<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【CTF】simple HTTP method</title>
    <url>/2020/03/10/%E3%80%90CTF%E3%80%91simpleHTTPmethod/</url>
    <content><![CDATA[<p>GET[] 与 POST[] 的区别：</p>
<p>GET方式会将表单中的数据以URL字符串的形式发送给服务器<br>将test.php以GET方式提交，浏览器地址栏会显示<br><a href="http://localhost/test.php?key1=value1&amp;key2=value2" target="_blank" rel="noopener">http://localhost/test.php?key1=value1&amp;key2=value2</a><br>以”?”开头的字符串称为URL字符串</p>
<p>则$GET[“key1”]=value1</p>
<p>​    $GET[“key2”]=value2</p>
<p>将test.php以POST方式提交，浏览器地址栏会显示<br><a href="http://localhost/test.php" target="_blank" rel="noopener">http://localhost/test.php</a></p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>【CTF】代码审计-01</title>
    <url>/2020/03/14/%E3%80%90CTF%E3%80%91%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-01/</url>
    <content><![CDATA[<p><strong>md5加密相等绕过</strong></p>
<p>md5()中需要一个是string类型的参数，但当传递一个array时，md5()不会报错，只是无法正确求出array的md5值，这样会导致任意两个array的md5值都会相等。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$test</span>=<span class="variable">$_GET</span>[<span class="string">'test'</span>]; </span><br><span class="line"><span class="variable">$test</span>=md5(<span class="variable">$test</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$test</span>==<span class="string">'0'</span>) &#123; </span><br><span class="line">        print <span class="string">'You passed stage 1.&lt;br /&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">        print <span class="string">"Game over at stage 1."</span>; </span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果hash值以“0e”开头，后边都是数字，再与数字比较，就会被解释为0*10^n，还是为0，就会被判断相等，绕过登录环节。</p>
<p>PHP在处理哈希字符串时，会利用”<code>!=</code>”或”<code>==</code>”来对哈希值进行比较，它把每一个以“0e”开头的哈希值都解释为0。如果两个不同的值经过哈希以后，都是“0e”开头，那么PHP将会认为他们相同。</p>
<p>eg：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line"><span class="number">0e830400451993494058024219903391</span></span><br></pre></td></tr></table></figure>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">s878926199a</span><br><span class="line"><span class="number">0e545993274517709034328855841020</span></span><br></pre></td></tr></table></figure>
<p><strong>sha()函数比较绕过</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$_GET</span>[<span class="string">'name'</span>] == <span class="variable">$_GET</span>[<span class="string">'password'</span>])&#123;</span><br><span class="line">        print <span class="string">'Your password can not be your name.'</span>;</span><br><span class="line">        <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sha1(<span class="variable">$_GET</span>[<span class="string">'name'</span>]) === sha1(<span class="variable">$_GET</span>[<span class="string">'password'</span>]))&#123;</span><br><span class="line">        print <span class="string">'You passed stage 2.&lt;br /&gt;'</span>;</span><br><span class="line">        print <span class="string">'Flag: '</span>.<span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看似不可能，但如果把这两个字段构造为数组，如：?name[]=a&amp;password[]=b，这样在第一处判断时两数组确实是不同的，但在第二处判断时由于<strong>sha1()函数无法处理数组类型</strong>，将报错并返回false，if 条件成立，获得flag。经验证md5()函数同样存在此漏洞。</p>
<p><strong>bool欺骗</strong></p>
<p>当存在json_decode和unserialize的时候，部分结构会被解释成bool类型，也会造成欺骗。</p>
<p><strong>通过数组绕过函数</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">'content'</span>]))&#123;</span></span><br><span class="line"><span class="php">    $filename = <span class="string">'config.php'</span>;</span></span><br><span class="line"><span class="php">    $content = $_GET[<span class="string">'content'</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="php">    <span class="keyword">if</span>(is_int(stripos($content, <span class="string">'php'</span>)) || is_int(stripos($content, <span class="string">'&lt;'</span>))) &#123;</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">'Invalid input'</span>;</span></span><br><span class="line"><span class="php">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="php">        file_put_contents($filename, $content);</span></span><br><span class="line"><span class="php">        <span class="keyword">echo</span> <span class="string">'Success'</span>;</span></span><br><span class="line"><span class="php">    &#125;</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure>
<p>stripos()函数：查找字符串在另一字符串中第一次出现的位置（不区分大小写），即在content文件中查找‘php’第一次出现的位置和’&lt;’第一次出现的位置，有则返回位置，没有则返回false。字符串位置从 0 开始，不是从 1 开始。</p>
<p>file_put_contents()函数：把一个字符串写入文件中，把content参数的值写入config.php文件中。</p>
<p>绕过stripos()函数，就不用执行if分支。可以使用数组绕过，即让content为数组形式，在config.php里得到flag。</p>
<p><a href="https://blog.csdn.net/wy_97/article/details/79088218" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="https://www.cnblogs.com/gaonuoqi/p/11408083.html" target="_blank" rel="noopener">参考链接2</a></p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>【Crypto】EIGamal</title>
    <url>/2021/01/30/%E3%80%90Crypto%E3%80%91EIGamal/</url>
    <content><![CDATA[<h1 id="eigamal公钥密码体制"><a href="#EIGamal公钥密码体制" class="headerlink" title="EIGamal公钥密码体制"></a>EIGamal公钥密码体制</h1><p>EIGamal 密码体制基于离散对数问题。</p>
<a id="more"></a>
<h2 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h2><p>给定一个正整数m，如果两个整数a和b满足（a-b）能够被m整除，即（a-b）/m得到一个整数，那么就称整数a与b对模m同余，记作<code>a ≡ b(mod m)</code>。</p>
<p>两个整数a、b，若它们除以整数m所得的余数相等，则称a与b对模m同余或a同余于b模m，记作<code>a ≡ b(mod m)</code>。</p>
<h3 id="同余性质"><a href="#同余性质" class="headerlink" title="同余性质"></a>同余性质</h3><img src="/2021/01/30/%E3%80%90Crypto%E3%80%91EIGamal/%E5%90%8C%E4%BD%99%E6%80%A7%E8%B4%A8.JPG" class title="同余性质">
<h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><img src="/2021/01/30/%E3%80%90Crypto%E3%80%91EIGamal/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.PNG" class title="离散对数">
<h2 id="密码体制"><a href="#密码体制" class="headerlink" title="密码体制"></a>密码体制</h2><img src="/2021/01/30/%E3%80%90Crypto%E3%80%91EIGamal/%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6.PNG" class title="密码体制">
<p>！！！开心O(∩_∩)O，了解 EIGamal 公钥密码体制后，《基于配对的密码学》P47 第一个公式迎刃而解</p>
<h1 id="eigamal签名方案"><a href="#EIGamal签名方案" class="headerlink" title="EIGamal签名方案"></a>EIGamal签名方案</h1><h2 id="签名方案"><a href="#签名方案" class="headerlink" title="签名方案"></a>签名方案</h2><h2 id="签名方案的安全性"><a href="#签名方案的安全性" class="headerlink" title="签名方案的安全性"></a>签名方案的安全性</h2>]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>密码学原理与实践</tag>
      </tags>
  </entry>
  <entry>
    <title>【Crypto】无证书加密体制</title>
    <url>/2021/02/15/%E3%80%90Crypto%E3%80%91%E6%97%A0%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/</url>
    <content><![CDATA[<h1 id="形式化模型"><a href="#形式化模型" class="headerlink" title="形式化模型"></a>形式化模型</h1><p>在无证书加密体制中，用户的私钥 $S_U$ 实际上由两部分组成，一部分是 KGC 生成的 $D_U$，另一部分是用户自己生成的 $x_U$，这种方法使得 KGC 不知道用户的完全私钥 $S_U$，<u>解决了</u>基于身份的密码体制中<strong>密钥托管问题</strong>。此外，私钥包含了 KGC 生成的部分私钥 $D_U$，<u>消除了</u>基于 PKI 密码体制中的<strong>公钥证书</strong>。</p>
<a id="more"></a>
<img src="/2021/02/15/%E3%80%90Crypto%E3%80%91%E6%97%A0%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.JPG" class title="通信模型">
<p>攻击者希望从密文 c 中恢复出明文信息 m 或者是获得接收者的私钥 $S_U$ 。</p>
<h1 id="机密性游戏"><a href="#机密性游戏" class="headerlink" title="机密性游戏"></a>机密性游戏</h1><h2 id="类型-i-敌手"><a href="#类型-I-敌手" class="headerlink" title="类型 I 敌手"></a>类型 I 敌手</h2><p>（敌手不知道主密钥，但可以任意替换用户的公钥）</p>
<img src="/2021/02/15/%E3%80%90Crypto%E3%80%91%E6%97%A0%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E6%97%A0%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6%E7%9A%84%E7%B1%BB%E5%9E%8BI%E9%80%82%E5%BA%94%E6%80%A7%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB%E6%B8%B8%E6%88%8F.JPG" class title="无证书加密体制的类型I适应性选择密文攻击游戏">
<p>在<strong>解密询问阶段</strong>，如果敌手 A 已经替换了 $ID_U$ 的公钥，那么 C 不知道公钥对应的秘密值，这种情况下，如果要求敌手 A 提供公钥对应的秘密值 $x_U$，那么称这种解密询问为<strong>弱解密询问</strong>，否则称为<strong>强解密询问</strong>。</p>
<h2 id="类型-ii-敌手"><a href="#类型-II-敌手" class="headerlink" title="类型 II 敌手"></a>类型 II 敌手</h2><p>（敌手知道主密钥 s ，但不能替换用户的公钥）</p>
<img src="/2021/02/15/%E3%80%90Crypto%E3%80%91%E6%97%A0%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E6%97%A0%E8%AF%81%E4%B9%A6%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6%E7%9A%84%E7%B1%BB%E5%9E%8BII%E9%80%82%E5%BA%94%E6%80%A7%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB%E6%B8%B8%E6%88%8F.JPG" class title="无证书加密体制的类型II适应性选择密文攻击游戏">
<h1 id="ap体制"><a href="#AP体制" class="headerlink" title="AP体制"></a>AP体制</h1>]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>基于配对的密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【Crypto】基于身份的加密体制</title>
    <url>/2021/01/31/%E3%80%90Crypto%E3%80%91%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/</url>
    <content><![CDATA[<h1 id="形式化模型"><a href="#形式化模型" class="headerlink" title="形式化模型"></a>形式化模型</h1><p>在基于身份的加密体制中，发送者可以在接收者还没有私钥的情况下加密一个消息给接收者，接收者可以在收到密文之后，才向 PKG 申请私钥进行解密。这种特征特别适合<u>电子邮件应用</u>。</p>
<a id="more"></a>
<img src="/2021/01/31/%E3%80%90Crypto%E3%80%91%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.JPG" class title="通信模型">
<p>攻击者希望从密文 c 中恢复出明文信息 m 或者是获得接收者的私钥 $S_U$ 。</p>
<img src="/2021/01/31/%E3%80%90Crypto%E3%80%91%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6%E7%9A%84%E9%80%89%E6%8B%A9%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB%E6%B8%B8%E6%88%8F.JPG" class title="基于身份的加密体制的选择明文攻击游戏">
<img src="/2021/01/31/%E3%80%90Crypto%E3%80%91%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6%E7%9A%84%E9%80%82%E5%BA%94%E6%80%A7%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB%E6%B8%B8%E6%88%8F.JPG" class title="基于身份的加密体制的适应性选择密文攻击游戏">
<p><strong>IND-IBE-CPA 与 IND-IBE-CCA2 的比较</strong>：</p>
<p>相同点：攻击者在 阶段2 都可以像 阶段1 那样执行多项式有界的适应性询问。</p>
<p>不同点：在询问阶段 IND-IBE-CPA 只进行<u>密钥提取询问</u>，IND-IBE-CCA2 进行<u>密钥提取询问</u>和<u>解密询问</u>。</p>
<h1 id="bf体制"><a href="#BF体制" class="headerlink" title="BF体制"></a>BF体制</h1><p>即，由 Boneh 和 Franklin 提出的基于身份的加密体制。</p>
<h2 id="basicident体制"><a href="#BasicIdent体制" class="headerlink" title="BasicIdent体制"></a>BasicIdent体制</h2><p>这个体制不能抵抗适应性选择密文攻击。P51</p>
<img src="/2021/01/31/%E3%80%90Crypto%E3%80%91%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E5%AE%9A%E7%90%863-1.JPG" class title="定理3-1">
<h3 id="定理31的证明"><a href="#定理3-1的证明" class="headerlink" title="定理3.1的证明"></a>定理3.1的证明</h3><p>第一步：证明针对 BasicIdent 体制的选择明文和身份攻击可以转换成 BasicPub 体制的选择明文攻击。</p>
<img src="/2021/01/31/%E3%80%90Crypto%E3%80%91%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E5%BC%95%E7%90%863-1.JPG" class title="引理3-1">
<p>第二步：证明在 BDH 假设下，BasicPub 体制是 IND-CPA 安全的。</p>
<img src="/2021/01/31/%E3%80%90Crypto%E3%80%91%E5%9F%BA%E4%BA%8E%E8%BA%AB%E4%BB%BD%E7%9A%84%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6/%E5%BC%95%E7%90%863-2.JPG" class title="引理3-2">
<h2 id="fullident体制"><a href="#FullIdent体制" class="headerlink" title="FullIdent体制"></a>FullIdent体制</h2><p>这个体制适应性选择密文安全。P57</p>
<h2 id="waters体制"><a href="#Waters体制" class="headerlink" title="Waters体制"></a>Waters体制</h2><p>不依赖随机预言模型的基于身份的加密体制。P58</p>
<p><strong>弱点</strong>：</p>
<ol>
<li>不能取得适应性选择密文安全性。（虽然可以利用 <strong>Fujisaki-Okamoto 转换</strong>将一个选择明文安全的 BasicIdent 体制转换成适应性选择密文安全的 FullIdent 体制，但不能将 Waters 体制转换成适应性选择密文安全的基于身份的加密体制。<strong>Fujisaki-Okamoto 转换</strong><u>在随机预言模型下成立，但在标准模型下不成立。</u>）</li>
<li>公共参数较大。</li>
<li>在安全证明中，规约较松。</li>
</ol>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>基于配对的密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Basic Key Exchange</title>
    <url>/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/</url>
    <content><![CDATA[<h1 id="trusted-3rd-parties"><a href="#Trusted-3-rd-parties" class="headerlink" title="Trusted 3^rd parties"></a>Trusted 3^rd parties</h1><p>两个用户可以通过共享一个密钥来保护通信数据，那么，这两个用户是如何产生这个共享密钥的？</p>
<a id="more"></a>
<h2 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h2><p>试想，世界上有 n 位用户，那么这些用户如何管理这些密钥？</p>
<p>假设 n=4 ，一种方案是，每一对用户共享一对密钥，这样用户需要管理的共享密钥太多。</p>
<p>有一种方法叫<strong>在线可信任第三方</strong>，使用 TTP 表示可信任第三方，每个用户与可信任第三方共享一个单独的密钥，这个设计的好处是每个用户只需记住一个密钥。当 Alice 想和 Bob 通信时会发生什么？</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%9C%A8%E7%BA%BF%E5%8F%AF%E4%BF%A1%E4%BB%BB%E7%AC%AC%E4%B8%89%E6%96%B9.PNG" class title="在线可信任第三方">
<p>双方必须参加某个特定协议，在协议的最后，他们会共享一个密钥 K_AB ，而攻击者不能知道 K_AB ，Alice 想和 Bob <strong>如何生成这一共享密钥 K_AB</strong> ？</p>
<p>看一个玩具协议，<u>这个协议对窃听是安全的，对篡改或主动攻击不安全</u>，Alice 有她的密钥 $k_A$ ，Bob有他的密钥 $k_B$ ，$k_A$、$k_B$ 是与可信任第三方共享的。这个协议如下工作：</p>
<p>Alice 开始时会发送一条信息，给可信任第三方，说她想要一个密钥用于和Bob通信，可信任第三方会选择一个随机密钥 k_AB ，那么可信任第三方生成了他们的共享密钥，他会回复一条信息给 Alice ，这条信息包含两部分，①使用 $k_A$ 加密的信息，这个密钥在 Alice 和 Bob 之间使用，k_AB 包含在这条信息里，即，这里被加密的信息是，k_AB 加上“这个密钥是Alice 和 Bob的共享密钥”这一事实。②票据，这个票据是为 Bob 加密的信息，是使用 $k_B$ 加密的，加密的信息依然是“这个密钥在 Alice 和 Bob 之间使用”，然后 TTP 把这个事实附在密钥 k_AB 后面。这里使用的加密系统 E 是一个 CPA 安全密码，当 Alice 想与 Bob 通信时，Alice 会解密给她的那部分信息得到密钥 k_AB ，然后把票据给 Bob ，Bob 收到这个票据，使用 $k_B$ 解密得到密钥 k_AB ，他们就有了共享密钥。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%88%A9%E7%94%A8%E7%8E%A9%E5%85%B7%E5%8D%8F%E8%AE%AE%E4%BA%A7%E7%94%9F%E5%85%B1%E4%BA%AB%E5%AF%86%E9%92%A5.PNG" class title="利用玩具协议产生共享密钥">
<p><strong>为什么这个协议是窃听安全的？</strong></p>
<p>当我们只考虑对窃听的安全时，窃听者在这个协议中看到两个密文，我们的目标是，<u>窃听者没有任何关于交换密钥 k_AB 的信息</u>，这点可由密码 E,D 的 CPA 安全性直接得到。</p>
<p>对于每个密钥交换，TTP是必须使用的，这个协议的另一个性质是，TTP 知道所有的会话密钥，如果 TTP 被破解了，那么攻击者可以轻松获得所有系统中用户之间已经交换过的密钥。这个机制的优点是，它只使用对称密钥密码学，是快速有效的。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E7%8E%A9%E5%85%B7%E5%8D%8F%E8%AE%AE.PNG" class title="玩具协议">
<p><strong>这个协议对主动攻击是完全不安全的，如，重放攻击：</strong></p>
<p>设想 Alice 从 Bob 那里订购了一本书，Bob 接收了这本书的付款，然后发给 Alice 一份这本书的拷贝，交易完成。设想攻击者记下了 Alice 和在线商家 Bob 的会话，稍后向 Bob重放这段会话，Bob 就会认为，Alice刚刚重新订购了这本书的另一份拷贝，Bob 就会再收一次 Alice 的钱，然后发给 Alice 这份拷贝，所以，重放会话会对 Alice 造成巨大危害</p>
<p>我们能否设计出密钥交换协议，对窃听和主动攻击都保持安全呢？<strong>我们能否设计出安全的密钥交换协议，但不需要一个在线的可信任第三方呢？</strong>答案是可能的。事实上，这是公钥密码学的起点，思路如下：</p>
<p>①由 Ralph Merkle 于1974年提出。</p>
<p>②由 Diffie 与 Hellman 于 1976年提出。</p>
<p>③由 Rivest，Shamir，Adleman 于1977年提出。</p>
<p>近年的新想法：①基于身份的加密（IBE）2001。②泛函加密，2011。</p>
<h1 id="merkle-puzzles"><a href="#Merkle-Puzzles" class="headerlink" title="Merkle Puzzles"></a>Merkle Puzzles</h1><p>不借助可信第三方的密钥交换协议。</p>
<p>这里我们通常的设定是，有 Alice 和 Bob ，他们想生成一个共享密钥，他们互相发送信息，在协议的最后，他们必须获得某个双方都知道的共享密钥 k ，窃听通信流量的攻击者绝对无法得知这个 k 是什么，目前，我们只关心监听会话的攻击者，我们将看到三个协议来达到这一目标。</p>
<p>能借助对称密码学做到吗？可不可以只使用分组密码或哈希函数等？答案是肯定的，但是得到的协议<u>非常低效，在实际中从未被使用</u>，不过这些协议非常简单，<strong>Merkle 谜题协议工作流程</strong>如下：</p>
<p>这个协议的主要工具叫做一个“谜题”，谜题是指难解的问题，但通过努力还是可以解出的。假设我们有一个对称密码，使用 128 位密钥，以 AES 为例，假设我选择的 AES 密钥的前 96 位都是 0 ，只有剩下的 32 位是非零的，并随机选取的。现在我加密一段固定的明文，比如“message”，使用 128 位密钥，大部分位都是 0 ，加密的结果叫做“谜题”，称之为谜题是因为不难找到密钥 P ，只需要尝试 2^32 种可能性，看是否得到明文“message”，如果是的话，就知道已经发现了正确的 P 。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/Merkle%E8%B0%9C%E9%A2%98%E5%8D%8F%E8%AE%AE.PNG" class title="Merkle谜题协议">
<p><strong>Merkle谜题协议工作方式</strong>如下：</p>
<p>Alice 开始时生成大量的谜题，特别地，她将生成 2^32 个不同的谜题，对于每个谜题，她生成的方法如下：选择一个 32 位 随机谜题 $P_i$ ，i 从 1 遍历 到 2^32 ，然后她再选择两个值 $x_i$ 和 $k_i$ ，每个 128 位，现在她会使用谜题 $P_i$ 作为一个 AES 密钥，前 96 位都是 0 ，后 32 位非零，所以这个密钥的熵是 32 位，如果只有 2^32 个密钥，现在他要使用这个密钥加密的明文是下图中红色部分的信息，她对所有的谜题都这么做<u>得到了 2^32 个不同的谜题，然后把所有的谜题发送给 Bob</u> 。</p>
<p>Bob 接收了 2^32 个不同的谜题，他只选择其中一个，不需要记住所有的谜题，比如说他选择了谜题 j ，他<u>花了 2^32 的时间来解决这个谜题</u>，他要检查明文的前面部分是否以“Puzzle”开头，如果是，Bob 就知道了他正确的解决了这个谜题，然后他就获得了嵌在谜题里的数据 $x_j$ 和 $k_j$ ，$x_j$ 是这个谜题的标记，$k_j$ 是他们要使用的秘密信息，<u>然后他把 $x_j$ 发送给 Alice</u> ，$k_j$ 自己保留，作为秘密。</p>
<p>Alice 查找谜题数据库，她会<u>查到谜题 $x_j$ ，就知道了 Bob 选择的密钥 $k_j$</u> ，他们就有了这个共享密钥。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/Merkle%E8%B0%9C%E9%A2%98%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.PNG" class title="Merkle谜题协议工作方式">
<p>窃听者看着 n 个谜题发送过去，看到 Bob 返回了一个 $x_j$ ，攻击者并不知道 Bob 解的是哪个谜题，他看到的只是谜题中的随机值，为了破解这个协议，窃听者会解决所有的谜题，直到他找到正确的谜题里面有 $x_j$ ，那么攻击者就会还原 $k_j$ ，那么，攻击者要做多少工作？$n^2$ 。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/Merkle%E8%B0%9C%E9%A2%98%E5%8D%8F%E8%AE%AE%E5%9B%BE%E8%A1%A8%E5%BD%A2%E5%BC%8F.PNG" class title="Merkle谜题协议图表形式">
<p><strong>我们能否只使用对称密码，做得比平方鸿沟更好呢？</strong>答案是未知的，我们不知道平方鸿沟是否是我们所能做到的最好的结果。</p>
<p>事实上，如果我们把分组密码或哈希函数当作黑盒神谕来使用，换句话说，参与者只能询问分组密码或询问哈希函数在特定点的值并获得结果，如果这些是参与者所能做到的全部，换句话说，参与者不能实际使用分组密码或哈希函数的实现，那么事实上有一个结果告诉我们，<strong>如果参与者只能询问分组密码在 n 个点的值，那么总有一个攻击运行在 n 平方的时间里</strong>。这就是说，如果你只能使用分组密码作为一个黑盒进行询问，那么无论交换什么密钥，这个密钥交换总有一个平方时间的攻击。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/tip.PNG" class title="tip">
<p>我们发现，我们需要比分组密码和哈希函数更多的技术，实际上，我们需要具备非常特殊性质的函数，为了构建这些函数，我们实际上必须依赖于某些代数。</p>
<h1 id="the-diffie-hellman-protocol"><a href="#The-Diffie-Hellman-protocol" class="headerlink" title="The Diffie-Hellman protocol"></a>The Diffie-Hellman protocol</h1><h2 id="diffie-hellman-协议"><a href="#Diffie-Hellman-协议" class="headerlink" title="Diffie-Hellman 协议"></a>Diffie-Hellman 协议</h2><p>这是我们第一个实用的密钥交换机制。</p>
<p>Alice 和 Bob 素未谋面，却想交换一个共享密钥，然后他们可以使用这个密钥来用于相互安全通信，我们只看对窃听攻击的安全性，攻击者不能篡改网络中的数据，在密钥交换协议的最后，Alice 和 Bob 应该有一个共享密钥，但窃听攻击者无法知道交换的密钥是什么。<strong>我们能否做与Merkle谜题协议同样的事情，但现在能获得一个指数级鸿沟，横亘在攻击者和参与者的工作之间？</strong>我们不能仅凭分组密码技术获得这个指数级鸿沟，我们必须使用拥有比对称原型更多结构的难解问题，那么我们使用一点代数。</p>
<p><strong>Diffie-Hellman 协议是如何工作的呢？</strong></p>
<p>首先，我们选某个固定的大质数，记为 p ，然后我们选一个固定的整数 g ，g 正好在从 1 到 p 的范围中，这里的 p 和 g 是 Diffie-Hellman 协议的参数，它们一经选择就不再改变。这个协议如下工作：</p>
<p>开始时， Alice 选择某个随机数 a ，范围是 1 到 p-1 ，然后她将计算 $g^a$ (mod p) ，这是可以有效计算的，我们把这个计算的结果记为 A ，发送给 Bob 。现在，Bob 做同样的事情，他选择一个随机数 b ，范围是 1 到 p-1 ，计算 $g^b$ (mod p) ，结果记为 B ，发送给 Alice 。现在他们宣布已经共享了一个密钥，那么<strong>这个共享的密钥是什么呢？</strong>我们记为 k_AB = g^(ab) (mod p) 。事实上，双方都可以计算 k_AB ，Alice 可以取值 B ，计算 $B^a$ (mod p) ，获得 g^(ab) (mod p) ，Bob 也可以做类似的事情。这个协议顺利工作的本质原因是<strong>指数的代数性质</strong>。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/Diffie-Hellman%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.PNG" class title="Diffie-Hellman协议的工作过程">
<p><strong>为什么这个协议是安全的？</strong></p>
<p>窃听者能看到什么？他能看到质数 p 和生成元 g ，这些值是永远固定不变的，每个人都知道它们，攻击者还能看到 Alice 发送给 Bob 的 A 和 Bob 发送给 Alice 的 B ，那么，窃听者能计算出 g^(ab) (mod p) 吗？更一般地，我们定义 DH 函数，我们说 DH 函数定义在 g 上，给定 $g^a$ 和 $g^b$ ，能否计算 g^(ab) ？p 大约有 600 个十进制位，计算这个很大的质数模 p 乘法群上的函数，有多困难？</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/DH%E5%87%BD%E6%95%B0%E5%AE%89%E5%85%A8%E6%80%A7.PNG" class title="DH函数安全性">
<p>目前已知的事实，这个质数正好有 n 位长，计算 DH 函数已知最好的算法是一个更为一般的算法，用来计算离散对数函数，这个算法叫做<strong>普通数域筛法</strong>。这个算法的运行时间是指数级的，运行时间大约是 e 的 n 的立方根次方，事实上这个算法的运行时间的严格表达式要比这个复杂的多，这个算法有时叫做<strong>亚指数算法</strong>，因为这里的指数项正比于 n 的立方根，而不是 n ，这说明即使这个问题很难，它也不是真正的指数级时间的问题，运行时间的指数是与 n 的立方根成正比的。</p>
<p>看几个例子，如果你的密码有 80 位密钥，那大概需要 1000 位的模，这个算法是说我们可以以时间大约是 e 的 1024 的立方根次方解决 DH 问题，这不是很准确，事实上指数上有一些常数项。这个例子告诉大家，如果有一个亚指数级算法，即使看到这个问题规模很大，比如 1000 位，因为这个立方根的作用，其实总体并没有那么大。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E6%99%AE%E9%80%9A%E6%95%B0%E5%9F%9F%E7%AD%9B%E6%B3%95.PNG" class title="普通数域筛法">
<p><strong>如果要使用 Diffie-Hellman 协议来交换会话密钥，用于分组密码的会话密钥要有合适的密钥大小，使得密钥交换协议的安全性和之后使用的分组密码的安全性相当。</strong></p>
<p>计算在椭圆曲线域上的 Diffie-Hellman 函数要比计算质数模乘法上的 Diffie-Hellman 困难得多，因为问题更加困难，可以使用小得多的代数对象。这些模在椭圆曲线上增长的不快，通常从使用模算术到使用椭圆曲线域有一个缓慢的转换。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%9F%9F.PNG" class title="椭圆曲线域">
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>Diffie-Hellman 协议对抗主动攻击时，是完全不安全的，当存在<strong>中间人攻击</strong>时，我们需要对这个协议做些补充，让它对中间人攻击也是安全的。</p>
<p><strong>这个协议为什么对主动攻击是不安全的？</strong></p>
<p>假设我们有中间人 MiTM 试图窃听 Alice 和 Bob 之间的会话，协议开始时，Alice 发送 $g^a$ 给 Bob ，中间人截获了这个 $g^a$ ，他将取 Alice 发出的信息，换成他自己的信息，记为 A’ ，写成 $g^a$’ ，中间人选择了他自己的 a’ ，发送给 Bob 。</p>
<p>Bob并不知道中间人对通信流量做了手脚，他只能获得 A’ ，Bob 会回复他的值 B ，$g^b$ 给 Alice ，中间人截获 B ，产生自己的 b’ ，然后发送 B’=$g^b$’ 给 Alice 。</p>
<p>Alice 将计算她的密钥得到 g^(ab’) ，Bob 计算他的密钥 g^(ba’) ，而对于中间人，他既知道 A’ ，又知道 B’ ，他可以计算 g^(ab’) ，也可以计算 g^(ba’) ，因此现在它可以扮演中间人。</p>
<p>当 Alice 发送一个加密的信息给 Bob ，中间人可以轻松解密这个信息，然后中间人重新使用 Bob 的密钥加密这个信息发送给 Bob ，这样 Alice 发送信息给 Bob ，Bob 接收信息认为这个信息是安全的。中间人可以完全读到信息内容，如果他愿意，可以修改它，所以这个协议是完全不安全的。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.PNG" class title="中间人攻击">
<h2 id="diffie-hellman-协议的非互动性"><a href="#Diffie-Hellman-协议的非互动性" class="headerlink" title="Diffie-Hellman 协议的非互动性"></a>Diffie-Hellman 协议的非互动性</h2><p>这个协议可以被视为一个非互动的协议，设想我们有一组几百万用户，他们中每个都将选取一个随机的私密值，然后在他们的 Facebook 页面上写下他们对 Diffie-Hellman 协议的贡献。</p>
<p>现在，如果 Alice 和 Charlie 想建立一个共享密钥，他们无需相互通信，Alice 只要去 Charlie 的公共页面，Charlie 只要去 Alice 的公共页面，刹那间，他们就共享了一个密钥，Alice 知道了 g^ca ，Charlie 知道了 g^ac ，某种意义上，一旦他们在公共页面发布了他们对 Diffie-Hellman 协议的共享，他们根本不需要互相通信就能建立共享密钥。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/Diffie-Hellman%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%80%A7%E8%B4%A8.PNG" class title="Diffie-Hellman协议的性质">
<p><strong>开放问题</strong>：我们能否对多于两方的用户做这些呢？换句话说，比如我们有 4 方，所有人都在他们的 Facebook 公共页面上发布了他们的值，现在我们想只通过阅读 Facebook 页面，所有人都可以建立共享密钥。我们是否可以非互动的建立这些共享密钥？n=2 就是 Diffie-Hellman 协议；n=3 ，我们也知道怎么做，有一个已知的协议由 Joux 提出的使用了非常高级的数学；对于 n=4,5… 这个问题是完全开放的，即使只有 4 人，我们也不知道怎么做。</p>
<h1 id="public-key-encryption"><a href="#Public-key-encryption" class="headerlink" title="Public-key encryption"></a>Public-key encryption</h1><p>一个基于公钥加密的不同的方法，依然只看对窃听的安全性，不允许攻击者修改数据或实施其他形式的主动攻击。</p>
<h2 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h2><p>就像对称加密一样，有一个加密算法和解密算法，不过这里的加密算法有一个密钥，叫做<strong>公钥</strong> PK，这个公钥属于 Bob ，而解密算法有一个不同的密钥，叫做<strong>私钥</strong> SK，也属于 Bob 。这两个密钥优势叫做<strong>密钥对</strong>。通常，加密这个信息的算法是，加密算法产生一个使用公钥加密的密文，当密文交给解密算法时，解密算法会输出对应的明文</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86.PNG" class title="公钥加密">
<p>公钥加密实际上由三个算法组成：密钥生成算法 G，E，D。当运行 G 时，会产生两个密钥，分别是公钥和私钥，通常，我们有<u>一致性</u>，即密钥生成算法输出的公钥和私钥，如果我们使用公钥加密明文，然后使用私钥解密，我们可以获得最初的明文。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%862.PNG" class title="公钥加密2">
<h2 id="公钥加密系统的安全游戏"><a href="#公钥加密系统的安全游戏" class="headerlink" title="公钥加密系统的安全游戏"></a>公钥加密系统的安全游戏</h2><p>使用与之前用过的语义安全同样的概念，但游戏不同。这里，挑战者运行密钥生成算法来产生一对公钥和私钥，他会把公钥给攻击者，挑战者对私钥进行保密。攻击者会输出两个长度相等的明文 $m_0$ 和 $m_1$ ，挑战者会给攻击者 $m_0$ 或 $m_1$ 的加密结果，我们定义两个实验，在 实验0 中，攻击者得到 $m_0$ 加密的结果，在 实验1 中，攻击者得到 $m_1$ 加密的结果，攻击者的目标是<u>猜他得到的是哪个明文的加密结果</u>，我们把他的猜测作为 实验0 或 实验1 的输出。在公钥加密中，没必要赋予攻击者以实施选择明文攻击的能力，因为在对称密钥系统中，攻击者必须请求他选择的明文的加密，而在公钥系统中，攻击者拥有公钥，他可以自己加密任何他想加密的明文。</p>
<p>我们说，如果攻击者无法区分 实验0 和 实验1 ，一个公钥系统 (G,E,D) 是语义安全的。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E5%85%A8%E6%B8%B8%E6%88%8F.PNG" class title="公钥加密系统的安全游戏">
<h2 id="共享密钥的建立"><a href="#共享密钥的建立" class="headerlink" title="共享密钥的建立"></a>共享密钥的建立</h2><p>①Alice 开始时会使用密钥生成算法为自己产生一个随机公钥、密钥对，然后把公钥 PK 发送给 Bob ，并告诉 Bob 这个信息来自 Alice 。</p>
<p>②Bob 会产生一个随机的 128 位值 x ，回复 Alice 这个信息来自 Bob ，他还会返回用 Alice 的公钥加密的 x 。</p>
<p>③Alice 收到这个密文使用私钥进行解密，解密结果会给她值 x 。</p>
<p>现在，x 可以被用来作为双方共享的密钥。</p>
<p>这与 Diffie-Hellman协议 很不相同，这里双方必须有先后的通信，Bob 不能发送他的信息，直到他收到了 Alice 的信息，换句话说，Bob 不能用 Alice 的公钥加密 x ，直到他收到了 Alice 的公钥。即使在 Facebook 发布了公钥，依然需要先发送信息 x 才能建立共享密钥。但在 Diffie-Hellman协议中，双方可以在任何时候发送他们的信息，没有对信息的发送顺序的强制要求。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%85%B1%E4%BA%AB%E5%AF%86%E9%92%A5%E7%9A%84%E5%BB%BA%E7%AB%8B.PNG" class title="共享密钥的建立">
<p><strong>为什么这个协议是安全的？（只考虑对窃听的安全）</strong></p>
<p>在这个协议中，攻击者看到这个公钥和用公钥加密的 x ，他想得到 x ，现在我们知道这个公钥系统是语义安全的，这意味着攻击者不能区分 x 的加密和某个随机信息的加密，它仅仅是一个随机值，攻击者不能猜到。</p>
<p>即使这个协议对窃听是安全的，对抗中间人攻击时，它也是完全不安全的。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%AF%B9%E7%AA%83%E5%90%AC%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86.PNG" class title="对窃听安全的公钥加密">
<h2 id="中间人攻击"><a href="#中间人攻击-1" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>Alice 产生她的公钥、密钥对，中间人也产生他自己的公钥、密钥对，当 Alice 发送她的公钥给 Bob 时，中间人会截获这个公钥，然后对 Bob 说这个信息来自 Alice，Alice 的公钥是 PK’ 。</p>
<p>Bob 接收了这个信息，他认为自己获得了从 Alice 发来的信息，他会选择随机数 x 进行回复，它会返回用 PK’ 加密的 x ，中间人 截获这个信息，他会用其他信息来代替它，他的目标是确保这个密钥交换成功，中间人应该发送什么给 Alice 呢？我们把 Bob 发送的密文记为 c ，中间人使用自己的私钥解密 c 得知 x ，然后他继续用 Alice 的公钥加密 x ，把加密值发回给 Alice ，Alice 获得 x ，完成了与 Bob 的密钥交换。</p>
<p>中间人也知道这个 x ，中间人可以修改 Alice 和 Bob 互发的信息，这个协议是完全不安全的。</p>
<img src="/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.PNG" class title="公钥加密的中间人攻击">]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Authenticated Encryption</title>
    <url>/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/</url>
    <content><![CDATA[<h1 id="active-attack-on-cpa-secure-encryption"><a href="#Active-attack-on-CPA-secure-encryption" class="headerlink" title="Active attack on CPA-secure encryption"></a>Active attack on CPA-secure encryption</h1><h2 id="修改iv域的攻击例子"><a href="#修改IV域的攻击例子" class="headerlink" title="修改IV域的攻击例子"></a>修改IV域的攻击例子</h2><p>在这个攻击者的例子中，他们可以篡改通信，因此完全破坏了CPA安全加密的安全性。这告诉我们，实际上那种方法提供的完整性和私密性也会被破坏，换句话说，如果我们要安全地对抗主动型攻击者，完整性和私密性，两者都必须保证。</p>
<a id="more"></a>
<p>使用一个高度简化的 TCP/IP 版本，这样我们可以关注于攻击，不拘泥于细节。我们有两个机器互相通信，一用户坐在一台机器上，另一台机器是个服务器，现在，服务器上有 TCP/IP 协议栈在接收数据包，然后，根据这些数据包的目标地址域，服务器把数据包转发到合适的位置。比如，这里我们有两个进程在监听这些数据包，一个在网页服务器这里，另一个在用户 Bob 这里，网页服务器监听 80 端口，用户 Bob 监听 25 端口。现在，当一个数据包到来时，TCP/IP 协议栈查看目标端口，在这个情况下，端口号是 80 ，因此，协议栈把数据包转发到网页服务器，如果目标端口是 25 ，TCP/IP 协议栈会把数据包转发给 Bob 。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/TCPIP%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="TCP&#x2F;IP的例子">
<p>现在，一个很有名的安全协议叫 IPsec ，加密了发送方和接收方之间的 IP 数据包，在这里，发送方和接收方共享一个密钥，当发送方发送 IP 数据包时，使用密钥 k 来加密这些 IP 包。现在，一个数据包到达了服务器，<u>TCP/IP 栈会解密这个数据包，然后看目标端口</u>，把数据包发送到合适的位置去解密，注意，这里的数据 data 是被加密的，这种情况下，因为目标端口是 80，会把数据发给网页服务器 ；如果目标端口正好是 25 ，TCP/IP 栈会解密这个包看目标端口，然后把明文数据 stuff 发给相应进程。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/IPsec.PNG" class title="IPsec">
<p>没有完整性的话，这里我们不能获得任何的私密性。为什么呢？想象一下攻击者截获了一个特定的给网页服务器的数据包，换句话说，这是个加密的目标端口为 80 的数据包，攻击者实际上可以接收任何给 25 端口的数据包的解密，因为 TCP 协议栈会乐意解密给 25 端口的数据包，并把结果给正在监听的 Bob（这里Bob是攻击者），Bob会截获途中的数据包，防止数据包到达服务器，而他将修改这个数据包，将目标端口改为 25 ，这在密文里完成。然后，当这个数据包到达服务器时，目标端口说是 25 ，服务器会解密这个数据包，就把数据转发给了 Bob。现在，Bob通过改变目标端口，就可以读到本不该给他的数据。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E4%B8%8D%E8%83%BD%E8%8E%B7%E5%BE%97%E7%A7%81%E5%AF%86%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="不能获得私密性的例子">
<p>如果数据使用的是带随机 IV 的 CBC 加密（这是一个 CPA 安全的机制）的，如果是这种情况，攻击者很容易改变密文以获得新密文，其目标端口是 25 ，而非80，攻击者只需修改IV域即可。事实上，其他的一切都保持不变，攻击者捕捉的是一个 CBC 加密的数据包，从这个数据包里，攻击者知道了目标端口是 80 ，但不知道数据是什么，他的目标是构建一个新的加密的数据包，其目标端口是 25 。攻击者只需改变 IV ，而解密 CBC 加密的数据的方法是，本质上，第一个明文分组是第一个密文分组的解密再与 IV 异或的结果，在原数据包里会读到目标端口为 80 ，那么攻击者该如何修改 IV 使得目标端口读起来是 25 ？容易看出，如果攻击者取原 IV 和 …80… 、…25… 异或，然后容易看出这个新的 IV’ 与原密文信息一并发发送，当攻击者解密时，新的 IV’ 会抵消掉 80 异或 25 将目标端口变成 25 。这个简单的方法，通过修改 IV 域，攻击者可以重定向数据包。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E6%94%BB%E5%87%BB%E8%80%85%E6%94%B9%E5%8F%98IV%E7%9A%84%E6%96%B9%E5%BC%8F.PNG" class title="攻击者改变IV的方式">
<p>这个例子展示了，没有完整性（确保信息不被篡改），一个 CPA 安全的加密不可能提供私密性。如果攻击者可以在途中修改数据包，CPA 安全加密只能在<u>攻击者只能窃听数据的这一假设下</u>，提供私密性，但在例子中可以看到攻击者不能在途中修改密文（如果可以修改密文，一个简单的修改也会完全改变明文）。</p>
<h2 id="选择密文攻击的例子"><a href="#选择密文攻击的例子" class="headerlink" title="选择密文攻击的例子"></a>选择密文攻击的例子</h2><p>这是另外一个篡改攻击的例子，只需要能接收到网络流量即可，不需要攻击者在解密机器上操作。</p>
<p>有一个远程终端应用，每次用户敲击键盘，一个加密的键盘输入被送往服务器，我们假定键盘输入是使用计数器模式加密的，D 对应一个字节输入，每个 TCP/IP 包包含了一个校验和 T ，校验和只能使用于检测传输错误，如果服务器接收了一个含错误校验和的数据包，它就会简单地扔了这个包。现在攻击者想学习键盘输入的内容，他会截获这个数据包，不修改它，但他会记录下这个数据包，直接把包发给服务器，之后他会修改数据包，然后再把修改后的数据包发给服务器，他会把加密的校验和与一个值 t 异或，把加密的数据与一个值 s 异或，他用很多 t 和 s 来做这件事。计数器模式的一个性质是，如果你用 t 异或密文，解密后明文结果也是与 t 异或的。服务器解密这个修改后的数据包，得到的数据包有个异或了 t 的校验和，数据是异或了 s 的，如果修改的校验和对于这个修改的数据包来说是正确的，服务器会发送一个 ACK 应答包；如果不正确，服务器会扔掉这个数据包。所以攻击者可以根据能否收到 ACK 包学习到特定的 t 异或和 s 异或，是否对应一个有效的校验和，攻击者会学习到，如果我们修改了数据，把数据和特定值 s 异或，那么校验和就要与 t 异或，他学习到很多的 t 和 s 。根据如图所示方程，可以解出值 D 。这是一个很好的例子，被叫做<strong>选择密文攻击</strong>。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="选择密文攻击的例子">
<p>我们可以看到许多这种攻击的例子，攻击者可以修改途中的通信，以上两个例子叫做<strong>主动攻击</strong>。</p>
<p>以上两个例子可以证明，只提供 CPA 安全，或者说对抗窃听的安全，对抗主动攻击者时不能保证安全，不仅密文没有完整性，而且甚至连私密性也没有。<strong>CPA 安全密码并不提供认证加密。</strong></p>
<p>如果你的信息<u>只需要完整性，不需要私密性</u>，使用 <strong>MAC</strong> 就足够了。</p>
<p>如果你的信息<u>需要完整性，也需要私密性</u>，那么必须使用<strong>认证加密模式</strong>。</p>
<p><strong>CPA 安全模式不应该被使用在加密数据上</strong>，带随机 IV 的 CBC 可以为认证加密构建分组，但不应被单独使用。</p>
<h1 id="definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h1><h2 id="认证加密"><a href="#认证加密" class="headerlink" title="认证加密"></a>认证加密</h2><p><strong>认证加密</strong>：即存在主动攻击也能保持安全。认证加密是一个密码，通常是个加密算法，取密钥、信息为输入，还可选一个新鲜值，输出一个密文。解密算法通常是输出一个信息，但是这个解密算法可以输出一个特殊符号，叫做 <strong>底⊥</strong> 。<u>当解密算法输出符号 ⊥ 时，意味着密文是无效的</u>，应当被忽略，唯一要求是这个 ⊥ 不在信息空间内，它表示密文应当被拒绝。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86%E5%AE%9A%E4%B9%89.PNG" class title="认证加密定义">
<h2 id="一个安全的认证加密系统"><a href="#一个安全的认证加密系统" class="headerlink" title="一个安全的认证加密系统"></a>一个安全的认证加密系统</h2><p>必须满足连个性质：</p>
<p>①这个系统必须<u>对选择明文攻击是语义安全的</u>。</p>
<p>②这个系统必须<u>满足密文完整性</u>。</p>
<p>这意味着，即使攻击者能看到许多密文，他也不应该能阐述另外一个能顺利解密的密文。</p>
<h2 id="密文完整性游戏"><a href="#密文完整性游戏" class="headerlink" title="密文完整性游戏"></a>密文完整性游戏</h2><p>这里 (E,D) 是一个信息空间 M 上的密码。通常，挑战者开始时选择一个随机密钥 k ，攻击者可以提交他选择的信息，收到这些信息的加密，如图，$c_1$ 是 $m_1$ 的加密，$m_1$ 由攻击者选择，攻击者可以反复这样操作，直到获得了 q 个信息的密文。<u>他的目标是产生某个新的有效密文</u>，如果这个攻击者产生的<u>新密文</u>被正确的解密了，即被解密成了不是符号 ⊥ 的东西，我们说攻击者赢得了游戏。通常我们定义在这个密文完整性游戏中，攻击者的优势为挑战者在游戏最后输出 1 的概率，如果事实上对所有的有效攻击者，其赢得游戏的优势都是可忽略的，我们说这个密码有<strong>密文完整性</strong>。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E5%AF%86%E6%96%87%E5%AE%8C%E6%95%B4%E6%80%A7%E6%B8%B8%E6%88%8F.PNG" class title="密文完整性游戏">
<p>带随机 IV 的 CBC 不提供认证加密。因为对于攻击者来说，很容易赢得密文完整性游戏。攻击者提交一个密文，CBC 的解密算法从不输出符号 ⊥ ，他总是输出某些信息，攻击者轻松获得游戏胜利。（任何奇怪的随机密文都会被解密成某些不是符号 ⊥ 的东西。）</p>
<h2 id="认证加密的两个影响"><a href="#认证加密的两个影响" class="headerlink" title="认证加密的两个影响"></a>认证加密的两个影响</h2><h3 id="第一个影响认证"><a href="#第一个影响—认证" class="headerlink" title="第一个影响—认证"></a>第一个影响—认证</h3><p><strong>认证</strong>，意味着攻击者无法欺骗接收方 Bob ，让 Bob 认为 Alice 发送了一条她没有发过的信息。如图，攻击者与 Alice 互动，让她去加密任意他选择的信息，这是一个选择明文攻击，攻击者的目标是产生某些不是由 Alice 创造的密文，因为攻击者不能赢下这个密文完整性游戏，他不能做到，意味着当 Bob 接收能被加密算法正确解密的密文时，他知道信息一定来自某知道密钥 k 的人。特别地，如果 Alice 是唯一知道 k 的人，那么他知道密文确实是来自 Alice ，并非攻击者发出的某些修改。</p>
<p>唯一剩下的警告是，认证加密无法抵抗重放攻击。攻击者可以截获某些从 Alice 到 Bob 的密文，攻击者可以重放信息，这样重放的密文对 Bob 来说看起来也是有效的。比如，Alice 让 Bob 转账100元，重放密文会反复进行转账，因此，<strong>任何加密协议必须能防御重放攻击</strong>，但这是认证算法能直接阻止得了的。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BD%B1%E5%93%8D%E2%80%94%E8%AE%A4%E8%AF%81.PNG" class title="第一个影响—认证">
<h3 id="第二个影响它能抵抗一种非常强力的攻击者即实施选择密文攻击下节讨论"><a href="#第二个影响—它能抵抗一种非常强力的攻击者，即实施选择密文攻击（下节讨论）。" class="headerlink" title="第二个影响—它能抵抗一种非常强力的攻击者，即实施选择密文攻击（下节讨论）。"></a>第二个影响—它能抵抗一种非常强力的攻击者，即实施<strong>选择密文攻击</strong>（下节讨论）。</h3><h1 id="chosen-ciphertext-attacks"><a href="#Chosen-ciphertext-attacks" class="headerlink" title="Chosen ciphertext attacks"></a>Chosen ciphertext attacks</h1><p><strong>认证加密可以抵抗选择密文攻击</strong>。</p>
<p>前面讲过，攻击者有某个他想解密的密文 c ，攻击者可以欺骗解密服务器去解密某些密文，但这些密文还不是 c ，在这个例子里，攻击者可以获得特定密文的解密结果，但不会是全部的密文；在另一个例子里，攻击者可以通过提交密文给解密者来学到明文，在这个例子里，攻击者提交 TCP/IP 数据包给解密服务器，如果加密服务器发送 ACK 包，攻击者就知道了解密后的明文有一个有效的校验和，否则，解密后的明文没有有效的校验和。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB%E7%9A%84%E4%BE%8B%E5%AD%90%E5%9B%9E%E9%A1%BE.PNG" class title="选择密文攻击的例子回顾">
<p>为了解决选择密文攻击的威胁，我们定义一个非常广义的安全观点，叫做<strong>选择密文安全</strong>。在这里，攻击者可以进行<strong>选择明文攻击 CPA</strong> ，也可以进行<strong>选择密文攻击 CCA</strong> ，即，它可以获得他选择的任意信息的加密，也可以解密他选择的任意密文，而不是挑战密文。</p>
<p>在这个模型里，攻击者有特定的密文想解密，它可以与解密者互动，向解密者发送这些选择密文的询问，解密各种密文，除了挑战密文。攻击者的目标是<strong>破坏挑战密文的语义安全</strong>。</p>
<h2 id="选择密文安全"><a href="#选择密文安全" class="headerlink" title="选择密文安全"></a>选择密文安全</h2><p>通常，我们有一个密码 (E,D) ，我们将定义两个实验，实验0 和 实验1 。挑战者开始时选择一个随机密钥，现在攻击者提交询问给挑战者，每个询问可以是两种类型中的一种，可以是 CPA 也可以是 CCA 。</p>
<p>一个选择明文询问中，攻击者提交两个信息 $m_0$ 和 $m_1$ ，它们的长度相同，在 实验0 中，攻击者收到 $m_0$ 的加密结果，或者是，在 实验1 中，攻击者收到 $m_1$ 的加密结果。攻击者收到左边或右边的加密结果取决于我们是在 实验0 还是在 实验1 中。</p>
<p>一个选择密文询问中，攻击者提交他选择的任意密文，他获得密文的解密，唯一的限制是，他的密文不是选择明文攻击的询问中他所获得的密文之一。这不合理，因为攻击者可以通过 CPA 询问轻松获得密文，得到的是 $m_0$ 或 $m_1$ 加密的结果，如果攻击者可以提交特定密文的 CCA 询问，他会获得 $m_0$ 或 $m_1$ 作为答复，这样攻击者就会知道自己是在 实验0 还是 实验1 了。所以我们说，攻击者收到的 CPA 密文都是<strong>挑战密文</strong>，攻击者允许获得任何他选择的密文的解密结果，这些挑战密文除外。</p>
<p>通常，攻击者的目标是确定他是在 实验0 ，还是 实验1 。这是一个极为强大的攻击者，他可以获得除了挑战密文外，任意密文的解密结果，但他依然不能区分他是在 实验0 或 实验1 中，如果攻击者在 实验0 和 实验1 中表现一致，无法区分这两个实验，通常我们说密码是 CCA 安全（选择密文安全）的。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%89.PNG" class title="选择密文安全的定义">
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9A%E4%B9%892.PNG" class title="选择密文安全的定义2">
<h2 id="带随机-iv-的-cbc-不是-cca-安全的"><a href="#带随机-IV-的-CBC-不是-CCA-安全的" class="headerlink" title="带随机 IV 的 CBC 不是 CCA 安全的"></a>带随机 IV 的 CBC 不是 CCA 安全的</h2><p>一个简单的例子来证明，带随机 IV 的 CBC 不是 CCA 安全的，为什么呢？</p>
<p>攻击者在一开始提交两个不同的明文 $m_0$ 和 $m_1$ ，我们假定这两个信息都是单分组的，然后攻击者会获得 $m_0$ 或 $m_1$ 的加密结果，注意，密文只有一个分组，因为明文只有一个分组长。攻击者要修改这个得到的密文 c ，变成 c’ ，他仅仅是将 IV 异或 1 。给一个新的不同于 c 的 密文 c’ ，因此攻击者完全可以提交 c’ ，作为他的选择密文攻击的询问，他让挑战者为他解密 c’ ，由于 c’ ≠ c ，挑战者必须解密 c’ ，c’ 的解密是什么？（如果我们把 IV 异或 1 ，明文也会异或 1 。）现在攻击者收到了 $m_0$⊕1，或是 $m_1$⊕1，攻击者就可以完全确定他在 实验0 ，还是在 实验1 ，攻击者的优势是 1 ，因为他可以轻松确定他在哪个实验。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E5%B8%A6%E9%9A%8F%E6%9C%BAIV%E7%9A%84CBC%E4%B8%8D%E6%98%AFCCA%E5%AE%89%E5%85%A8%E7%9A%84.PNG" class title="带随机IV的CBC不是CCA安全的">
<h2 id="一个定理"><a href="#一个定理" class="headerlink" title="一个定理"></a>一个定理</h2><p><strong>如果密码能够提供认证加密，这个密码就可以抵抗选择密文攻击。</strong></p>
<p>如果我们有一个攻击者，提交了 q 个询问，换句话说，最多 q 个 CPA 询问和 q 个 CCA 询问，那么有两个有效的攻击者 $B_1$ 和 $B_2$ ，满足如下不等式：</p>
<script type="math/tex; mode=display">
Adv_{CCA}[A,E]\leq2q\cdot Adv_{CI}[B_1,E]+Adv_{CPA}[B_2,E]</script><p>由于这个机制有认证加密，</p>
<p>因为它是 <u>CPA 安全</u>的，因此不等式右侧第二个优势是可忽略的；</p>
<p>因为加密机制有<u>密文完整性</u>，因此不等式右侧第一个优势是可忽略的；</p>
<p>因此，攻击者赢得 CCA 游戏的优势，即不等式左侧的优势也是可忽略的。</p>
<h2 id="上述定理的证明"><a href="#上述定理的证明" class="headerlink" title="上述定理的证明"></a>上述定理的证明</h2><p>如图，我们有两份 CCA 游戏，左上为 实验0 ，左下为 实验1 。攻击者提交 CPA 询问和 CCA 询问，最后他输出一个特定的猜测 b，记为 b’ ，我们的目标是证明这个 b’ 在两种情况下都是不可区分的。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E1.PNG" class title="定理证明1">
<p>首先，我们稍微改变一下挑战者，不再输出 CCA 询问的解密，攻击者会输出符号 ⊥ ，每次攻击者提交一个 CCA 询问，挑战者都说符号 ⊥ ，以下两个游戏在事实上是不可区分的，攻击者无法进行区分。因为机制有密文完整性，攻击者不能产生一个密文不是从 $c_1$ 到 c_i-1 中的，可以解密到不是符号 ⊥ 的其他东西。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E2.PNG" class title="定理证明2">
<p>同样的事情应用在下面的游戏中，可以知道左右两个游戏不可区分。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E3.PNG" class title="定理证明3">
<p>因为选择密文的询问总是以同样的方式回复，不会给攻击者任何信息，攻击者总是知道我们会以符号 ⊥ 回复，所以我们可以去除这些询问，得到下图。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E4.PNG" class title="定理证明4">
<p>去除这些询问后，剩下的游戏看上去很熟悉，即，右上和右下的游戏是由 CPA 安全的定义得来的，由于这个机制是 CPA 安全的，我们得出右上和右下的游戏不可区分，从而，我们证明了以上四个游戏都是等价的，因此，攻击者不能区分 实验0 和 实验1 ，因此这个机制是 CCA 安全的。</p>
<p><strong>认证加密蕴含了对抗选择密文攻击的安全性</strong>。</p>
<h2 id="认证加密的局限"><a href="#认证加密的局限" class="headerlink" title="认证加密的局限"></a>认证加密的局限</h2><p>①它不能阻止重放攻击。</p>
<p>②如果解密者透露了更多关于为什么密文被拒绝的信息，解密者不仅仅输出符号 ⊥ ，它还输出更多信息。如，计时攻击。</p>
<h1 id="constructions-from-ciphers-and-macs"><a href="#Constructions-from-ciphers-and-MACs" class="headerlink" title="Constructions from ciphers and MACs"></a>Constructions from ciphers and MACs</h1><p>在软件项目中最常见的错误是<u>不正确地组合加密和完整性机制</u>。</p>
<h2 id="cpa-安全加密和-mac-的组合例子"><a href="#CPA-安全加密和-MAC-的组合例子" class="headerlink" title="CPA 安全加密和 MAC 的组合例子"></a>CPA 安全加密和 MAC 的组合例子</h2><p>在这三个例子里，有一个单独的密钥 $k_E$ 用来加密，一个单独的密钥 $k_I$ 用来 MAC ，这两个密钥相互独立，都是在会话建立阶段生成的。</p>
<p>第一个例子在 SSL 协议里，SSL 组合加密和 MAC ，希望能获得认证加密，组合方法如下：取明文 m 的 MAC ，使用 MAC 密钥 $k_I$ ，计算明文 m 的标签，然后把标签附在明文后面，然后加密这个明文和标签的联结，得到最终的密文。</p>
<p>第二个例子在 IPsec 中，取明文，首先加密这个明文，然后计算得到的<u>密文的标签</u>，把密文附在标签后。</p>
<p>第三个例子在 SSH 协议里，SSH 取明文，加密明文，计算<u>明文的标签</u>，把密文附在标签后。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/CPA%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%E5%92%8CMAC%E7%9A%84%E7%BB%84%E5%90%88%E4%BE%8B%E5%AD%90.PNG" class title="CPA安全加密和MAC的组合例子">
<p>试想，以上三个例子哪个是安全的？</p>
<p>在 <u>SSH 方法</u>中，标签是由明文计算的，然后把标签以明文的方式附在密文的后面，这存在很大的问题，因为 MAC 本身不是为私密性设计的，<strong>MAC 仅为完整性设计</strong>，事实上，仅以输出明文中的几位作为 MAC 的话，也没有错，也是很好的标签。如果使用这个方法，会完全破坏 CPA 安全性，因为明文的若干位在 MAC 签名算法的输出密文里被泄露了，所以这个 SSH 方法尽管对于 SSH 这个协议本身来说没有问题，也没有因为这个组合而被破解，但一般还是<u>不建议使用</u>这种方法。SSH方法有时叫做“<u>加密且MAC</u>”。</p>
<p><u>IPsec 的方法更为推荐</u>，因为无论使用什么 CPA 安全系统和 MAC 密钥，组合总能提供认证加密。因为一旦我们加密了明文，明文的内容就被隐藏在密文里了，当我们计算密文的标签时，我们用这个标签给密文上了锁，确保没人能产生一个不同的密文看起来是有效的，因此保证了任何对密文的修改都会被解密者检测出来。IPsec有时叫做“<u>先加密后MAC</u>”。</p>
<p>在 <u>SSL 方法</u>中，有一些病态的例子，把 CPA 安全的加密系统和一个安全的 MAC 组合起来，结果却对一个选择密文攻击是脆弱的，所以 SSL 方法实际上不提供认证加密。这个发生的原因是，加密机制和 MAC 算法之间有一些不好的互动，事实上，会有一个选择密文攻击，因此 SSL 方法<u>不提供认证加密</u>。SSL 方法有时叫做“<u>先MAC后加密</u>”。（如果你使用<u>随机计数器模式</u>或<u>随机 CBC</u>，那么对那些 CPA 安全的加密机制，SSL 方法<u>提供了认证加密</u>，是安全的。事实上，如果你使用的是<u>随机计数器模式</u>，那么你的 <u>MAC 算法只要是一次性安全的就够了</u>，不需要是完全安全的 MAC，这样更高效。）</p>
<h2 id="认证加密的三个标准模式"><a href="#认证加密的三个标准模式" class="headerlink" title="认证加密的三个标准模式"></a>认证加密的三个标准模式</h2><p>一旦认证加密的观念变得更为流行，很多组合加密和 MAC 的标准方法便涌现出来。</p>
<p>GCM（Galois计数器模式）和 CCM（CBC计数器模式）是由 NIST 标准化的。</p>
<p><strong>GCM 的工作过程</strong>：使用了计数器模式加密，即使用 Carter-Wegman MAC 的随机计数器模式。GCM 的 Carter-Wegman MAC 如下工作，它是待求 MAC 的信息的一个哈希函数，然后用一个 PRF 加密哈希的结果，这个速度很快，而 GCM 的运行时间受制于计数器模式，为了更快，Intel 引入了一个特殊指令 PCLMULQDQ ，目标是让 GCM 的这个哈希函数跑得尽可能快。</p>
<p><strong>CCM 的工作过程</strong>：使用 CBC MAC ，然后用计数器模式加密，这个机制使用 MAC ，然后加密。<u>并不推荐使用</u>。但因为使用的是计数器模式，实际上是一个很好的加密机制。CCM 一切都是基于 AES 的，它的  CBC-MAC 使用了 AES，他的计数器模式也是使用 AES ，因此，CCM 可以用相对少的代码实现，因为需要的仅为 AES 引擎，因此，CCM 被 WIFI 采用。</p>
<p><strong>EAX 的工作过程</strong>：使用的是计数器加密模式，然后是 CMAC，先加密后 MAC 。</p>
<p>所有的这些模式都是<u>基于新鲜值的</u>，换句话说，它们不使用任何随机性，并且，每个密钥的新鲜值是唯一的，有序对（密钥，新鲜值）永远不应该重复使用，但新鲜值本身不一定是随机的，可以使用一个计数器。</p>
<p>所有的这些模式被称为<strong>带相关数据的认证加密</strong>（<strong>AEAD</strong>），这是一个认证加密的扩展，在网络协议中经常出现，AEAD 的想法是：<u>提供给加密模式的信息不被完全加密，只有部分信息是被加密的，但所有信息是被认证的</u>。网络数据包就是一个很好的例子，报文头不需要加密，封装数据需要加密，报文头和封装数据都需要被认证。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/AEAD.PNG" class title="AEAD">
<h2 id="mac-安全性的相关解释"><a href="#MAC-安全性的相关解释" class="headerlink" title="MAC 安全性的相关解释"></a>MAC 安全性的相关解释</h2><p>安全MAC 定义的要求之一是，给定信息 m 的信息、MAC 对，攻击者不能产生同样的信息 m 的另一个标签，换句话说即使攻击者已经有了信息 m 的一个标签，他也不能产生同样信息 m 的一个新的标签。</p>
<p>为什么呢？如果攻击者已经有了信息 m 的一个标签，谁在乎他是否能产生另一个标签？</p>
<p>实际上，如果 MAC 没有这一性质，那么这个 MAC 会造成一个不安全的“先加密后MAC”的模式，如果想要“先加密后MAC”具有密文完整性，很重要的一点是，我们的 MAC 安全性蕴含着这个安全观点（即，不能产生同样信息 m 的一个新的标签）。</p>
<p>事实上，容易出现“产生新标签”这种伪造，在一种“先加密后MAC”系统有一种选择密文攻击，意味着它并不提供认证加密，如图所示，一开始，攻击者发送两个信息 $m_0$ 和 $m_1$ ，通常他会收到 $m_0$ 或 $m_1$ 的加密结果，由于我们使用“先加密后MAC”，攻击者收到的密文记为 $c_0$ ，$c_0$ 上有一 MAC t ，攻击者可以产生同样信息的另一个 MAC  t’ ，于是他有了一个新的完全有效的密文 ($c_0$,t’) ，攻击者可以提交 c’ 的一个选择密文的询问，这是一个有效的选择密文的询问，因为它和 c 不同，挑战者将 c’ 的解密发送给攻击者，c’ 的解密为 $m_0$ 或 $m_1$ ，因此他能输出 b 的值，以优势 1 赢得这个机制。</p>
<p>由此证明，如果 MAC 安全性不蕴含着这个安全观点，那么在这个“先加密后MAC”系统有一种选择密文攻击，因此，它是不安全的。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/MAC%E5%AE%89%E5%85%A8%E6%80%A7.PNG" class title="MAC安全性">
<h2 id="ocb由分组密码构建的认证加密机制"><a href="#OCB（由分组密码构建的认证加密机制）" class="headerlink" title="OCB（由分组密码构建的认证加密机制）"></a>OCB（由分组密码构建的认证加密机制）</h2><p>如果考虑 MAC 和加密的组合是如何工作的，比如说计数器模式和 CMAC ，那么对每个明文分组，首先必须以计数器模式使用分组密码，然后必须再次使用分组密码运行 CBC-MAC ，这意味着，如果把 CPA 安全的加密和一个 MAC 组合起来，对每个明文分组必须计算分组密码两次，一次计算 MAC ，一次计算加密机制。</p>
<p>那么，我们能否由一个 PRP 直接构建一个认证加密机制？这样我们对每个分组只计算一次 PRP ，答案是肯定的，这个构造叫做 <strong>OCB</strong> 。OCB 比从加密和 MAC 分别构造的机制<u>快很多</u>。</p>
<p>如下图，在 OCB 里，我们输入明文，注意，OCB 是完全<strong>可并行</strong>的，每个分组可以被单独加密，另外，<strong>对每个明文分组，只需计算一次分组密码</strong>，然后在最后再计算一次分组密码，以构建认证标签，除去分组密码部分，OCB 的开销是最小的，只需要计算一个非常简单的函数 P ，新鲜值、密钥、分组计数器都给了 P 。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/OCB.PNG" class title="OCB">
<p>为什么 OCB 不是标准？OBC 没被应用的原因是各种各样的专利。。。</p>
<h2 id="一些性能参数"><a href="#一些性能参数" class="headerlink" title="一些性能参数"></a>一些性能参数</h2><p>如图，右边为不该用的模式的性能参数，因为它们只提供 CPA 安全，不提供对抗主动攻击的安全性。左侧为三种标准和 OCB 的性能参数。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0.PNG" class title="一些性能参数">
<p>GCM 虽然速度快，但在空间有限的硬件设备上，并不理想，因为它的实现需要更多的代码（Intel只需要很少代码）。</p>
<h1 id="case-studytls"><a href="#Case-study：TLS" class="headerlink" title="Case study：TLS"></a>Case study：TLS</h1><h2 id="tls-的工作过程"><a href="#TLS-的工作过程" class="headerlink" title="TLS 的工作过程"></a>TLS 的工作过程</h2><p>在 TLS 中，数据加密使用的协议叫做 <strong>TLS 记录协议</strong>，在这个协议栈，每个 TLS 记录都以一个报文头 HDR 开始，报文头后面接加密的数据，TLS 中记录的长度最多为 16KB ，如果需要发送多于 16KB 的数据，那么一个记录需要被拆分成多个记录。</p>
<p>现在，TLS 使用了单向密钥（从浏览器到服务器的单方向密钥），而从服务器到浏览器也有另一个密钥，服务器和浏览器双方都知道这两个密钥，两个密钥都是由 TLS 密钥交换协议生成的。</p>
<p>TLS 记录协议使用了所谓的<u>基于状态的加密</u>，意思是，每个数据包的加密是使用浏览器和服务器内部维护的特定状态来完成的。一些 64 位计数器，当会话被首次初始化后，这些计数器被初始化为 0 ，然后每次发送记录时，它们都增加。一个状态，两个计数器，这个状态存在于浏览器和服务器双方随着记录由以一方发送，另一方接收，状态被合理更新。</p>
<p>这些计数器的目的：<strong>阻止重放攻击</strong>。攻击者不能简单地保存记录，然后进行重放，因为计数器一定增加了。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/TLS%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.PNG" class title="TLS的工作过程">
<h2 id="tls记录协议的工作细节"><a href="#TLS记录协议的工作细节" class="headerlink" title="TLS记录协议的工作细节"></a>TLS记录协议的工作细节</h2><p>加密使用 AES-CBC ，MAC 使用 HMAC-SHA1 ，注意，TLS 使用了一个 MAC 然后加密。</p>
<p>浏览器给服务器发送数据，使用的是从浏览器到服务器的密钥，密钥本身是由 2 个密钥组成，一个 MAC 密钥 k_mac 和一个加密密钥 k_enc ，两个密钥在会话起始阶段就被协商好了，总的来说，从浏览器到服务器有 2 个密钥，从服务器到浏览器有 2 个密钥，一共有 4 个密钥。</p>
<p>TCL 数据包结构图如下。它以一个<u>报文头</u>开头，包含了数据包的类型、协议版本号以及数据包的长度。注意到数据包的长度是以明文形式发送的，加密数据、加密特定记录时，取密钥和当前状态为输入，工作流程如下：</p>
<p>①首先，计算数据的 MAC ，这是取 MAC 的实际的封装数据，报文头、计数器的当前值也在 MAC 的计算中。（所有计数器增加表示又一个记录被发送了。）即使计数器的值包含在标签里，注意，计数器的值实际上永远不会在记录中发送，它不用被放在记录里发送的原因是，另一端的服务器已经知道了计数器的值，所以不需要发送。这个标签计算的范围是三元组数据 [header,data,tag] 。</p>
<p>②把标签附在数据后面。由于是<strong>先 MAC 后加密</strong>，所以计算了 MAC 。我们会将数据和标签一并加密，所以报文头、数据和标签补齐到 AES 分组。</p>
<p>③用加密密钥来进行 CBC 加密。我们计算数据和标签的 CBC 加密，使用一个新鲜的随机 IV ，它会被嵌入到密文中。</p>
<p>④在结果前附上报文头、报文类型、版本号、长度，给出整个 TLS 记录，发送给服务器。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/TLS%E8%AE%B0%E5%BD%95%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%BB%86%E8%8A%82.PNG" class title="TLS记录协议的工作细节">
<p>以上是 TLS “先MAC后加密”的实现，唯一与“先MAC后加密”的区别在于，有一个状态，即这个计数器，被包含在 MAC 值里。</p>
<p><strong>为什么这个计数器能阻止重放攻击？</strong></p>
<p>我们看记录协议是如何解密到来的记录，以加密的记录 record 为输入，服务器又将使用对应的、从浏览器到服务器密钥 以及 从浏览器到服务器的计数器。</p>
<p>①首先，我们使用加密密钥来解密记录。</p>
<p>②解密后，检测补齐长度，如果补齐格式错误，它将发送一个坏记录 MAC 警告并断开连接。如果需要发送更多记录，那就必须协商一个新的会话密钥。如果补齐格式正确，去除补齐很容易，服务器只需看补齐的最后的字节，然后进行相应的去除。</p>
<p>③从记录中提取标签，这个网页数据藏在这个去除补齐后剩下的记录里，然后验证报文头、数据和计数器值的标签，如果 MAC 不能验证，将发送一个警告“坏记录 MAC”，然后断开连接；如果标签通过验证，就去除标签、报文头，剩下的就是明文数据。</p>
<p>现在可以看到，如果记录被重放了（即，攻击者记下了某个记录重放给服务器），那时，计数器的值已经变了，因此被重放的记录的标签将不会通过验证。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E8%AE%A1%E6%95%B0%E5%99%A8%E9%98%BB%E6%AD%A2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%E7%9A%84%E8%AF%81%E6%98%8E.PNG" class title="计数器阻止重放攻击的证明">
<p>这个方法“先MAC后加密”，不过只有当<u>解密时没有信息泄露</u>，才是认证加密。只要无法区分为什么密文被拒绝了（即，解密者暴露了拒绝的事实，但不说为什么拒绝），这就是一个认证加密系统。</p>
<p><strong>当解密失败时，只要输出拒绝，永远不要解释为什么拒绝</strong>。在密码学里，如果解释为什么失败，很可能会造成一个攻击。</p>
<h2 id="一个被破解的协议-80211b-wep"><a href="#一个被破解的协议-802-11b-WEP" class="headerlink" title="一个被破解的协议 802.11b WEP"></a>一个被破解的协议 802.11b WEP</h2><p><strong>802.11b WEP 工作流程</strong>：笔记本想发送一条信息给接入点，首先，笔记本计算信息的循环冗余校验码（CRC），然后把 CRC 校验码附在信息的后面，然后结果用流密码 RC4 加密。WEP 使用的密钥是一个初始 IV 值，这个 IV 每个数据包都会变，再联结上一个长密钥 k ，然后 IV 和密文一并传递给对方。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E4%B8%80%E4%B8%AA%E8%A2%AB%E7%A0%B4%E8%A7%A3%E7%9A%84%E5%8D%8F%E8%AE%AE.PNG" class title="一个被破解的协议">
<p><strong>存在的两个问题</strong>：</p>
<p>①IV 会重复。可以实施一个二次密码本攻击。</p>
<p>②使用了关联非常密切的密钥。密钥仅仅是 IV 联结上 k ，唯一改变的是 IV ，而 k 总是固定的。RC4 不是为这种用法而设计的，会完全被破解。</p>
<p><strong>攻击方法</strong>：</p>
<p>利用 CRC 校验和的一个性质，CRC 基本上是<u>线性</u>的，意思是如果我给你 CRC(m) ，可以很容易计算 CRC(m⊕p) ，只需要计算某个广为人知的函数 F(p) ，两者异或即可。异或从括号里提取出来，意味着 CRC 是线性的。</p>
<p>攻击如下，假设攻击者截获了某个送往接入点的数据包，现在数据包说，它的目标端口是 80 ，攻击者知道它是送往 80 端口的，攻击者想修改密文，使得目标端口变成 25 ，也许攻击者可以读取送往 25 端口的信息，CRC 校验和是为了确保攻击者不能修改密文中的数据，但事实上，非常容易修改密文数据，CRC 对篡改根本没有安全可言。</p>
<p>攻击者会对密文中代表 80 的那些字节异或某些特定的值 XX ，现在他会异或 25⊕80 ，如果异或特定字符串 XX 到密文里，密文由流密码生成，当密文解密时，此处的明文也会变成异或了 XX 后的样子，因此在解密后，这里的明文会变成 80⊕25⊕80=25 。</p>
<p>但是，如果我们只做这些，攻击还是会失败，因为 CRC 校验和现在还不是有效的，需要一个不同的 CRC ，但这不是问题，因为我们可以轻松修正这个 CRC 校验码，尽管 CRC 校验码也被加密了，我们把密文中对应 CRC 校验码的部分，与 F(XX) 异或，所以当密文解密后，我们会得到正确的 CRC 校验和。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95.PNG" class title="攻击方法">
<p><strong>结论</strong>：<strong>CRC 校验和完全不提供完整性来对抗主动攻击</strong>。</p>
<h1 id="cbc-padding-attacks"><a href="#CBC-padding-attacks" class="headerlink" title="CBC padding attacks"></a>CBC padding attacks</h1><p>一般情况下，当你想提供认证加密时，正确的方法是先加密，然后计算 MAC ，因为这样无论你组合什么加密和 MAC 算法，得到的结果将是认证加密。</p>
<p>假定这里的加密和 MAC 算法是正确实现的，我们看一个非常犀利的针对使用 CBC 加密的 TLS 记录协议的攻击。</p>
<p>TLS 解密时会发生两种错误：①补齐错误 ②MAC 错误</p>
<p>假设攻击者可以区分两种错误，得到的结果叫做<strong>补齐神谕</strong>。试想攻击者截获了一段特定的密文并试图去进行解密，它可以把这份密文提交给服务器，服务器会<u>解密这段密文</u>，然后<u>检查补齐格式是否正确</u>，如果补齐格式不正确，我们会得到一种错误类型；如果补齐格式正确，<u>检查 MAC</u> ，由于这段随机密文是攻击者捏造的，很可能是 MAC 错误的，然后攻击者会观测到一个 MAC 错误。所以如果补齐无效，我们会看到一个补齐错误；如果补齐有效，我们会看到一个 MAC 错误。因此，在向服务器提供密文后，攻击者可以知道解密的密文中最后几个字节是否是有效的补齐，这样攻击者仅仅通过提交密文给服务器，就学到了解密的密文中的一些信息。</p>
<p>那么，攻击者能否使用这个信息来完全解密一个给定的密文？<strong>一个补齐神谕，可以被用来完全解密一个给定的密文。</strong></p>
<h2 id="计时攻击"><a href="#计时攻击" class="headerlink" title="计时攻击"></a>计时攻击</h2><p>如果补齐无效，那么警告信息很快就会发出，在 21 毫秒内密文会被拒绝；如果补齐无效，检查 MAC ，发现 MAC 也是无效的，在 23 毫秒被拒绝，返回警告，即使返回同样的警告，攻击者可以观察警告信息生成的用时，如果时间较短，他就知道补齐是无效的，如果时间较长，他就知道补齐有效，MAC 无效。因此，攻击者有一个补齐神谕可以告诉他补齐是否有效。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E8%AE%A1%E6%97%B6%E6%94%BB%E5%87%BB.PNG" class title="计时攻击">
<h2 id="如何利用补齐神谕"><a href="#如何利用补齐神谕？" class="headerlink" title="如何利用补齐神谕？"></a>如何利用补齐神谕？</h2><p>如果攻击者有一个特定的密文 c ，它可以只使用补齐神谕就能完全解密这个密文。</p>
<p>假设攻击者想获取明文 m[1] ，这里有攻击者截获的密文，首先，他扔掉 c[2] </p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E8%A1%A5%E9%BD%90%E7%A5%9E%E8%B0%95%E7%9A%84%E4%BD%BF%E7%94%A8.PNG" class title="补齐神谕的使用">
<p>这样最后分组就是 c[1] ，即攻击者想解密的分组，现在假定他有一个特定的猜测 g ，对 m[1] 的最后一个字节进行猜测，g 是从0 到 255 的某个值。攻击者会计算 g⊕01，再异或分组 c[0] 的最后一个字节，当这两个密文分组被解密时，会发生什么？c[0] 被解密成什么我们不管，当 c[1] 被解密时，最后一个字节与这个修改的 c[0] 异或，得到明文的最后一个字节 将也是与这个多出来的、与 c[0] 异或的值 异或的，所以实际上原来明文 m[1] 的最后一个字节，现在与 g⊕01 异或了（图中0x表示十六进制）。</p>
<p>如果 m[1] 最后一个字节的猜测 g 是正确的，那么 last-byte⊕g 会抵消，last-byte⊕g=0，我们会得到明文的最后一个字节是 01 ，这意味着，如果我们对 m[1] 最后一个字节的猜测是正确的，那么我们获得了一个格式正确的补齐，补齐神谕说，这个补齐是有效的；如果猜测不正确，我们会得到一个不等于 1 的值，我们的补齐可能是无效的。可以看到，如果我们对 m[1] 最后一个字节的猜测是正确的，表示 g 实际上是正确的猜测；如果我们的猜测是错误的，g 就是错误的。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E8%A1%A5%E9%BD%90%E7%A5%9E%E8%B0%95%E7%9A%84%E4%BD%BF%E7%94%A82.PNG" class title="补齐神谕的使用2">
<p>那么，攻击者会创建他的修改后的密文，注意，他只修改密文的第二个分组，把这个发送给补齐神谕，根据补齐神谕返回的结果，我们可以知道最后一个字节是否等于 g 。</p>
<p>我们可以重复这一步，g 从0 遍历到 255 ，直到找到正确的 g，我们就知道了 m[1] 的最后一个字节。然后，我们可以使用一模一样的流程来学到 m[1] 中倒数第二个字节，我们使用两字节的补齐 (02,02) ，这是一个正确的补齐格式。当我们用异或的技巧时，我们可以总是确保明文的最后一个字节为 02 ，现在我们可以猜测 m[1] 的倒数第二个字节了，通过尝试很多 g ，直到找到那个可以造出补齐 22 的 g 。然后一次次迭代这个过程。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E8%A1%A5%E9%BD%90%E7%A5%9E%E8%B0%95%E7%9A%84%E4%BD%BF%E7%94%A83.PNG" class title="补齐神谕的使用3">
<p>这个攻击对于 TLS 不起作用，因为 TLS 接收到一个带有坏补齐或坏 MAC 记录时，它会关闭连接，然后重新协商一个新密钥，TLS 中只能提交一个询问，只会泄露单个询问的明文信息给攻击者，不会暴露整个明文分组。但这个攻击十分犀利，只要协议中有这样一个错误，攻击就会发生。</p>
<p><strong>防御这个攻击的方法</strong>是<strong>始终检查 MAC</strong> ，因此需要花同样的反应时间，看补齐是否有效，无论补齐是否有效，就防止了计时攻击，让这个攻击更加困难。</p>
<h2 id="两个教训"><a href="#两个教训" class="headerlink" title="两个教训"></a>两个教训</h2><p>①如果 TLS 先加密后 MAC ，而不是先 MAC 后加密，这个攻击将完全不顶用。</p>
<p>②MAC 和 CBC 确实提供了认证加密，但仅当不透露解密失败的原因，但以上实验证实了这种模式不能提供认证加密。</p>
<h1 id="attacking-non-atomic-decryption"><a href="#Attacking-non-atomic-decryption" class="headerlink" title="Attacking non-atomic decryption"></a>Attacking non-atomic decryption</h1><h2 id="针对ssh的二元数据包协议的攻击"><a href="#针对SSH的二元数据包协议的攻击" class="headerlink" title="针对SSH的二元数据包协议的攻击"></a>针对SSH的二元数据包协议的攻击</h2><p>SSH 是一个标准的安全远程 shell 应用，使用了一个客户端与服务端之间的协议，它有一个密钥交换机制，一旦双方交换密钥，SSH 使用所谓的二元数据包协议来在客户端和服务端之间相互发送信息。</p>
<p><strong>SSH工作过程</strong>：使用“加密且MAC”，每个 SSH 包以一个序列号开头，然后数据包包含了包的长度、CBC补齐的长度、封装数据、CBC补齐，图中红色快是用带链式 IV 的 CBC 加密的，所以这对 CPA 攻击也是脆弱的，计算整个<u>数据包的明文的 MAC</u> ，MAC 以<u>明文的形式</u>和数据包一起发送。SSH 解密过程如下：</p>
<p>①首先，服务器只解密加密的数据包的包长度域 packet len ，那么它只解密开头这几个字节。</p>
<p>②然后它从网络接着读取数据，读取的字节数由数据包长度域指定。</p>
<p>③SSH 使用 CBC 解密剩下的密文内容。</p>
<p>④一旦恢复了整个 SSH 数据包，它会接着检查明文的 MAC ，如果 MAC 无效，就报错。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/SSH%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.PNG" class title="SSH工作过程">
<p>这里的问题是，数据包长度域被解密了，然后被直接使用，以决定数据包的长度，这是在任何认证发生前，事实上，不可能认证数据包长度域的 MAC ，因为我们还没有还原整个数据包，所以我们还不能检查 MAC 。但是，SSH 协议在验证 MAC 之前就是用了数据包长度，这实际上引入了一个非常犀利的攻击。</p>
<p>我们只描述这个攻击的一个非常简化的版本，想法如下：假设攻击者截获了一个密文分组，即直接用 AES 加密的分组 m ，现在攻击者想还原 m ，这个截获密文只有一个 AES 分组长，攻击者向服务器发送一个数据包，数据包的开头是正常的，以一个序列号开头，然后他截获的密文 c 作为第一个分组，发送给服务器，服务器会解密第一个 AES 分组的前几个字节，他会把这前几个字节解读成数据包的长度域，接下来，服务器将期待着这么多字节，在验证 MAC 之前，攻击者将一次只给服务器一个字节，这样服务器会一个字节一个字节的读，最终，服务器会读到长度域里说的那么多的字节，他会检测 MAC 是否有效，由于攻击者给服务器的字节都是随便弄的，因此 MAC 不会通过验证，服务器会发送一个 MAC 错误，但是可以发现，攻击者在数他发送给服务器多少个字节，他能严格的知道他发送了多少个字节，当他接收到服务器发来的 MAC 错误，这就告诉攻击者，密文 c 的前 32 位的解密结果正好等于已经发送的字节数，在看到 MAC 错误之前，这是一个非常聪明的攻击，攻击者可以知道一条长信息的每个密文分组的高 32 位。</p>
<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/%E7%AE%80%E5%8C%96%E7%89%88%E6%9C%AC%E7%9A%84%E6%94%BB%E5%87%BB.PNG" class title="简化版本的攻击">
<p><strong>密码设计的两个错误</strong>：</p>
<p>①解密操作不是原子操作，换句话说，解密算法不取整个数据包作为输入，而返回整个明文作为输出，或者返回“拒绝”，解密算法部分地解密了密文，获得了长度域，然后等待指定数量的字节去还原，然后完成了解密过程。</p>
<p>②在正确的认证之前，就使用了长度域。</p>
<p><strong>重新设计SSH，如何最小的改动，可以让SSH抵抗这种攻击？</strong></p>
<p>方案①：以明文的形式发送一个长度域，就像 TLS 一样，这样，攻击者就没有机会提交选择密文攻击了，因为长度域不会被加密，攻击者无法滥用解密操作。</p>
<p>方案②：单独对长度域计算 MAC ，这样服务器可以去读长度域，检查仅为长度域服务的 MAC 是否有效，服务器就知道了接下来要读多少个字节，之后再检查整个数据包的 MAC 域。</p>
<p>方案③：可行，但效率极差，可能会让服务器遭受拒绝服务攻击。</p>
<p>Lesson<img src="/2020/07/11/%E3%80%90DanBoneh%E3%80%91AuthenticatedEncryption/Lesson.PNG" class title="Lesson"></p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Block Ciphers</title>
    <url>/2020/03/27/%E3%80%90DanBoneh%E3%80%91BlockCiphers/</url>
    <content><![CDATA[<p><strong>分组密码</strong>：由两部分组成，<u>加密算法E</u> 和 <u>解密算法D</u>，它的输入和输出具有严格相同的位数。</p>
<p><strong>3DES</strong>：分组大小为 64 位，使用 168 位长的密钥。n = 64 bits，k = 168 bits。</p>
<p><strong>AES</strong>：n = 128 bits，k = 128，192，256 bits。密钥越长，密码工作速度越慢，越安全。</p>
<a id="more"></a>
<p><strong>伪随机函数</strong>（PRF）：定义在密钥空间、输入空间、输出空间上的三元组 (K,X,Y) ，F：K×X→Y。有一个有效的方法来计算这个函数，无需可逆。</p>
<p><strong>伪随机置换</strong>（PRP）：定义在密钥空间和一个集合 X 上 (K,X) ，E：K×X→X，取密钥空间上的一个元素和 X 上的一个元素输出 X 上的一个元素。有一个有效的算法来计算这个函数，一旦固定密钥 K ，函数 E 是<u>一一对应</u>的，<u>需要一个逆向算法</u>。</p>
<p>一个PRP是一个输入空间等于输出空间的PRF。</p>
<p><strong>PRF安全的条件</strong>：在<u>伪随机函数集合上的均匀分布</u>与<u>全体函数上的均匀分布</u>不可区分。</p>
<p><strong>DES</strong>：核心思想是Feistel网络。</p>
<p>从<strong>伪随机数发生器</strong>可以构建<strong>伪随机函数</strong>，而不是伪随机置换，最终目标是构建一个分组密码，本质上是<strong>PRP</strong>，可被证明是安全的，但很慢、不实用。</p>
<p><strong>PRF转换引理</strong>：一个安全的PRP，事实上也是安全的PRF，只要集合 X 足够大。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Message Integrity</title>
    <url>/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/</url>
    <content><![CDATA[<h1 id="message-auth-codes"><a href="#Message-Auth-Codes" class="headerlink" title="Message Auth. Codes"></a>Message Auth. Codes</h1><h2 id="mac"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>MAC（消息验证码）是一对算法，包含一个<u>签名算法</u>和一个<u>验证算法</u> I=(S,V)，定义在一个密钥空间、一个信息空间、一个标签空间上 (K,M,T)，签名算法 S(k,m) 会输出标签空间 T 中的一个标签 tag，验证算法 V(k,m,tag) 取密钥 k ，信息 m ，标签 tag，输出 yes 或 no。</p>
<a id="more"></a>
<h2 id="标准的一致性要求"><a href="#标准的一致性要求" class="headerlink" title="标准的一致性要求"></a>标准的一致性要求</h2><p>每一个密钥空间中的密钥 K 和每一个信息空间中的信息 M 都正好满足，如果使用密钥对信息进行签名，使用同样的密钥验证这个签名应该获得 yes 作为回应，V(k,m,S(k,m)) = yes。</p>
<h2 id="crc"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h2><p>CRC（循环冗余检验）是一个经典的校验和算法，为监测信息中的随机发生的错误而设计，并非针对恶意错误。如果利用 CRC 进行检验，没有密钥，攻击者可以随意更改信息重新计算输出 tag 并得到 yes 的反馈，Alice与攻击者无区别。</p>
<h2 id="存在性伪造"><a href="#存在性伪造" class="headerlink" title="存在性伪造"></a>存在性伪造</h2><p>安全的MAC，如果对它进行<strong>选择信息攻击</strong>，是不可能被存在性伪造的。</p>
<p>存在性伪造：攻击者产生新的信息标签对。</p>
<h2 id="mac安全模型"><a href="#MAC安全模型" class="headerlink" title="MAC安全模型"></a>MAC安全模型</h2><p>有两个算法 S 和 V ，有一个攻击者A ，游戏如下：挑战者通常为 MAC 选择一个随机密钥，攻击者进行他的<u>选择信息攻击</u>，他提交 $m_1$ 给挑战者，获得 $m_1$ 的标签，然后提交 $m_2$ 给挑战者，获得 $m_2$ 的标签，直到他提交了 q 个信息给挑战者，获得了 q 个这些信息的标签，这是选择信息攻击的部分，然后攻击者继续试图进行存在性伪造，他输出一个新的信息标签对我们就说他赢下这场游戏，换句话说，b=1 表示他赢下这场游戏。通常，我们定义攻击者的优势等于挑战者在本游戏中输出 1 的概率。安全的MAC系统，对所有有效的攻击者，优势都是可忽略的，换句话说，没有有效的攻击者能够以不可忽视的概率赢得这个游戏。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/MAC%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.PNG" class title="MAC安全模型">
<h1 id="macs-based-on-prfs"><a href="#MACs-based-on-PRFs" class="headerlink" title="MACs based on PRFs"></a>MACs based on PRFs</h1><h2 id="构建安全的mac"><a href="#构建安全的MAC" class="headerlink" title="构建安全的MAC"></a>构建安全的MAC</h2><p><u>安全的 PRF 可以构建安全的 MAC</u>。</p>
<p>假设我们有一个伪随机函数 PRF，这个 PRF 取输入 X，输出 Y，<code>F：K×X→Y</code>，定义如下 MAC 为信息 M 签名，<code>S(k,m):= F(k,m)</code>，即计算函数在 M 处的值，信息 M 的标签就是在点 M 处的函数值，然后通过这一对验证信息，方法就是重新计算在信息 M 处的函数值检查结果是否等于给我们的标签，如果一样，我们说“是”，否则我们拒绝。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E5%AE%89%E5%85%A8%E7%9A%84MAC%E6%9E%84%E5%BB%BA.PNG" class title="安全的MAC构建">
<p>在如下例题中的 MAC 是不安全的，因为标签太短（当且仅当函数输出太小，才会有问题，如果PRF的输出很大，就可以获得一个安全的 MAC），攻击者有 1/2^(10) 的机会猜中 MAC。对这个MAC 的优势如下：</p>
<script type="math/tex; mode=display">
Adv_{MAC}[A,I_F]=\frac{1}{2^{10}}=\frac{1}{1024}(不可忽略)</script><img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E4%B8%80%E4%B8%AA%E7%B3%9F%E7%B3%95%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="一个糟糕的例子">
<h2 id="安全性定理"><a href="#安全性定理" class="headerlink" title="安全性定理"></a>安全性定理</h2><p>要想获得安全的 MAC，我们需要输出空间很大，例如：取一个 PRF，输出 80 位就很好了，它会产生 80 位 MAC，因此任意攻击者的优势最多是 1/2^(80)。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%86.PNG" class title="安全性定理">
<h2 id="安全性定理证明"><a href="#安全性定理证明" class="headerlink" title="安全性定理证明"></a>安全性定理证明</h2><p>假设有一个从信息空间到标签空间的真随机函数，<code>f:X→Y</code>，这是一个从 X 到 Y 的真随机函数，它是从所有函数集中随机选择的。攻击者获得了信息 $m_1$ 的标签，即在点 $m_1$ 处的函数值，然后攻击者重新选择信息 $m_2$ ，获得了 $m_2$ 的标签，直到 $m_q$ ，他获得了所有对应的标签，它的目标是产生一个新的信息标签对就赢了，也就是存在性伪造，<code>t=f(m)</code>，意味着 t 是 m 的一个有效标签，并且 m 必须是新的，不能是 $m_1$ 到 $m_q$ 中的任何一个，然后它以 1/Y 的概率猜中函数值。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%86%E8%AF%81%E6%98%8E.PNG" class title="安全性定理证明">
<h2 id="简单引理"><a href="#简单引理" class="headerlink" title="简单引理"></a>简单引理</h2><p>如果 N 位 PRF 是安全的，那么 T&lt;N 位的PRF（截断PRF，1/2^T可忽略）也是安全的。</p>
<h1 id="cbc-mac-and-nmac"><a href="#CBC-MAC-and-NMAC" class="headerlink" title="CBC-MAC and NMAC"></a>CBC-MAC and NMAC</h1><h2 id="cbc-mac"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h2><p>CBC-MAC（ECBC，常与AES一起使用）：取针对短信息的 PRF 为输入，输出一个 PRF ，可以处理长信息作为输出。在银行业广为应用，确保支票的完整性。</p>
<p>取信息 m ，将它分割成一个个的分组，每个分组和底层函数 f 的分组一样长，然后沿着 CBC 链接运行，但不输出中间值。</p>
<p>CBC-MAC 可以取最多长 L 个分组的信息，L 可以是百万或十亿的大小。它还可以是变化的输入信息的长度，换句话说，|X|不大于 L，意思是允许输入的信息包含的<u>分组数</u>可以是 0 到 L 的任一数，每个 CBC 可以处理一个分组长的信息、两个分组长的信息、… 、L 个分组长的信息。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/ECBC.PNG" class title="ECBC">
<p>不经历最后一步 $k_1$ 加密的函数，叫做<u>原 CBC 函数</u>。不是一个安全的 MAC。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/CBC-MAC%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7%E6%94%BB%E5%87%BB.PNG" class title="CBC-MAC的扩展性攻击">
<h2 id="一个特殊的攻击"><a href="#一个特殊的攻击" class="headerlink" title="一个特殊的攻击"></a>一个特殊的攻击</h2><p>不经历最后一步 $k_1$ 加密的函数，在这个攻击里，攻击者先请求一个特定信息 m 的标签，信息 m 只有一个分组长，对一个单分组信息应用 CBC 意味着，只需要直接应用函数 f ，就获得了这个标签（即直接应用 f 在单分组信息 m 处的结果），现在攻击者有了<code>t=F(k,m)</code>，现在我们声称他可以定义这个信息 m’ ，包含两个分组，第一个是 m ，第二个是 t⊕m ，我们声称刚刚收到的 t 是这两个分组的信息 m’ 的标签，t 是这个两分组信息<code>m&#39;=(m,t⊕m)</code>的有效 MAC ，攻击者可以产生这个有效的标签 t ，而这个两份组的信息是从未被询问过的，因此，他可以破解这个 MAC 。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E6%94%BB%E5%87%BB.PNG" class title="一个特殊的攻击">
<h2 id="hmac"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>HMAC 取处理短输入的 PRF ，产生能处理长输入的 PRF，在因特网上 SSL、IPesc、SSH 等协议使用 HMAC 来保护完整性。</p>
<h2 id="nmac"><a href="#NMAC" class="headerlink" title="NMAC"></a>NMAC</h2><p>NMAC 同上，取处理短输入的 PRF ，产生能处理长输入的 PRF。NMAC 不常与分组密码配合使用，主要原因是在 NMAC 机制里各个分组的密钥会变化，这意味着整个 AES 密钥扩展对每个分组都必须重新计算，而当密钥快速变化时 AES 并不是能表现很好，因此，使用 NMAC 时，可以使用更善于处理各个分支上变化密钥的分组密码，因此， NMAC 一般不用 AES 。事实上，<u>NMAC 是 HMAC 的基础</u>。</p>
<p>NMAC 用到的 PRF 的分组长度 |X| 远远大于密钥长度，把固定的补齐附在信息后面，fpad 是固定的补齐。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/NMAC.PNG" class title="NMAC">
<p>不经历最后一步 $k_1$ 加密的函数，为<u>级联函数</u>。不是安全的 MAC。最后一步的加密阻止了<u>扩展攻击</u>，扩展攻击是针对级联的唯一一种攻击。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/NMAC%E4%B8%8D%E8%BF%9B%E8%A1%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AD%A5%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="NMAC不进行最后一步加密的例子">
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/NMAC%E7%9A%84%E6%89%A9%E5%B1%95%E6%80%A7%E6%94%BB%E5%87%BB.PNG" class title="NMAC的扩展性攻击">
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%862.PNG" class title="安全性定理2">
<h2 id="针对-cbc-mac-的安全性定理"><a href="#针对-CBC-MAC-的安全性定理" class="headerlink" title="针对 CBC-MAC 的安全性定理"></a>针对 CBC-MAC 的安全性定理</h2><p>q 是询问的信息数，并用一个特定密钥计算 MAC ，假设我们想确保所有的攻击者区分 PRF 和真随机函数的优势都小于 1/2^32 ，根据安全性定理，这意味着我们需要确保 <code>(q^2)/|X| &lt; 1/2^32</code>，超过了 32 这个安全长度就必须更换密钥。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E9%92%88%E5%AF%B9CBC-MAC%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%86.PNG" class title="针对CBC-MAC的安全性定理">
<h2 id="attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><p>在签名了 |X| 或 |K| 的平方根 个信息后，MAC 就不再安全。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/Attack.PNG" class title="Attack">
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/Attack2.PNG" class title="Attack2">
<p>针对 PRF ，同时也是针对 ECBC 和 NMAC 的攻击：假设底层函数是 PRP ，是类似 AES 的分组密码，记为 F ，F 可以是 F_ECBC 或 F_NMAC ，F 意味着这是一个针对长信息的 PRF 。现在，实际上两种机制都有如下的扩展性质，如果给我一个碰撞，发生在信息 X 和 Y 上，那么事实上，这也意味着有一个碰撞发生在 X 和 Y 的扩展上，换句话说，如果我把 W 各附在 X 和 Y 的后面，我也会在这些信息上获得一个碰撞，那么很难说服自己这个扩展性质是成立的。</p>
<p>观察下面这张图，正好在 tag 那里发生膨胀，记得我假设 F 是 PRP ，那么一旦固定 $k_1$ ，它就是一一映射的函数，于是，如果两个信息正好被映射到输出的同一个值，这就意味着它们正好被映射到同样的值作为 原CBC 的输出。但如果它们在 原CBC 的输出中被映射到同样的值，这意味着如果我加上另外一个分组，我们记为 W ，我获得了这个输出，然后计算这两个信息的共同的函数值，对两个信息，我都会在点得到同样的值，当用 $k_1$ 加密时，会获得同样的输出，即最终输出。在我附上分组 W 后，如果两个不同信息的两个值正好是一样的，依然能获得同样的输出值，便容易说服自己。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E9%92%88%E5%AF%B9PRF%E7%9A%84%E6%94%BB%E5%87%BB.PNG" class title="针对PRF的攻击">
<h1 id="mac-padding"><a href="#MAC-padding" class="headerlink" title="MAC padding"></a>MAC padding</h1><h2 id="一个糟糕的补齐"><a href="#一个糟糕的补齐" class="headerlink" title="一个糟糕的补齐"></a>一个糟糕的补齐</h2><p>当 ECBC 信息长度不是分组长度的整数倍时，需要对最后一个分组补齐信息。取最后一个分组，在后面补 0 至其长度和一个满分组的长度一样，这样的 MAC 是不安全的。因为这样可以计算出新的信息 m ，信息 m 联结上 0 ，正好也有同样的补齐，一旦带入 m 和 m∥0 到 ECBC 中，我们会得到同样的标签输出，这意味着 m 和 m∥0 有着相同的标签，因此攻击者可以实施存在性伪造，他会问信息 m 的标签，然后他会输出伪造的标签和信息 m∥0 。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E4%B8%80%E4%B8%AA%E7%B3%9F%E7%B3%95%E7%9A%84%E8%A1%A5%E9%BD%90.PNG" class title="一个糟糕的补齐">
<h2 id="补齐函数"><a href="#补齐函数" class="headerlink" title="补齐函数"></a>补齐函数</h2><p>补齐函数本身必须是一一映射的函数，换句话说，它应当是将两个不同的信息映射到不同的两个补齐的信息，不应该在补齐函数上有碰撞，必须是可逆的。$m_0$ ≠ $m_1$  =&gt;  pad($m_0$)  ≠ pad($m_1$)</p>
<h2 id="完美的补齐方法"><a href="#完美的补齐方法" class="headerlink" title="完美的补齐方法"></a>完美的补齐方法</h2><p>ISO 建议把字符串 “1000…00” 附在信息后面，使得信息长度是分组长度的倍数，这个补齐是可逆的，我们只需描述求逆的算法，就是简单的从右往左扫描信息，直到遇见第一个 1 ，然后移除所有在 1 右边的位，包括 1 本身，就可以获得原来的信息。</p>
<p>如果原信息长度已经是分组长度的整数倍，在这种情况下，加一个假的分组非常重要，假设我们不加假的分组去计算这个信息的 MAC ，结果是，如果你看到这个信息的长度是分组长度的整数倍，还有一个信息的长度不是分组长度的倍数，但它被补齐到分组大小了，想象这个信息以 100 结尾，如下图，与第二个根本没补齐的信息是一样的，因此，如果我问第一个信息的标签，同时我也获得了第二个以 100 结尾的信息的标签。如果我们不加假的补齐分组，补齐将是不可逆的，因为两个不同的信息正好被映射到了同样的补齐结果，因此 MAC 将不安全。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/MAC%E8%A1%A5%E9%BD%90.PNG" class title="MAC补齐">
<h2 id="cmac"><a href="#CMAC" class="headerlink" title="CMAC"></a>CMAC</h2><p>如果你看<u>确定的补齐函数</u>，容易证明所有情况下我们都需要补齐，原因是 长度为分组倍数的信息数目 比 长度不是分组倍数的信息数目 少得多（约为 1:2 ），因此我们无法获得一个从 大的所有信息的集合 到 小的分组倍数长的信息集合 的一一映射，总会有我们必须扩展原信息的情况，这种情况就对应于我们加假的补齐分组。但是，有一种非常聪明的方法 CMAC ，可以使用一个<u>随机的补齐函数</u>，不需要加假分组。</p>
<p>CMAC（常与AES一起使用）可以使用一个随机的补齐函数，不用加假分组。使用三密钥机制，第一个密钥 k 用于 CBC 计算标准的 CBC-MAC 算法，密钥 $k_1$ 和 $k_2$ 仅用于最后一个分组的补齐。 $k_1$ 和 $k_2$ 是使用伪随机数发生器由 k 推出的。如果信息长度正好是分组长度的整数倍，采用 ISO 补齐，并把最后一个分组和密钥 $k_1$ 异或；如果信息长度不是分组长度的整数倍，不做扩展，把最后一个分组和密钥 $k_2$ 异或。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/CMAC.PNG" class title="CMAC">
<p>攻击者不知道 $k_1$ 和 $k_2$ ，因此攻击者不知道随后分组运行了哪个函数，不可能实施对级联函数、原CBC 所适用的扩展攻击。</p>
<p>CMAC 机制是一个伪随机函数，具有与 CBC-MAC 同样的安全性。</p>
<p><strong>使用 CMAC 的好处</strong>：①不需要做 原CBC 函数后面的最终加密步骤；②通过两个密钥来区分信息长度是否是分组长度的倍数问题，解决了“是否发生了补齐”所带来的歧义。</p>
<h1 id="a-parallel-mac"><a href="#A-Parallel-MAC" class="headerlink" title="A Parallel MAC"></a>A Parallel MAC</h1><h2 id="pmac"><a href="#PMAC" class="headerlink" title="PMAC"></a>PMAC</h2><p>PMAC 可并行，使用了一个底层的 PRF 来构建一个 PRF去处理长得多的信息。密钥是一对密钥，一个给 PRF，另一个给掩码函数 P。采用与 CMAC 类似的补齐函数，不需要加假的分组。</p>
<p>这个机制如下工作：我们取信息，把它分成若干分组，然后我们独立的处理各个分组。首先，我们计算某个函数 P ，并将结果与第一个分组异或，然后我们运用函数 F ，使用密钥 $k_1$ 。我们对每个分组都做同样的事情，我们可以并行地处理，所有分组都被独立地处理，我们收集来所有的结果，然后异或起来，然后再加密一次，就得到了最后的标签。由于技术原因，在最后一个分组上，我们不需要使用 PRF F 了。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/PMAC.PNG" class title="PMAC">
<p><strong>函数 P 的作用</strong>：在运行过程中，如果不与函数 P 进行异或，得到的 MAC 是完全不安全的，因为各个分组之间没有加入先后顺序。特别地，如果随意交换两个分组，将不会改变最后标签的值，因为异或是可交换的，无论我们是否交换分组，标签值都是一样的，因此攻击者可以请求一个特定信息的标签，然后他将获得 其中两分组交换后的信息的标签，这也算存在性伪造。这个函数 P 试图为这些分组加入顺序，首先注意到，这个函数 P 是个带密钥的函数，它取密钥为输入；其次，更为重要的，它取分组序数为输入。换句话说，函数的这个输入每个分组都不相同，这就是用来阻止<strong>分组交换攻击</strong>的，函数 P 其实是一个非常容易计算的函数，给定密钥和分组序数，只是进行了某个有限域上的乘法，对于 PMAC 的运行时间开销很小。</p>
<h2 id="pmac的安全性定理"><a href="#PMAC的安全性定理" class="headerlink" title="PMAC的安全性定理"></a>PMAC的安全性定理</h2><p>如果给我一个攻击 PMAC 的攻击者，我可以构建另一个攻击底层 PRF 的攻击者，加上另一个误差项。由于这个 PRF 是安全的，我们知道这一项是可忽略的，如果我们希望左侧优势可忽略，需要误差项也是可忽略的。其中，q 是使用一个密钥计算 MAC 的信息数，L 是所有这些信息的最大长度。</p>
<p>对于 AES ，分组长度是 2^128，其平方根是 2^64，只要 qL &lt; 2^64，这个 MAC 将是安全的。每次当它接近这个值时，为了计算更多信息的 MAC ，我们必须更换密钥。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/PMAC%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%86.PNG" class title="PMAC安全性定理">
<h2 id="pmac-的数学是增长的"><a href="#PMAC-的数学是增长的" class="headerlink" title="PMAC 的数学是增长的"></a>PMAC 的数学是增长的</h2><p>假设用来构建 PMAC 的函数 F 不仅是 PRF ，而且是 PRP，那么我们能在需要时求 F 的逆，现在假设我们已计算长信息 m 的 MAC，假设这个长信息的一个分组发生了变化，m[1] 变成了 m’[1]，但其他分组不变，对于其它 MAC 机制，比如 CBC-MAC ，即使只有一个分组变化了，我们还是需要重新计算整个信息的标签，重新计算标签需要的时间与信息长度成正比。实际上用 PMAC ，如果我们只变化一个分组或是很少的分组，我们可以很快就完成标签的重新计算。由于使用的是 PRP ，取改变前原信息的标签，我们可以求函数 F 的逆，确定应用函数 F 之前的值，现在我们有了所有分组的异或值，我们可以抵消掉来自原分组的异或部分，将 所有分组的异或值 与 原信息分组传到异或加法器的值 进行异或，再异或 来自新分组传到异或加法器的值，然后再应用函数 F ，就得到新信息的标签。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E6%95%B0%E5%AD%A6%E5%A2%9E%E9%95%BF%E7%9A%84PMAC.PNG" class title="数学增长的PMAC">
<h2 id="一次性mac"><a href="#一次性MAC" class="headerlink" title="一次性MAC"></a>一次性MAC</h2><p>一次性 MAC 构建的 MAC 只用于单个信息的完整性，换句话说，每次计算特定信息的完整性，我们也要改变密钥，任何密钥只能用于一条信息的完整性。</p>
<h2 id="一次性mac安全模型"><a href="#一次性MAC安全模型" class="headerlink" title="一次性MAC安全模型"></a>一次性MAC安全模型</h2><p>我们定义<strong>安全性游戏</strong>，只允许攻击者做一次选择信息攻击，那么，他只提交一个信息的询问，然后得到了这个询问信息对应的标签。现在攻击者的目标是伪造一对信息-标签。当我们只想使用一个密钥，为单条信息提供加密或完整性，通常，我们说一次性 MAC 是安全的，因为没有攻击者可以赢得这场游戏。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E4%B8%80%E6%AC%A1%E6%80%A7MAC%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.PNG" class title="一次性MAC安全模型">
<p>一次性 MAC 对无限强力的攻击者都是安全的，由于只为一次性设计，它可以比基于 PRF 的 MAC 更快。</p>
<h2 id="一次性mac的经典机制"><a href="#一次性MAC的经典机制" class="headerlink" title="一次性MAC的经典机制"></a>一次性MAC的经典机制</h2><p><strong>工作过程</strong>：首先，选取一个比分组大小略大的质数，当我们使用 128 位分组时，我们选的第一个质数大于 2^128 ，质数选为 2^128+51 ，现在这个密钥是一对随机数，它们的取值范围从 1 到我们选的质数 q ，现在我们有一个信息，把它分成若干分组，每个分组 128 位，我们把每个分组里的数视为整数，范围从 0 到 2^128 - 1。现在 MAC 如下定义：首先，我们去我们的分组信息构建它们的多项式，如果信息中有 L 个 分组，我们构建一个 L 次多项式，注意多项式的常数项设为 0 ，我们去信息对应的多项式，计算它在点 K 的值，K 是我们密钥的一半，然后加上 A ，A 是我们密钥的另一半，最后结果取模。这个 MAC 是安全的，如果我告诉你一个特定信息的 MAC 值，并不会告诉你任何关于另一信息的 MAC 的任何信息，因此，即使你已经看过一条信息的 MAC ，你也无法伪造其他信息的 MAC ，但如果你看到了两条信息的 MAC ，那将完全暴露了密钥，MAC 就是可伪造的了。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E4%B8%80%E6%AC%A1%E6%80%A7MAC%E7%9A%84%E7%BB%8F%E5%85%B8%E6%9C%BA%E5%88%B6.PNG" class title="一次性MAC的经典机制">
<h2 id="many-time-mac"><a href="#Many-time-MAC" class="headerlink" title="Many-time MAC"></a>Many-time MAC</h2><p>现在有一个通用的方法可以把一次性 MAC 转变成多次 MAC。假设我们有一次性 MAC ，签名和验证算法分别为 S 和 V ，我们假设签名本身是 n 位 字符串，另外，我们看一个安全的 PRF ，它也正好输出 n 位字符串，但也取 n 位字符串，现在定义一个通用的 MAC 构建，这些 MAC 叫做 Carter-Wegman MAC ，它如下工作：我们对信息 M 应用一次性 MAC ，然后我们用 PRF 加密结果，我们选择一个随机数 r ，根据 r 计算一个一次性密码本，通过对 r 应用 PRF ，然后我们把结果与一次性 MAC 异或，在这个机制里，快速的一次性 MAC 被用到了可能有几个 G 的长信息上，而费时的 PRF 只被应用在新鲜值 r 上，r 接着被用来加密 MAC 的最后结果。</p>
<p>可以证明如果我们的 MAC 作为构建分组，是个安全的 MAC ，而 PRF 也是安全的，那么事实上，我们可以获得一个多次的安全 MAC ，其输出 2n 位标签。</p>
<p>Carter-Wegman MAC 是一个随机的 MAC 的好例子，这个新鲜值 r 每次重新计算标签时，都被重新选取，如果你试图两次计算同一信息的标签，你会选择一个不同的 r ，因此两次你会得到不同的标签。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/Many-timeMAC.PNG" class title="Many-timeMAC">
<p>Carter-Wegman MAC ，不基于 PRF ，因为单个信息可以被映射到许多不同的有效标签。</p>
<p>Carter-Wegman MAC 取大量的信息，计算哈希值，得到一个小标签，计算是用了快速的一次性 MAC ，然后用 PRF 加密。好处是 大量信息的哈希值计算使用了一个快速的一次性 MAC 。</p>
<img src="/2020/04/02/%E3%80%90DanBoneh%E3%80%91MessageIntegrity/%E4%B8%80%E9%81%93%E5%B0%8F%E4%BE%8B%E9%A2%98.PNG" class title="一道小例题">]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Collision Resistance</title>
    <url>/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/</url>
    <content><![CDATA[<h1 id="introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="抗碰撞的哈希函数"><a href="#抗碰撞的哈希函数" class="headerlink" title="抗碰撞的哈希函数"></a>抗碰撞的哈希函数</h2><p><strong>HMAC</strong>：基于<u>抗碰撞的哈希函数</u>构建的。</p>
<a id="more"></a>
<p><strong>碰撞的哈希函数</strong>：一个哈希函数，能将某个信息空间 M 映射到一个标签空间 T （信息空间应当比标签空间大得多），<code>H：M→T (|M| &gt;&gt; |T|)</code>，函数 H 的一个碰撞是一对信息 ($m_0$,$m_1$)， $m_0$ 和 $m_1$ 不同，但应用函数 H 会得到同样的输出。H($m_0$) = H($m_1$) 且 $m_0$ ≠ $m_1$，当应用这个函数时，他们会发生碰撞，即信息空间的 $m_0$ 和 $m_1$ 同被映射到标签空间中的同一个输出（输出空间没有足够的空间来不碰撞地容纳所有信息），则称函数 H 是碰撞的。</p>
<p><strong>抗碰撞的哈希函数</strong>：抗碰撞是指 $m_0$ 和 $m_1$ 不同，使得 H($m_0$) = H($m_1$) 是很难找到的。如果有一个能直接找出这些碰撞的有效算法，我们说这个函数是抗碰撞的。如果对所有有效的算法 A ，这些算法都不能输出函数 H 的碰撞，通常，我们用一个算法 A 能够输出一个碰撞的概率来定义这个优势。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E6%8A%97%E7%A2%B0%E6%92%9E%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.PNG" class title="抗碰撞的哈希函数">
<p><strong>简单应用</strong>：特别地，给定一个抗碰撞的哈希函数，我们看如何简单地构建一个 MAC 。假设我们对短信息有一个 MAC ，假设我们有一个哈希函数是抗碰撞的，它从一个很大的信息空间里取值，将几个 G 的信息映射到小的信息空间里，我们用哈希函数输出值 MAC 来定义它。我们如何验证它呢？给定一个标签，我们通过重新计算给定信息的哈希值来验证，检查小 MAC 值是否能验证给定的标签。这是一个非常简单的方法来证明，抗碰撞可以取一个原型，这个原型可以<u>处理短输入</u>，把这个原型扩展成一个<u>为非常长的输入而构建的原型</u>。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8.PNG" class title="简单应用">
<h2 id="安全性定理"><a href="#安全性定理" class="headerlink" title="安全性定理"></a>安全性定理</h2><p>如果<u>底层 MAC 是安全的</u>，并且 <u>H 是抗碰撞的</u>，那么这个组合可以计算长信息的 MAC ，得到的 MAC 也是安全的。</p>
<p>把这个安全性定理应用到 AES ，在 SHA-256 里，输出 256 位，即 32 字节，我们必须构建一个能处理 32 字节的 MAC ，我们可以应用 16 字节的 AES 把它带入到一个两个分组的 CBC 里，两个分组的 CBC 把 AES 从一个 16 字节的 PRF 扩展成了以一个 32 字节的 PRF ，然后取 SHA-256 的输出，把它带入到两分组的基于 AES 的 CBC 里，然后我们获得了一个非常简单的 MAC ，假设 AES 是个 PRF ，并且 SHA-256 是抗碰撞的，这个 MAC 是安全的。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%86.PNG" class title="安全性定理">
<p>抗碰撞是这个组合 MAC 的安全性的本质。假设我们使用的哈希函数 H 不是抗碰撞的，换句话说，存在一个算法，可以找到两个不同的信息，它们的 MAC 是一样的，这种情况下，这个组合 MAC 是不安全的，因为攻击者可以简单地使用一个选择信息攻击来获得 $m_0$ 的标签，然后输出 ($m_1$,t) 作为一个伪造，确实，t 是 $m_1$ 的一个有效 MAC 。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E4%B8%8D%E6%8A%97%E7%A2%B0%E6%92%9E%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0.PNG" class title="不抗碰撞的哈希函数">
<h2 id="抗碰撞被直接应用于信息的完整性"><a href="#抗碰撞被直接应用于信息的完整性" class="headerlink" title="抗碰撞被直接应用于信息的完整性"></a>抗碰撞被直接应用于信息的完整性</h2><p>想象我们有想保护的文件，我们把这些文件想象成软件包，我们想把这些软件安装在系统里，如下图有三个不同的软件包，现在用户想下载软件包，他想确保他下载的软件包的版本不是某个被攻击者篡改后的版本，内容被攻击者修改了。那么用户可以参考一个比较小的公共空间，这个公共空间只需保存这些软件包的哈希值，不需要很多这样的空间，公共空间唯一的要求是只读。</p>
<p>换句话说，攻击者无法篡改这个空间里的哈希值，然后，一旦用户参考了公共空间，他可以很容易地计算下载的软件包的哈希值，把结果与公共空间进行比较，如果它们相同，用户就知道他下载的版本是正确的。因为函数 H 是抗碰撞的，攻击者无法找到一个戴帽子的 $F_1$ ，可以让它拥有与 $F_1$ 同样的哈希值，因此攻击者无法修改 $F_1$ ，且不会被发现，因为无法让这个戴帽子的 $F_1$ 拥有与公共空间里一样的哈希值。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E6%8A%97%E7%A2%B0%E6%92%9E%E8%A2%AB%E7%9B%B4%E6%8E%A5%E5%BA%94%E7%94%A8%E4%BA%8E%E4%BF%A1%E6%81%AF%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7.PNG" class title="抗碰撞被直接应用于信息的完整性">
<p>我们看一个 MAC 与上述类似的情况，在这个 MAC 的例子里，我们需要一个密钥来验证单个文件的标签，但我们不需要一个只读的公共空间；用抗碰撞的哈希函数，我们就不需要用一个密钥来验证，任何人都可以验证，但是我们需要这个多余的资源，即攻击者不能修改的空间，事实上，我们后面看到数字签名可以在完整性和资源两方面都达到最优，届时我们可以既让公众自行验证，又不需要只读空间。</p>
<p>但目前，只用 MAC 或抗碰撞哈希函数，我们只能达到单方面的要求，事实上，这种机制是非常流行的，实际上，Linux 发行版通常使用公共空间来发布它们软件包的哈希值，任何人在电脑上安装之前，可以确保他们下载了正确的软件包。</p>
<h1 id="generic-birthday-attack"><a href="#Generic-birthday-attack" class="headerlink" title="Generic birthday attack"></a>Generic birthday attack</h1><h2 id="针对抗碰撞哈希函数的通用攻击"><a href="#针对抗碰撞哈希函数的通用攻击" class="headerlink" title="针对抗碰撞哈希函数的通用攻击"></a>针对抗碰撞哈希函数的通用攻击</h2><p>针对<strong>分组密码</strong>的通用攻击是<strong>穷举攻击</strong>，穷举攻击迫使分组密码的密钥大小是 128 位或更多；针对<strong>抗碰撞哈希函数</strong>的通用攻击是<strong>生日攻击</strong>，生日攻击迫使抗碰撞的哈希函数的输出必须多于某个下界。</p>
<p>这里我们有抗碰撞的哈希函数，假设它输出 n 位，换句话说，它的输出空间大小大约是 2^n 。现在，信息空间要远远大于 n 位，我们说待哈希的信息可能有 100 个 n 位长。看这样一个算法，可以用大约 2^(n/2) 的时间，找到这个函数 H 的碰撞，这个<strong>算法</strong>如下工作：</p>
<p>①我们从信息空间里随机选择 2^(n/2) 个信息，即 $m_1$ ，…， $m_2$^(n/2) ，现在因为信息本身远远大于 n 位，它们有上百个 n 位，很有可能这些信息是不相同的，它们互不相同的概率很大。</p>
<p>②但对每一条选中的信息，我们应用哈希函数，获得标签 $t_i$ ，这个 $t_i$ 是 n 位字符串。</p>
<p>③现在我们在 $t_i$ 中寻找一个碰撞，换句话说，我们找一个 i 和 j ，满足 $t_i$ = $t_j$ ，一旦找到了，就等于是发现了碰撞，因为如前所述，以很高的概率，$m_i$ ≠ $m_j$ ，但 $m_i$ 的哈希值等于 $m_j$ 的哈希值，因此，我们找到了函数 H 的碰撞。现在如果我们找遍了这 2^(n/2) 个 $t_i$ 却没有找到碰撞，我们回到第一步尝试另一组 2^(n/2) 个信息。</p>
<p>我们需要迭代这个过程多少次才能发现碰撞？事实上，迭代次数是个非常小的数，意味着这个算法可以以大约正比于 2^(n/2) 的时间找到碰撞。由于每轮迭代会以 1/2 的概率找到碰撞，我们平均需要迭代 2 次，因此这个算法的运行时间是 2^(n/2) 乘以 哈希函数的计算时间（这个算法需要大量的空间 O(2^(n/2)) ，但我们先忽略空间的问题）。如果你的哈希函数输出 n 位，总是存在一个攻击算法 用 2^(n/2) 的时间发现碰撞，比如：如果我们输出 128 位，在 2^64 的时间里，可以找到一个碰撞，这将不是充分安全的，这就是为什么抗碰撞的哈希函数通常不输出 128 位。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E9%92%88%E5%AF%B9%E6%8A%97%E7%A2%B0%E6%92%9E%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E6%94%BB%E5%87%BB.PNG" class title="针对抗碰撞哈希函数的通用攻击">
<p>从下面的例子可以看出，分组越大，算法越慢，有一些性能上的亏损，但安全性上有很多好处。</p>
<p>SHA-1 不推荐使用，有一个理论上的碰撞发现算法，需要 2^51 的时间，所以某人发现一个 SHA-1 的碰撞几乎只是时间问题。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E4%B8%80%E4%BA%9B%E6%8A%97%E7%A2%B0%E6%92%9E%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="一些抗碰撞的例子">
<h2 id="生日悖论的证明"><a href="#生日悖论的证明" class="headerlink" title="生日悖论的证明"></a>生日悖论的证明</h2><p>为了分析这种攻击，我们引入生日悖论的知识，它之所以称为悖论，是因为平方根函数增长缓慢，与人的直觉相悖。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA.PNG" class title="生日悖论">
<p>设想我们有 n 个随机变量 $r_1$ ，$r_2$ ，…，$r_n$ ，取值范围是从 1 到 B 的区间里，我峨嵋你唯一的假设是，这 n 个随机变量是<strong>相互独立</strong>的，而且它们是<strong>同分布</strong>的，例如，它们可能都是在从 1 到 B 的区间里均匀分布的，但它们还是独立的均匀分布的变量。但如果我们把 n 设置为 B 的平方根大小，换句话说，如果我们从区间 1 到 B 内取样约 B 的平方根次，精确的说是 1.2 × B^(1/2) ，那么样本中有两个是一样的概率至少是 1/2 ，事实上，均匀分布是生日悖论中最坏的情况，换句话说，<u>如果 $r_i$ 的分布不是均匀的，事实上，需要取样的次数要少于 1.2 × B^(1/2)</u> 。那么，我们证明均匀分布的情况，也就能证明其他分布的情况，但这里给出的证明只对<u>均匀分布</u>成立。</p>
<p><strong>证明过程</strong>：我们要求 存在一对 i 和 j ，i ≠ j ，满足 $r_i$ = $r_j$ 的概率，我们求互斥事件的概率，就是说我们所求概率为 1 减去 对所有 i ≠ j 都有 $r_i$ ≠ $r_j$ 的概率（这意味着我们选择的 n 个样本里没有发生碰撞）。当我们选择 $r_i$ 时，这是我们第一次选择，所以是不会发生任何碰撞的，但当我们取 $r_2$ 时，$r_2$ 不与 $r_1$ 碰撞的概率是 (B-1)/B ，类似的，当我们选择 $r_3$ ，$r_3$ 不与 $r_1$ 或 $r_2$ 碰撞的概率是 (B-2)/B ，…，直到我们获得了最后的 $r_n$，$r_n$ 不与 不与之前所有的 $r_i$ 碰撞的概率是 (B- (n-1) )/B ，也就是 (B-n+1)/B ，将这些概率乘起来正是因为这些 $r_i$ 是<u>相互独立的</u>。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA%E7%9A%84%E8%AF%81%E6%98%8E.PNG" class title="生日悖论的证明">
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%94%9F%E6%97%A5%E6%82%96%E8%AE%BA%E7%9A%84%E5%9B%BE%E8%A1%A8.PNG" class title="生日悖论的图表">
<h1 id="the-merkle-damgard-paradigm"><a href="#The-Merkle-Damgard-Paradigm" class="headerlink" title="The Merkle-Damgard Paradigm"></a>The Merkle-Damgard Paradigm</h1><h2 id="抗碰撞的哈希函数的构建"><a href="#抗碰撞的哈希函数的构建" class="headerlink" title="抗碰撞的哈希函数的构建"></a>抗碰撞的哈希函数的构建</h2><p>我们的目标是构建一个抗碰撞的哈希函数，对这些函数，即使找到一个碰撞也是困难的（尽管我们知道有很多碰撞存在），没有有效的算法可以输出哪怕一个碰撞。那么我们要构建这些哈希函数，我们分两步构建这些哈希函数：</p>
<p>①如果给我一个处理短信息的抗碰撞哈希函数，我们可以扩展它来构建一个处理长得多的信息的抗碰撞的哈希函数。</p>
<p>②构建安全压缩函数。</p>
<p>Merkle-Damgard 是一个非常通用的机制，所有的标准哈希函数都遵循这个机制，由一个压缩函数，构建抗碰撞的哈希函数。</p>
<p><strong>Merkle-Damgard 工作过程</strong>：这里我们有函数 H ，我们假设 H 是抗碰撞的哈希函数，可以处理短输入，我们使用这个小函数 h ，h 有时叫做<u>压缩函数</u>（从 T 中取元素，正好与哈希函数相反），我们将取长信息 M 把它分成若干分组，然后我们使用一个固定值叫做 IV ，这里 IV 永远是固定的，它内嵌在代码和标准里，只是一个固定的 ID ，是函数的一部分。然后我们对第一个信息分组应用小的压缩函数 h ，一并使用这个 ID ，得到的叫做<u>链接变量</u>，将被交给下一压缩函数来压缩下一分组，一并使用前一链接变量输出下一链接变量，直到我们到达最后分组。在最后分组上，我们要做一个特别的事情，我们必须把补齐分组 PB 附在信息后面，在附上补齐分组之后，我们还是要压缩最后的链接变量与最后的分组，得到的输出就是实际哈希函数的输出。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/Merkle-Damgard%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.PNG" class title="Merkle-Damgard工作过程">
<p><strong>补齐分组</strong>：我们看到，序列 1000 为实际明文分组的结尾，这个分组最重要的部分是 我们对信息长度进行的编码，在这个补齐分组里，信息长度域固定为 64 位，所以在所有所有的 SHA 哈希函数中，最大信息长度为 2^64 - 1 ，事实上信息长度应当适应于 64 位分组，2^64 - 1 位的信息长度的上界对应我们能释放的信息来说足够长了。</p>
<p>如果最后一个分组长度是压缩函数分组长度的倍数，我们怎么办？通常，答案是如果在最后分组中没有空间留给补齐分组时，那么我们就必须加另外一个假分组把补齐函数放在那里。当然以正确的方式写 1000… 有一点非常重要，那就是<u>补齐分组包含信息长度</u>。</p>
<h2 id="相关定理的证明"><a href="#相关定理的证明" class="headerlink" title="相关定理的证明"></a>相关定理的证明</h2><p>Merkle-Damgard 这个机制流行的原因是，下面这个定理告诉我们，如果小的压缩函数是抗碰撞的，那么大的 Merkle-Damgard 哈希函数也是抗碰撞的。换句话说，<u>如果我们要为长输入构建抗碰撞的哈希函数，我们只需要构建一个抗碰撞的压缩函数</u>。</p>
<p>我们证它的逆否命题，也就是，“如果你能找到这个大哈希函数的一个碰撞，那么我们可以推出这个小压缩函数的一个碰撞”，因此，<u>如果 h 是抗碰撞的，那么 H 也是</u>。</p>
<p><strong>证明过程</strong>：</p>
<p>假设给我一个大压缩函数的碰撞，即 两个不同的信息 M 和 M’ ，它们正好被哈希到同一个输出，我们将使用 M 和 M’ 来构建这个小压缩函数的一个碰撞。首先我们必须记住 Merkle-Damgard 机制的过程，特别地，当我们哈希 M 和 M’ ，给链接变量起一些名字当我们计算信息 M 的哈希值时，会得到这些链接变量，那么 $H_0$ 固定的 IV 开启整个过程，$H_1$ 是用 IV 计算第一个分组的哈希结果，直到最后一个链接变量，也是 Merkle-Damgard 链的最后输出。类似地，对于 M’ ，做同样操作得到最后的哈希值。现在注意信息 M 和 M’ 的长度不一定是一样的，特别地，M 的长度为 t ，M’ 的长度为 r ，因为发生了碰撞，我们知道这两个值是一样的，即 H(M) = H(M’) ，换句话说，最后的链接变量相同。</p>
<p>现在仔细看 $H_t+1$ 和 $H_r+1$ 是如何计算的，前者是由压缩函数应用到之前的链接变量，并使用 M 的最后分组得到的，包括补齐分组，注意，这里假设补齐分组可以放在 M 的最后分组里，即使最后的补齐分组在它自己的分组里，也没有任何区别，为了简便，我们假设补齐分组在 M 最后分组里，那么，通过计算最后分组的哈希，要用到补齐分组和最后的链接变量，我们获得了 $H_t+1$ ，类似地，也可以对 M’ 做同样的事情，通过计算最后的信息分组和最后的链接变量的哈希，我们获得了 $H_r+1$ ，由于这两个值相等，突然间我们有了一个候选的压缩函数的碰撞，即下图最后等式两侧小括号中的参数，这两个参数交给压缩函数，正好产生了同样的输出值。我们唯一的捕获的任何碰撞的方法是，如果参数正好是一样的，换句话说，如果压缩函数的参数不同，那么我们就获得了 h 的一个碰撞，证明结束。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%9B%B8%E5%85%B3%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E.PNG" class title="相关定理的证明">
<p>有一种情况我们的证明还没有结束，那就是 两个倒数第二个链接变量相等，且两个信息的最后分组也相等，且两个信息的补齐分组也相等。两个补齐分组相等意味着什么？信息长度被编码在补齐分组里的，特别地，这意味着 M 的长度 和 M’ 的长度一致，即 t=r ，那么现在就可以假设 t=r 了，现在我们可以对倒数第二个链接变量应用同样的参数，换句话说，$H_t$ 是如何计算的？$H_t$ 是计算前一个链接变量 $H_t-1$ 用倒数第二个信息分组哈希得到的，类似地，$H’t$ 也被计算出来，因为这两个值相等，现在我们获得了另一个候选的压缩函数的碰撞，换句话说，如果 $H_t-1$ ≠ $H’t-1$ 或 $M_t-1$ ≠ $M’t-1$ ，那么我们有一个 h 的碰撞，证明结束。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%9B%B8%E5%85%B3%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5.PNG" class title="相关定理的证明的特殊情况">
<p>如果继续发生如上情况，我们可以继续往前迭代，迭代到信息的开始，下面两者之一一定成立：</p>
<p>①找到压缩函数的碰撞。</p>
<p>②M 和 M’ 的所有分组都相同，与碰撞的前提相矛盾。</p>
<h1 id="constructing-compression-functions"><a href="#Constructing-Compression-Functions" class="headerlink" title="Constructing Compression Functions"></a>Constructing Compression Functions</h1><h2 id="由分组密码构建压缩函数"><a href="#由分组密码构建压缩函数" class="headerlink" title="由分组密码构建压缩函数"></a>由分组密码构建压缩函数</h2><h3 id="利用davies-meyer构建压缩函数"><a href="#利用Davies-Meyer构建压缩函数" class="headerlink" title="利用Davies-Meyer构建压缩函数"></a>利用Davies-Meyer构建压缩函数</h3><p>h 抗碰撞 =&gt; H 抗碰撞</p>
<p>我们能否从分组密码来构造压缩函数呢？答案是肯定的。</p>
<p>假设我们这里有一个特定的分组密码，用来处理 n 位分组，输入和输出都是 n 位。有一个经典的机制叫 <strong>Davies-Meyer 机制</strong>：<code>h(H,m) = E(m,H)⊕H</code> ，给定信息分组和链接变量，我们使用<u>信息分组作为密钥</u>来加密链接变量，然后我们在输出上再做一次异或。信息分组 $m_i$ 完全是在攻击者的控制之下，攻击者试图找到碰撞，这样他可以选择他想要的信息分组，我们把这个信息分组作为一个分组密码的密钥，当 E 是一个理想的密码时，我们可以证明这个机制事实上是抗碰撞的。</p>
<p><strong>定理</strong>：如果 E 是一个理想的分组密码，意味着它是一个 {0,1}^n 上的随即置换的集合，如何置换由密钥 K 确定，在这个 E 是理想的分组密码的假设下，事实上，找到这个压缩函数 h 的碰撞需要 2^(n/2) 的时间，特别地，我们可以证明，任何能找到碰撞的人必须至少能花费 2^(n/2) 的时间来加、解密，这意味着，因为这个压缩函数只有 n 位长，总有一个通用的生日攻击可以在 2^(n/2) 的时间里找到碰撞，所以这个定理是说，这个抗碰撞函数确是抗碰撞的，通过生日攻击以在 2^(n/2) 的时间里找到碰撞，但没有算法可以做的比 2^(n/2) 更好。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E5%88%A9%E7%94%A8Davies-Meyer%E6%9E%84%E5%BB%BA%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0.PNG" class title="利用Davies-Meyer构建压缩函数">
<h3 id="一个不抗碰撞压缩函数的例子"><a href="#一个不抗碰撞压缩函数的例子" class="headerlink" title="一个不抗碰撞压缩函数的例子"></a>一个不抗碰撞压缩函数的例子</h3><p>Davies-Meyer 机制有一些特别的地方使得该机制是抗碰撞的，如果仅仅是猜这个机制，很有可能最终得到的不是抗碰撞的压缩函数，我们看如下问题：</p>
<p>假设我们如下定义了压缩函数，<code>h(H,m) = E(m,H)</code> ，我们使用目前分组作为密钥，加密这个链接变量 H，不同之处在于，我们不做 Davies-Meyer 机制里的异或，我们求证这个压缩函数不是抗碰撞的。</p>
<p>我们试图构建一个碰撞，即一对不同的 m 和 m’ 能在这个函数 H 下发生碰撞，我们怎么构造这个碰撞呢？选择任意的 H，m，和 m’ ，唯一的要求是 m 与 m’ 不同，如何构建 H’ 可以找出碰撞？首先，我们选择一个简单的方法来解释，如下图第一个选项，如果我们使用加密函数对两边进行加密，左边我们得到了 H’ 用 E 和密钥 m’ 加密的结果 <code>E(m&#39;,H&#39;)</code> ，右边用 m’ 加密，解密操作会被抵消，只剩下 m 的加密结果 <code>E(m,H)</code> ，即为我们想找的碰撞，这里使用了解密函数 D ，容易为压缩函数构建碰撞。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%97%E7%A2%B0%E6%92%9E%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="一个不抗碰撞压缩函数的例子">
<h3 id="利用miyaguchi-preneel构建压缩函数"><a href="#利用Miyaguchi-Preneel构建压缩函数" class="headerlink" title="利用Miyaguchi-Preneel构建压缩函数"></a>利用Miyaguchi-Preneel构建压缩函数</h3><p>Miyaguchi-Preneel 方法有 12 种变体，通过玩弄各种异或以及把变量放在不同位置等手段，都可以得到一个抗碰撞的机制，但也有许多类似的变体并不是抗碰撞的</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E5%88%A9%E7%94%A8Miyaguchi-Preneel%E6%9E%84%E5%BB%BA%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0.PNG" class title="利用Miyaguchi-Preneel构建压缩函数">
<h3 id="sha-256"><a href="#SHA-256" class="headerlink" title="SHA-256"></a>SHA-256</h3><p>SHA-256 使用了 <strong>Merkel-Damgard 机制</strong> 和 <strong>Davies-Meyer 压缩函数</strong>，那么，Davies-Meyer 的底层分组密码是什么？这个分组密码叫做 <strong>SHACAL-2</strong> ，它的参数使用了 512 位密钥，密钥是从信息分组里提取的，信息分组是 512 位，一次会处理它的 512 位输入信息，这个分组密码的分组大小是 256 位。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/SHA-256.PNG" class title="SHA-256">
<h2 id="由数论里的困难问题构建压缩函数"><a href="#由数论里的困难问题构建压缩函数" class="headerlink" title="由数论里的困难问题构建压缩函数"></a>由数论里的困难问题构建压缩函数</h2><p>我们说这些压缩函数是可证实的，因为如果你可以找到这种压缩函数的碰撞，那么你就可以解决非常困难的理论问题，一般这类问题是难解的。因此，如果数论问题是难解的，得到的压缩函数可被证实是抗碰撞的。</p>
<p><strong>工作过程</strong>：我们选取一个非常大的质数，约 700 个十进制数，2000 位二进制数，我们在 1 到 p 之间选择两个随机数 u 和 v ，现在如下定义压缩函数，它在 0 到 p-1 之间取两个数，输出 0 和 p-1 之间的一个数，那么其压缩率为 2:1 ，然后计算双重指数，计算 $u^H$ × $v^m$ ，现在这个定理表述为一个事实，事实上，如果你找到这个压缩函数的一个碰撞，那么你就可以解一个标准的数论难题，叫做<strong>离散对数问题</strong>。</p>
<p>所有人都相信离散对数问题是难解的，因此这个压缩函数可证实是抗碰撞的。为什么在实际中我们不使用这种压缩函数呢？因为与分组密码相比，这个压缩函数速度太慢了。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E6%95%B0%E8%AE%BA%E5%9B%B0%E9%9A%BE%E9%97%AE%E9%A2%98%E6%9E%84%E5%BB%BA%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%87%BD%E6%95%B0.PNG" class title="数论困难问题构建的压缩函数">
<h1 id="hmaca-mac-from-sha-256"><a href="#HMAC：a-MAC-from-SHA-256" class="headerlink" title="HMAC：a MAC from SHA-256"></a>HMAC：a MAC from SHA-256</h1><p>我们能否不依赖 PRF ，直接用 大的哈希函数 来构建 MAC 呢？</p>
<h2 id="第一个点子"><a href="#第一个点子" class="headerlink" title="第一个点子"></a>第一个点子</h2><p>假设给你一个 Merkel-Damgard 哈希函数，注意到它把长信息哈希成短的摘要，我们想把长信息直接转成 MAC ，首先我们想到，我们为什么不计算 MAC 密钥联结上待求 MAC 的信息后的哈希呢？但实际上，这是<u>完全不安全的</u>，因为由于它的密钥扩展，如果我告诉你一个特定信息的标签 H(m) ，攻击者很容易加上另外一个分组，然后再计算一次压缩函数 h ，现在他们可以获得原信息联结上补齐分组的标签，因此，这是个存在性伪造。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%82%B9%E5%AD%90.PNG" class title="第一个点子">
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%82%B9%E5%AD%90%E5%9B%BE%E8%A7%A3.PNG" class title="第一个点子图解">
<h2 id="hmac"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>有一个标准方法可以把一个抗碰撞的哈希函数转成一个 MAC ，这个标准方法叫做 <strong>HMAC</strong> 。特别地，我们可以使用 SHA-256 这一哈希函数来构建 MAC ，输出 256 位，事实上，人们相信 HMAC 是一个伪随机函数，所以通过 SHA-256 ，我们获得了一个伪随机函数输出 256 位的信息。</p>
<p><strong>工作过程</strong>：首先我们取密钥 k ，然后我们在密钥后面联结一个叫做 ipad 的内部密码本，这使它成为Merkel-Damgard 机制的一个分组，比如，对于 SHA-256 来说将是 512 位，我们把得到的分组附在信息 m 前面，然后求哈希，刚刚证明了只做这些是完全不安全的，不过除此之外， HMAC 还取这 256 位输出，计算密钥 k 与 外部密码本 opad 异或，把异或结果附在 256 位输出的前面，也会形成 512 位的一个分组，然后 HMAC 取这两个分组的哈希值，最终得到信息 m 的标签。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/HMAC.PNG" class title="HMAC">
<p>如果压缩函数 h 是 PRF ，密钥是第一个上面的输入，那么我们计算 PRF h 在固定 IV 处的值，结果是一个随机值，我们记为 $k_1$ ，然后我们应用到 Merkel-Damgard 链，对外部密码本做同样的事情，认为 h 是 PRF ，密钥是上面的输入，我们使用不同的密钥，应用这个 PRF ，计算在固定值 IV 的值，得到另外一个结果 $k_2$ 。现在，当我们使用这些密钥 $k_1$，$k_2$ 来计算 HMAC 时，这看上去非常熟悉，这就是 NMAC 。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/HMAC%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.PNG" class title="HMAC工作示意图">
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/NMAC.PNG" class title="NMAC">
<p>为了证明这是 NMAC 机制，我们必须假设这个压缩函数 h 是 PRF ，密钥是下面的函数输入，我们说这些密码本 ipad 和 opad 它们是固定的 512 位的常数。</p>
<p>我们回头看，发现 HMAC 与 NMAC 的主要不同之处是这些密钥 k⊕ipad ，k⊕opad 互相是有关联的，它们只不过是同样的密钥异或上不同的常数。本质上，密钥 $k_1$ 和 $k_2$ 也是互相关联的，因为它们是在同样的固定值 IV 上应用 PRF 计算得到的。</p>
<p>为了证明 $k_1$ 和 $k_2$ 是伪随机且相互独立的，我们必须证明压缩函数不仅当其上面的输入是密钥时，它是 PRF ，而且当使用关联密钥时，它也是 PRF。基于这些假设，应用对 NMAC 一模一样的分析来分析 HMAC ，我们可以证明 HMAC 是安全的 MAC，其安全的界定与 NMAC 一致，换句话说，你不必改变密钥，只要求 MAC 的信息数小于输出标签的一半空间大小（本质上就是生日攻击里的平方根）。对于 HMAC 和 SHA-256 ，输出空间是 2^256 ，平方根是 2^128 ，这意味着你可以使用 HMAC 和 SHA-256 ，想处理多少信息都可以，而且是始终保持安全的。</p>
<p>TLS 要求支持 HMAC 和 SHA-196 ，意味着 HMAC 由 SHA-1 函数构建，并截断到 96 位，SHA-1 输出 160 位。SHA-1 不再被认为是安全的哈希函数，那怎么能在 HMAC 里使用 SHA-1 呢？实际上，这是没问题的，因为 HMAC 的安全性分析不需要 SHA-1 是抗碰撞的，当输入运行是密钥时，只需要压缩函数 SHA-1 是 PRF ，目前我们知道，这对 SHA-1 的底层压缩函数也成立，即使它可能不是抗碰撞的。</p>
<h1 id="timing-attacks-on-mac-verification"><a href="#Timing-attacks-on-MAC-verification" class="headerlink" title="Timing attacks on MAC verification"></a>Timing attacks on MAC verification</h1><h2 id="计时攻击"><a href="#计时攻击" class="headerlink" title="计时攻击"></a>计时攻击</h2><p>一个特别的 HMAC 验证的实现，这个实现来自 Keyczar 库。输入为 密钥、信息和标签，我们的验证方法是重新计算信息的 HMAC ，然后比较得到的 16 字节与实际给的签名 16 字节。事实上很多人已经实现了它，问题是，如果看下图 “==” 的比较是如何实现的，你可能觉得比较应该是逐字节地进行，第一次发现它不相等的话，循环终止，说两字符串不相等，这造成了针对该密码库的一个严重的<strong>计时攻击</strong>，这是一个非常合理的实现 MAC 验证的程序。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E8%AE%A1%E6%97%B6%E6%94%BB%E5%87%BB.PNG" class title="计时攻击">
<p><strong>攻击过程</strong>：设想你是攻击者，你有信息 m ，你想获得 m 的一个有效标签。现在，你的目标是攻击一个服务器，这个服务器存放着 HMAC 的密钥。这个服务器开放了一个接口，这个接口接收信息与 MAC ，检查这个 MAC 是否有效，如果 MAC 有效，服务器用这个信息进行操作；如果 MAC 无效，服务器拒绝，退回到信息发送方或拒绝这条信息。现在这个攻击者有机会提交大量信息，看看能不能推出特定的攻击信息的标签，我们可以使用计时攻击来做，攻击者提交许多信息询问信息的标签，而信息始终是一样的，但对于标签来说，攻击者尝试很多不同的标签。</p>
<p>①在第一个询问里，攻击者提交目标信息和一个随机标签，然后攻击者测量服务器的反应时间。</p>
<p>②他提交的下一个询问将尝试的第一字节的所有 256 种情况。标签中剩下的字节是任意选取的，它们是什么并不重要，但对于第一个字节，攻击者会提交一个以 0 字节开头的标签，然后他观察服务器是否比之前花稍长一点的时间验证标签。如果服务器花了与第一步严格相同的时间来验证这个标签，那么攻击者会再次尝试，这次以字节 1 开头，如果服务器依然反应迅速，攻击者会尝试以字节 2 开头，直到服务器花了稍微长一点的时间给出反应，就意味着当服务器比较正确的 MAC 和攻击者提交的 MAC 时，在这个字节上，两个 MAC 是一样的，而不一样的是第二个字节。</p>
<p>③攻击者知道第一个字节后，他可以对第二个字节实施一模一样的攻击，直到服务器接受正确的 MAC 。然后我们继续在这个假信息上做手脚，攻击服务器。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E8%AE%A1%E6%97%B6%E6%94%BB%E5%87%BB%E8%BF%87%E7%A8%8B.PNG" class title="计时攻击过程">
<h2 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h2><h3 id="第一种防御方法"><a href="#第一种防御方法" class="headerlink" title="第一种防御方法"></a>第一种防御方法</h3><p>Keyczar 严格地实现了这种防御，首先我们看攻击者提交的签名的字节数是否正确，如果不是，我们就不承认这是个有效的 MAC ，如果签名确实有正确的长度，我们实现比较器，他们总是花相同的时间比较两个字符串。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%951.PNG" class title="防御方法1">
<h3 id="第二种防御方法"><a href="#第二种防御方法" class="headerlink" title="第二种防御方法"></a>第二种防御方法</h3><p>不被广泛实现，这种攻击试图把字符串的比较对攻击者隐藏起来，这里的验证算法取密钥、信息和一个攻击者提供的候选 MAC 作为输入，然后我们进行比较，首先计算信息的正确 MAC ，但然后不直接比较 MAC 和攻击者的签名，我们再取一次哈希值，我们计算 MAC 的哈希值，计算签名的哈希值，让然如果参数一样，它们的哈希也是一样的，所以这个比较会成功。如果签名和 MAC 的第一个字节一样，先不管其他字节的情况，我们再计算一次哈希，很有可能这两个得到的值是完全不一样的，因此，逐字节的比较器会在第一轮就完成输出，这个攻击者将无法知道到底在比较什么字符串，因此不能实施计时攻击。</p>
<img src="/2020/06/25/%E3%80%90DanBoneh%E3%80%91CollisionResistance/%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%952.PNG" class title="防御方法2">]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Number Theory</title>
    <url>/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/</url>
    <content><![CDATA[<h1 id="notation"><a href="#Notation" class="headerlink" title="Notation"></a>Notation</h1><p>N 表示正整数，p 表示正质数。</p>
<p><strong>$Z_N$ 表示集合 {0,1,2,…,N-1}</strong> ，事实上这不仅是一个整数集合，我们可以在上面做加法和乘法，只要我们始终取模 N 即可。<strong>$Z_N$ 表示了一个环，其加法和乘法都定义为模 N 的</strong>。</p>
<a id="more"></a>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/Z_N.PNG" class title="Z_N">
<p>所有关于加法和乘法的运算法则，在 $Z_N$ 中也同样适用。</p>
<h2 id="最大公约数-gcd"><a href="#最大公约数-gcd" class="headerlink" title="最大公约数 gcd"></a>最大公约数 gcd</h2><p>假设给你两个整数 x 和 y ，我们说 x 和 y 的 gcd 是它们的最大共有因数，即 最大的可以同时整除 x 和 y 的整数。</p>
<p>如果给你两个数 x 和 y ，总是存在另外两个整数 a  和 b ，使得 ax + by 是 x 和 y 的 gcd 。gcd(x,y) 是 x 和 y 使用整数 a 和 b 的一个线性组合，根据整数模 N 乘法群中逆元的存在性，可知 a 和 b 存在但不唯一，有一个简单有效的算法可以找到这些整数 a 和 b，这个算法被称为<strong>扩展的欧几里德算法</strong>，能在 x 和 y 的对数的平方的时间里找到 a 和 b 。</p>
<p><strong>如果 gcd(x,y)=1 ，那么，x 和 y 是互质的。</strong></p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0.PNG" class title="最大公约数">
<h2 id="模逆"><a href="#模逆" class="headerlink" title="模逆"></a>模逆</h2><p>模逆：数和它的逆的乘法结果等于单位元 1 。即，2 的逆是 1/2 。</p>
<p><strong>当我们工作在模 N 上时，逆是什么？</strong></p>
<p>$Z_N$ 中的一个元素 x 的逆，就是 $Z_N$ 中的另一元素 y ，使得 xy 等于 $Z_N$ 中的 1 。换句话说， xy =1 in $Z_N$ 。y 记为 $x^{-1}$ ，如果 y 存在，事实上它是唯一的。</p>
<p>N 是一个奇数，求 2 在 $Z_N$ 上的逆？(N+1)/2 。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E6%A8%A1%E9%80%86.PNG" class title="模逆">
<p><strong>$Z_N$ 中哪些元素有逆？</strong></p>
<p>引理：<strong>如果 $Z_N$ 中的一个元素 x 有逆，当且仅当 x 与 N 互质。</strong></p>
<p>证明：</p>
<p>假设 gcd(x,N)=1，那么 x 与 N 互质，根据 gcd 的性质，存在整数 a 和 b ，满足 ax+bN 等于 x 和 N 的 gcd ，也就是 1 ，即 ax+bN=1，两边取模 N ，意思是在 $Z_N$ 中，ax=1，只要我们对这个方程取模 N ，bN 这一项会被消除，因为 bN 被 N 整除，因此是 0 模 N 。</p>
<p>事实上，x 在 $Z_N$ 中的逆就是 a ，所以因为 x 与 N 互质，可以证明 x 可逆，并且构造出了 $x^{-1}$ mod N 。</p>
<p>如果 gcd&gt;1 会怎样？那么我们想证明没有逆。</p>
<p>如果说 a 正好是 x 的模 N 逆，我们看 ax ，ax=1 mod N ，但如果 gcd(x,N)&gt;1 ，那么 gcd(ax,N)&gt;1 ，如果 gcd(ax,N)&gt;1 ，那么 ax 不可能等于 1，所以 ax 必须也大于 1 ，因此 a 不可能是 x 的模 N 逆。</p>
<p>这就证明了，事实上，当 gcd&gt;1，x 不可能有逆，因为没有 a ，使得 ax=1 mod N 。</p>
<p>举个例子，假设 gcd(x,N)=2，我们声称因此 x 不是模 N 逆的，为什么？对于所有的 a ，我们知道 ax 一定是偶数，原因是，2 整除 x ，2 整除 N ，这意味着不可能有 ax=1 mod N ，特别地，不可能有 ax=bx+1 ，因为，2整除 N ，bN 是偶数，bN+1 是奇数，偶数不可能等于奇数，所以对于任意的整数 b ，ax=bN+1 都不可能成立。特别地，这意味着 a 不可能是 x 的逆，因为 ax 不可能是 1 mod N ，所以 x 不是模 N 逆的。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E5%BC%95%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E.PNG" class title="引理的证明">
<p>记 <strong>$Z_N^*$ 为 $Z_N$ 中所有可逆元素</strong>（所有满足 gcd(x,N)=1 的元素组成的集合）。</p>
<p>举个例子，从一个质数 p 开始，我们知道从 0 到 p-1 的所有整数除了整数 0 ，其它都与 p 互质，因为 gcd(p,0) 不是 1 ，==所以如果 p 是质数， $Z_p^*$ 就是 $Z_p$ 除去 0 ，意味着 $Z_p$ 中除 0 外的所有元素都是可逆的==。</p>
<p>所以，如果想计算 $Z_p^*$ 的大小，答案就是 p-1 。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E5%8F%AF%E9%80%86%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88.PNG" class title="可逆元素集合">
<p>如果给你一个 $Z_p^*$ 里的元素 x ，你可以使用扩展的欧几里德算法很快地找出它的逆。如果给你一个线性方程，让你在模 N 下解出来是非常容易的，只需要把 b 移到另一边就有了一个 -b ，然后再乘以 $a^{-1}$ ，使用欧几里德算法找到 $a^{-1}$ ，再用 -b乘以它，取模 N ，得到这个线性方程的解。</p>
<p>欧几里德算法实际上花掉 $log^2$N 的时间，与 $(logN)^2$ 成正比，对于解模 N 的线性方程而言，这是一个平方算法。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B.PNG" class title="解线性方程">
<h1 id="fermat-and-euler"><a href="#Fermat-and-Euler" class="headerlink" title="Fermat and Euler"></a>Fermat and Euler</h1><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>假设给大家一个质数 p ，对 $Z_p^*$ 里的任意元素 x ，如果研究 $x^{p-1}$ ，我在 $Z_p$ 中就会得到 1 。</p>
<p>简单应用1：假设我看 $Z_p^*$ 里的一个元素 x ，p 必须是质数，我们知道 $x^{p-1}$=1 ，那么 x·$x^{p-2}$=1 ，这就是说 x 模 p 的逆正好就是 $x^{p-2}$ ，这就给了我们另外一个计算 x 模质数的逆的算法，计算 $x^{p-2}$ 就会得到 x 的逆。这个算法与欧几里德算法相比有两个不足，①它只能工作在质数模上，而欧几里德算法也能工作在合数模上，②效率低，运行时间实际上是 O($(log)^3$p) 。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86.PNG" class title="费马小定理">
<p>简单应用2：假设我们想生成一个随机的大质数，我们要找的质数是 $2^{1024}$ 的量级，我们可以从一个指定的区间里面选择一个随机整数，然后检测这个选取的整数是不是满足费马小定理，如果等式不成立，那么我们选择的 p 一定不是质数，我们需要返回第一步尝试另一个数，一次次这么做直到最终找到一个整数满足费马小定理的条件，然后输出。事实上，如果一个随机数通过了检测，那么它极有可能是质数，特别地，对于 1024 位的数来说，p 不是质数的概率非常小，小于 $2^{-60}$ 。随着数的变大，一个数通过检测却不是质数的概率迅速向 0 衰减。</p>
<p>我们无法保证输出一定是质数，只知道它非常可能是一个质数。在实际中，并不用这个方法来生成质数。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8.PNG" class title="费马小定理简单应用">
<h2 id="z_p的结构"><a href="#Z-p-的结构" class="headerlink" title="$Z_p^*$的结构"></a>$Z_p^*$的结构</h2><p>$Z_p^*$ 是一个<u>循环群</u>。</p>
<p>这意味着 $Z_p^*$ 里有某个元素 g ，如果我们取 g，计算 g 的一组幂，$g^2$ 、$g^3$ 、$g^4$ 直到 $g^{p-2}$ ，没有点超过 $g^{p-2}$ ，因为根据费马小定理，$g^{p-1}$=1 ，回到了 1 得到了一个循环。</p>
<p>欧拉证明了事实上，有这么一个元素 g ，如果你看到了它的所有幂，可以<u>扩展成整个群</u> $Z_p^*$ 。</p>
<p>g 的幂给出了 $Z_p^*$ 里的所有元素，这样的元素 g 叫做<u>生成元</u>。不是每个元素都是生成元。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E5%8F%AF%E9%80%86%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%93%E6%9E%84.PNG" class title="可逆元素集合的结构">
<p>给定 $Z_p^*$ 里的一个元素 g ，如果我们看 g 的全体幂组成的集合，得到的集合叫做 <u> g 的生成群</u>，记为 <g> 。</g></p>
<p>我们把 g 的生成群的大小叫做 <u>g 在 $Z_p^*$ 里的阶</u>，记为 $ord_p$(g) 。</p>
<p><g>=$ord_p$(g) ，g 的阶是满足在 $Z_p$中，$g^a$=1 的最小的整数 a 。</g></p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/g%E7%9A%84%E9%98%B6.PNG" class title="g的阶">
<p>事实上，1 模任意质数的阶总是 1 。</p>
<p><strong>拉格朗日定理</strong>：有限子群的阶必然整除有限群的阶。拉格朗日定理意味着，<u>如果你看 g 模 p 的阶，这个阶始终整除 p-1</u> 。费马小定理某种意义上是拉格朗日定理的直接推论。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/g%E7%9A%84%E9%98%B62.PNG" class title="g的阶2">
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>欧拉定理是一个费马小定理的直接推广。</p>
<p>给定一个整数 N ，欧拉定义了函数 φ ，φ(N) 表示 $Z_p^*$ 的大小，有时也叫做<u>欧拉的 φ 函数</u>。</p>
<p>我们知道，$Z_p^*$ 包含了 $Z_p$ 中除 0 以外的全部元素，因此，对于任意质数 p ，φ(p)=p-1 。有一个特例，如果 N 正好是两个质数 p 和 q 的乘积，那么 φ(N)=N-p-q+1 ，为什么？N 是 $Z_N$ 的大小，现在我们需要移除所有与 m 不是互质的元素，一个元素如何才能不与 m 互质呢？它要不被 p 整除，要不就被 q 整除，在 0 到 m-1 之间，有多少元素能被 p 整除？一定有 q 个。有多少元素能被 q 整除？一定有 p 个。那么我们减去 p ，来除去那些被 q 整除的数；减去 q ，来除去那些被 p 整除的数，注意我们减了 0 两次，因为 0 被 p 和 q 同时整除，所以我们再加 1 。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0.PNG" class title="欧拉函数">
<p><strong>欧拉定理</strong>：如果给我 $Z_N^*$ 中任意的元素 x ，事实上，$x^{φ(N)} 在 $Z_N$ 中一定等于 1 。特别地，费马小定理只适用于质数的情况，对质数而言，我们知道 φ(p)=p-1 ，换句话说，如果 N 是质数，将 φ(N) 可替换为 p-1 ，就得到了费马小定理。</p>
<p><strong>欧拉定理不仅仅适用于质数，还适用于合数。</strong>欧拉定理也是拉格朗日定理的特例。</p>
<p>事实上，欧拉定理是 RSA 密码系统的基础。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86.PNG" class title="欧拉定理">
<h1 id="modular-eth-roots"><a href="#Modular-e’th-roots" class="headerlink" title="Modular e’th roots"></a>Modular e’th roots</h1><p>我们已经知道通过使用求逆的算法去解线性方程，那么，怎么解高次多项式方程呢？</p>
<p>我们固定质数 p ，c 是 $Z_p$ 中的某元素，在 $Z_p$ 中，x 满足 $x^e$=c ，我们就说 x 是 c 的 e 次方根。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/e%E6%AC%A1%E6%96%B9%E6%A0%B9.PNG" class title="e次方根">
<p>注意，这些 e 次方根不一定总是存在的。例如，$2^{1/2}$ 在 $Z_{11}$ 中不存在。</p>
<p>什么时候这些 e 次方根存在？当我们知道它们存在时，我们能否有效地计算它们？</p>
<h2 id="简单例子e与p-1互质"><a href="#简单例子-e与p-1互质" class="headerlink" title="简单例子(e与p-1互质)"></a>简单例子(e与p-1互质)</h2><p>看一个简单的例子，当我们想计算某个数的 e 次方根时，正好有 e 与 p-1 互质，这时 $c^{1/e}$ 始终存在，且有一非常容易的算法可以计算出 c 在 $Z_p$ 中的 e 次方根。</p>
<p>首先，因为 e 与 p-1 互质，我们知道 e 模 p-1 有逆，我们计算这个逆，并记之为 d ，然后我们宣称，事实上， $c^{1/e}$ 就是 $c^d$ mod p ，如果这个等式成立，那么首先它证明了对 $Z_p$ 中的所有 c ，c 的 e 次方根总是存在。进一步地，它给出了一个非常有效的算法来计算 c 的 e 次方根，通过简单计算 e 模 p-1 的逆，然后计算 c 的逆次方。</p>
<p>那么，$c^{1/e}$ = $c^d$ mod p 这个方程为何成立？首先，一个事实是，d·e=1 mod p-1 ，这意味着存在某个整数 k ，使得 d·e=k(p-1)+1 ，现在可以确认 $c^d$ 是 c 的一个 e 次方根了，如何确定？取 $c^d$，计算它的 e 次方，如果 $c^d$ 真的是 c 的一个 e 次方根，那么当我们计算它的 e 次方，我们应该会得到 c ，为什么？如图推导，因为 c 在 $Z_p$ 中，根据费马定理，我们知道 $c^{p-1}$=1 ，从而推出最后结果 c ，证明了 $c^d$ 是 c 的 e 次方根。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90.PNG" class title="简单例子">
<p><strong>事实上，当 e 与 p-1 互质时，e 次方根总是存在，根是容易计算的。</strong></p>
<h2 id="经典例子e与p-1不互质"><a href="#经典例子-e与p-1不互质" class="headerlink" title="经典例子(e与p-1不互质)"></a>经典例子(e与p-1不互质)</h2><p>当 e 与 p-1 不互质时，一个经典例子是当 e=2 的情况。</p>
<p>假设我们想计算在 $Z_p$ 中 c 的平方根，那么如果 p 是一个奇质数，事实上从今往后我们一直都关心奇质数，事实上，p-1 是偶数，意味着 2 整除 p-1 ，gcd(2,p-1)≠1 ，所以这不是容易的情况。</p>
<p>当我们工作在奇质数模下，平方函数实际上是 2 到 1 函数，它把 x 和 -x 映射到了同一个值 $x^2$ ，因此说这个函数是 2 到 1 函数。</p>
<p>看当我们计算模 11 的平方会发生什么，1 和 -1 模 11 都被映射到了 1 ；2 和 -2 模 11 都被映射到了 4 ；… ，事实上，1，4，9，5，3，都是有平方根的，比如，4 的平方根是 2 和 9 。事实上，$Z_11$ 里的其它元素都没有平方根，这就引出<strong>二次剩余</strong>。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99.PNG" class title="二次剩余">
<p><strong>二次剩余</strong>：说一个  $Z_p$ 中的元素 x ，如果事实上它在  $Z_p$ 中<u>有一个平方根</u>，我们称之为一个二次剩余；如果没有，就称为二次非剩余。例如，4 模 11 是一个二次剩余。</p>
<p><strong>如果 p 是一个奇质数，$Z_p$ 中的二次剩余一共有多少个？</strong><u>这个平方函数是 2 到 1 的映射，意味着  $Z_p$ 中有一半的元素在这个映射中没有原像</u>，所以二次剩余的总数是 (p-1)/2+1 ，因为我们知道 $Z_p$ 中的一半元素是二次剩余的，因为平方函数是 2 到 1 的映射，所以映射的像最多有 (p-1)/2 个元素，在 $Z_p^*$ 里有 (p-1)/2 个二次剩余，<u>$Z_p$ 中还有 0 也是二次剩余的</u>，$Z_p$ 中一共有(p-1)/2+1 个二次剩余。</p>
<p><strong>我们能否对 $Z_p^*$ 里的一个元素 x 判断出 x 是否有平方根呢？</strong></p>
<p>欧拉提出了一个非常清楚的标准测试这些元素是否是二次剩余。特别地，他说<strong>在 $Z_p$ 中，x 是二次剩余，当且仅当 $x^{(p-1)/2}$=1 mod p</strong> 。</p>
<p>当我们工作在模 11 下时，可以看到 $x^{(p-1)/2}$ 始终是 1 或 -1 ，<u>在二次剩余1，3，4，5，9上它一定是 1</u> ；而其它元素不是二次剩余，没有平方根。事实上，工作在模 11 下，如果我们取一个非 0 的数 x ，我们看 $x^{(p-1)/2}$ ，我们可以把它写成 $x^{p-1}$ 的平方根，根据费马小定理，$x^{p-1}$=1 ，$x^{(p-1)/2}$ 就是 1 的平方根，一定是 1 或 -1 。</p>
<p>$x^{(p-1)/2}$ 这个值有个名字叫<strong>勒让德符号</strong>，<u>$Z_p$ 中所有元素的勒让德符号不是 1 就是 -1 取决于 x 是否是二次剩余的</u>。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E6%AC%A7%E6%8B%89%E5%BC%95%E7%90%86.PNG" class title="欧拉引理">
<p>如果我们想计算一个二次剩余的平方根，这个引理并没有告诉我们怎么办。</p>
<h2 id="计算质数模的平方根"><a href="#计算质数模的平方根" class="headerlink" title="计算质数模的平方根"></a>计算质数模的平方根</h2><p>分两种情况。</p>
<p><strong>第一种情况</strong>：p=3 (mod 4) 时，非常容易计算平方根，这种情况下，c 的平方根就是 $c^{(p+1)/4}$ ，p=3 (mod 4) 必然有 p+1=0 mod 4 ，意味着 p+1 被 4 整除，因此 (p+1)/4 是一个整数，就允许计算这个幂，给了我们 c 的平方根。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%83%85%E5%86%B5.PNG" class title="第一种情况">
<p><strong>解模 p 的二次方程</strong>：假设给你一个二次方程，让你找到 $Z_p$ 中这个二次方程的解，使用如图方法。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E8%A7%A3%E6%A8%A1p%E7%9A%84%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B.PNG" class title="解模p的二次方程">
<p><strong>计算合数模的根</strong></p>
<p>什么时候模 N 的 e 次方根存在？如果我们知道它存在能否有效地计算它？</p>
<p>事实上，我们只知道计算合数模的 e 次方根与分解合数一样困难，现在，对于一个普通的数 e 不知道是否是最优的，但我们有的最好的计算模 N 的 e 次方根的算法，需要我们分解这个模，一旦我们分解了这个模，那么实际上每个质数因数的 e 次方根是容易计算的，我们可以组合所有的这些 e 次方根，来得到合数模 N 的 e 次方根。</p>
<h1 id="arithmetic-algorithms"><a href="#Arithmetic-algorithms" class="headerlink" title="Arithmetic algorithms"></a>Arithmetic algorithms</h1><p>加法有进位，减法有借位，这些都是<u>线性时间操作</u>，换句话说，如果你想加或者减两个 n 位整数，运行时间与 n 成线性。</p>
<p>天然的乘法会花<u>平方时间</u>，1960年 Karatsuba 发现运行时间只需要 <u>$n^{1585}$</u> ，很常用，大多数的密码学库都是用这个算法实现乘法。实际上可以用大约 n·log(n) 的时间（几乎线性的时间）来计算乘法，它忽略了很大的常数，只有当乘数十分巨大时才实用，实际上用的不多。</p>
<p>带余数的除法，实际上也是个<u>平方时间算法</u>。</p>
<h2 id="求幂问题"><a href="#求幂问题" class="headerlink" title="求幂问题"></a>求幂问题</h2><p>这个指数问题，设想我们有一个有限循环群 G ，这意味着这个群是由生成元 g 的各个幂生成的，共有群的阶数个幂。比如群 $Z_p^*$ ，g 是某个 G 的生成元，事实上还有很多有限循环群的例子。</p>
<p>现在，我们的目标是，给定这个生成元 g ，以及某个指数 x ，计算 $g^x$ 。通常情况下你会认为，如果 x=3 ，我要计算 $g^3$ 。这会花费指数级时间，<strong>如何在 x 非常大的情况下依然很快地计算 $g^x$ ？</strong>使用<strong>重复平方算法</strong>。</p>
<p><strong>重复平方算法工作过程</strong>：假设要计算 53 个 g 的乘积，把 53 写成二进制，如图，53 是 32+16+4+1 ，这意味着 $g^{53}$ 就是 $g^{32+16+4+1}$ ，我们可以把指数分解开，使用指数法则。这给出了一个计算想法，我们取 g ，然后开始计算平方、再平方等，然后简单的乘合适的幂，就可以得到结果。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E9%87%8D%E5%A4%8D%E5%B9%B3%E6%96%B9%E6%B3%95.PNG" class title="重复平方法">
<p>下图中，z 累乘着合适的幂。循环次数是 $log_2$x 。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E9%87%8D%E5%A4%8D%E5%B9%B3%E6%96%B9%E6%B3%952.PNG" class title="重复平方法2">
<h2 id="运行时间小结"><a href="#运行时间小结" class="headerlink" title="运行时间小结"></a>运行时间小结</h2><p>假设我们有一个 N 位模，$Z_N$ 上的加减法花线性时间；简化乘法需平方时间；指数需要 log(x) 次循环，每轮做两次乘法即 log(x) 次乘法，乘法的时间是平方的，所以运行时间是 $n^2$log(x) ，指数算法是立方时间算法。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E5%B0%8F%E7%BB%93.PNG" class title="运行时间小结">
<h1 id="intractable-problems"><a href="#Intractable-problems" class="headerlink" title="Intractable problems"></a>Intractable problems</h1><h2 id="简单问题"><a href="#简单问题" class="headerlink" title="简单问题"></a>简单问题</h2><p>如果给我一个整数 N ，给我一个 $Z_N$ 中的指数 x ，使用欧几里德算法找到 x 的逆是很容易的。</p>
<p>如果给我一个质数 p ，给我某个多项式 f ，找到 $Z_N$ 中的一个元素，使得它是这个多项式的根也很容易。实际上有一个有效的算法，用时与多项式次数呈线性，至少对于低次数的多项式，找到这些方程的质数模的根很容易。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E7%AE%80%E5%8D%95%E9%97%AE%E9%A2%98.PNG" class title="简单问题">
<h2 id="经典的质数模的困难问题"><a href="#经典的质数模的困难问题" class="headerlink" title="经典的质数模的困难问题"></a>经典的质数模的困难问题</h2><p>困难的问题组成了许多公钥密码系统的基础。</p>
<p>固定某个大质数 p ，固定 $Z_p^*$ 中的某个元素 g ，我们假设这个元素 g 的阶正好是数 q ，现在，考虑一个指数函数，将 x 映射到 $g^x$ ，，这个函数是容易计算的。</p>
<p>现在，看相反的问题，给定 $g^x$ ，想找出它的对数，即值 x 。在实数上，给定 $g^x$ ，找 x 就是对数函数的定义，但在这里找的是模 p 下的对数，这个问题叫<strong>离散对数问题</strong>，Dlog ，<u>$g^x$ 的以 g 为底的离散对数是这个指数 x</u> 。我们的目标是输出指数 x ，x 在 0 到 q-2 的范围里正好是 $log_2$x 。</p>
<p>看一个例子，假设看整数模 11 ，写下 $Z_11$ 里的离散对数函数，底数为 2 ，这个函数如下工作：首先，1 的离散对数是 0 ，因为 $2^0$ 是 1 。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98.PNG" class title="离散对数问题">
<p>一般情况下的离散对数函数的计算是很困难的，当然，对于小质数而言是很容易的，做一张表可以读到离散对数值，但如果质数 p 是个大数，计算离散对数是很困难的。</p>
<p><strong>更一般地定义离散对数问题</strong>，不再局限于群 $Z_p^*$ ，更为抽象的看一个普通群。</p>
<p>我们有一个有限循环群，生成元是 g ，这意味着，这个群由 g 的各次幂组成。我们取所有的幂，一共有阶数个，这里 G 的阶正好是 q ，那么我们取 g 所有的幂，组成了群 G ，群 G 的离散对数问题是困难的，事实上没有有效的算法能够计算离散对数函数。</p>
<p>如果你从群 G 中随机选择一个元素 g ，再随机选择一个指数 x ，同时给出这个群的描述、阶数，但最初的元素只有 g 和 $g^x$ ，这个算法会计算出离散对数的概率是可忽略的。如果这点对所有的有效算法都成立，那么我们说在群 G 上，离散对数问题是困难的。</p>
<p>没有有效的算法能以不可忽略的概率计算出离散对数。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E6%9B%B4%E4%B8%80%E8%88%AC%E7%9A%84%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E9%97%AE%E9%A2%98.PNG" class title="更一般的离散对数问题">
<h2 id="亚指数算法"><a href="#亚指数算法" class="headerlink" title="亚指数算法"></a>亚指数算法</h2><p>在 $Z_p^*$ 中计算离散对数有一个亚指数算法，如果你有一个 n 位的质数，这个算法的运行时间的指数大约是 n 的立方根，事实上，在这个算法的运行时间里，这里有很多其他项，但最主要的项是质数的位数的立方根，即 n 的立方根。因为有这个算法，如果我们想让离散对数问题变得与破解相应的对称密钥一样难，我们必须使用较大的模 p 。</p>
<p>如果看椭圆曲线群，参数会好很多，事实上在一个椭圆曲线群里，我们对离散对数的最好算法运行时间为 $2^{n/2}$ 。</p>
<p>椭圆曲线大小是对称密钥大小两倍的原因是由于指数里的因子 2 ，我们必须将椭圆曲线群的大小扩大一倍，以获得 $2^n$ 的运行时间。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E4%BA%9A%E6%8C%87%E6%95%B0%E7%AE%97%E6%B3%95.PNG" class title="亚指数算法">
<p><a href="https://lemongx.github.io/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/" target="_blank" rel="noopener">相关笔记链接</a></p>
<h2 id="离散对数困难性的直接应用"><a href="#离散对数困难性的直接应用" class="headerlink" title="离散对数困难性的直接应用"></a>离散对数困难性的直接应用</h2><p>特别地，我们基于离散对数问题构建一个抗碰撞哈希函数，我们选择一个群 G ，G 上的离散对数问题是困难的，可以把 G 想象成群 $Z_p^*$ ，我们假设群 G 有质数阶 q ，那么 q 是某个质数且正好为 |G| ，即群 G 里元素的个数，现在我们选择群 G 中的两个元素 g 和 h 定义如下哈希函数 H ：哈希函数的输入为 x 和 y 时，输出 $g^x$· $h^y$ 。</p>
<p>这个函数 H 事实上是抗碰撞的，就是说，找到一个 H 的碰撞与计算 G 上的离散对数一样困难。特别地，如果你可以找到一个 H 的碰撞，你就能计算 g 底 h 的离散对数，由于计算离散对数是困难的，所以找 H 的碰撞也是困难的。</p>
<p>证明：假设我们有一个函数 H 的碰撞，碰撞为两对不同的信息对，($x_0$,$y_0$) 与 ($x_1$,$y_1$) ，它们正好在函数 H 上发生碰撞，也就是说，如果计算函数值 H($x_0$,$y_0$) 和 H($x_1$,$y_1$) ，就会得到一个碰撞，也就是会得到相等的结果。然后做一些变换，取两边的 ($y_1$-$y_0$) 次方根，另一边得到 h 。我们用 g 的某个幂表示了 h ，所以就计算出了 g 底 h 的离散对数。那么这个指数里除以 ($y_1$-$y_0$) 是什么意思呢？这个意思就是让我们计算 ($y_1$-$y_0$) 的模 q 的逆，然后把结果与 ($x_0$-$x_1$) 相乘。</p>
<img src="/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0%E5%9B%B0%E9%9A%BE%E6%80%A7%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%BA%94%E7%94%A8.PNG" class title="离散对数困难性的直接应用">
<p>这也展示了为什么我们希望 q 是质数，因为我们需要确保 ($y_1$-$y_0$) 始终可逆，那么事实上我们知道，当我工作在质数模时，除了 0 ，所有数都可逆，这就遇到了一个难以理解的地方，如果 $y_1$-$y_0$=0 会怎样？如果是这种情况，我们无法得到离散对数，我们不能除以 0 ，如果 $y_1$-$y_0$=0 ，意味着 $y_1$=$y_0$ ，看上图式子最左侧，$x_1$ 也必须等于 $x_0$ ，这与碰撞的前提相矛盾，相当于给了同样的信息对两次，因此，不需要去找离散对数了。但如果给我一个碰撞，$y_1$ 与 $y_0$ 有必要是不同的，然后将计算 h 底 g 的离散对数，由于群 G 上的离散对数被认为是困难的，这意味着这个非常简单的函数 H 一定是抗碰撞的。</p>
<p>尽管这个函数有一个漂亮的抗碰撞的证明，但不怎么用，因为每次哈希需要计算两次指数，相对较慢。</p>
<h2 id="合数模的经典难题"><a href="#合数模的经典难题" class="headerlink" title="合数模的经典难题"></a>合数模的经典难题</h2><p>1024 位数，定义集合 $Z_{(2)}(n)$ 表示所有的整数，正好是两个质数的乘积，这两个质数都是 n 位的，2 对应于这个集合的数都有两个质因子，这两个质因子差不多大小都是 n 位的质数</p>
<p><strong>难题一</strong>：如果选择 $Z_{(2)}(n)$ 中的一个随机整数，如何分解它？</p>
<p>1024 位的数尽管还没有被解出来，但很有可能这个数量级的数将很快被因子分解，现在推荐的值是 2048 位的数。</p>
<p><strong>难题二</strong>：给出某个非线性多项式，如果多项式次数大于 1 ，给出 $Z_{(2)}(n)$ 中的某个随机的合数，如何找到这个方程的根 x ？</p>
<p>如果次数等于 1 那就是解线性方程，很容易；但当次数变成非线性时，我们不知道怎么解这个模 N 的方程。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】One Time Pad</title>
    <url>/2020/03/24/%E3%80%90DanBoneh%E3%80%91OneTimePad/</url>
    <content><![CDATA[<p><strong>密码</strong>由<u>加密算法 E</u>（经常是一个随机算法） 和<u>解密算法 D</u>（是确定算法） 组成。定义为一个三元组 <u>（K, M, E）</u>，全体可能的密钥（密钥空间）记为 K ，全体可能的明文空间记为 M ，全体可能的密文空间记为 E。<code>E：K×M→E</code> ；<code>D：K×E→M</code>。</p>
<p><strong>一致性方程</strong>：∀m∈M，k∈K，D(k,E(k,m)) = m。</p>
<p><strong>Vernam密码</strong>（一次性密码本OTP）：它的明文空间与其密文空间一样，是全体 n 位二进制字符串的集合，<code>M=E={0,1}ⁿ</code>，<code>K={0,1}ⁿ</code>，<code>密钥key=(与明文等长的随机字符串)</code>。</p>
<p><code>c: = E(k,m) = k⊕m</code>；<code>m: = D(k,c) = k⊕c</code>。</p>
<p><code>D(k,E(k,m)) = D(k,k⊕m) = k⊕k⊕m = m</code>。</p>
<a id="more"></a>
<p>给定明文 M 和密文 C 很容易求出密钥 K ，C = M⊕K，C⊕M = M⊕K⊕M，<code>K=M⊕C</code>，同时可以得出，<u>只有一个</u>密钥 K ，能够满足 E(K,M) = C。</p>
<p>关于<strong>应用</strong>：Alice和Bob想要通信，必须传递一个和明文等长的密钥，这和直接安全传递明文没有区别，实际中很难应用。</p>
<p><strong>关于安全</strong>：Shannon（香农）定义的安全想法是，如果得到了密文，从中无法得出一点关于明文的信息。</p>
<p><strong>密码完美安全</strong>（perfect secrecy）：假设有加密算法 E 和解密算法 D ，定义在三元组 (K,M,C) 上，满足如下条件：</p>
<p>对 M 中任意两个<u>长度相同</u>的明文 m0 和 m1 ，对 C 中的任意密文，满足 <code>Pr[E(k,m0) = c] = Pr[E(k,m1) = c]</code> 的概率关系，且密钥分布是均匀的。</p>
<img src="/2020/03/24/%E3%80%90DanBoneh%E3%80%91OneTimePad/the_oretic_Security.PNG" class title="the_oretic_Security">
<p>对于完美安全的密码，任何唯密攻击都无效，一次性密码本有完美安全，但完美安全并不意味着一次性密码本在实际应用中是安全的。</p>
<p>Shannon证明了完美安全，还证明，如果一个密码是完美安全的，其全体密钥数 不少于其能处理的明文数，意味着 密钥长度必须不小于明文长度。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Odds And Ends</title>
    <url>/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/</url>
    <content><![CDATA[<h1 id="key-derivation"><a href="#Key-Derivation" class="headerlink" title="Key Derivation"></a>Key Derivation</h1><h2 id="从一个密钥推出多个密钥"><a href="#从一个密钥推出多个密钥" class="headerlink" title="从一个密钥推出多个密钥"></a>从一个密钥推出多个密钥</h2><p>设想我们有一个特定的源密钥，源密钥有很多种方法生成，设想源密钥是由一个<u>硬件随机数发生器</u>生成的，或者可能是由<u>密钥交换协议</u>生成的，攻击者不知道源密钥是什么。在很多情况下，我们需要很多密钥来保证会话的安全，不仅仅是单个源密钥。</p>
<a id="more"></a>
<p><strong>如何使用一个源密钥，从一个硬件过程或密钥交换，来生成一堆密钥来保证我们的会话安全？</strong></p>
<p>使用<strong>密钥推导函数</strong>（<strong>KDF</strong>）来实现。</p>
<h2 id="均匀分布的源密钥构建-kdf"><a href="#均匀分布的源密钥构建-KDF" class="headerlink" title="均匀分布的源密钥构建 KDF"></a>均匀分布的源密钥构建 KDF</h2><p>首先，假设我们有一个安全的 PRF ，正好有密钥空间 K ，现在假设我们的源密钥 SK 在密钥空间 K 中均匀分布，这时，源密钥实际上是安全 PRF F 的一个均匀随机密钥，我们可以直接使用它来生成多个密钥。在这种情况下，KDF 很简单，工作过程如下：取<u>源密钥</u>、<u>一个上下文参数</u>、<u>输入的长度</u>为输入，然后计算 PRF 在 0 处的值、1 处的值、… 、直到 L ，使用输出中你需要的那么多位来<u>截断输出</u>，来生成会话的全部密钥。如果需要生成单向密钥，每个方向都有一个密钥，包括加密密钥和一个 MAC 密钥，当你生成了足够多的密钥来保护会话，就截断输出。</p>
<p>CTX（上下文参数）：是一个作为应用身份唯一的字符串，所以实际上可以在一个系统上有多个应用，多个应用试着建立多种安全密钥。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83%E7%9A%84%E6%BA%90%E5%AF%86%E9%92%A5.PNG" class title="均匀分布的源密钥">
<p>假设有三个进程都有密钥生成，这个上下文变量试图把他们三个分开，<strong>上下文变量的目的是什么？</strong>上下文变量用来<strong>分离各个进程</strong>，使得每个进程有属于自己的会话密钥，即使多个进程正好有同样的源密钥 SK 。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%AE%E7%9A%84.PNG" class title="上下文字符串目的">
<h2 id="非均匀分布的源密钥构建-kdf"><a href="#非均匀分布的源密钥构建-KDF" class="headerlink" title="非均匀分布的源密钥构建 KDF"></a>非均匀分布的源密钥构建 KDF</h2><p>如果源密钥不是均匀分布的密钥，对于伪随机函数来说，我们不能继续假设 伪随机函数的输出是与随机函数的输出 不可区分的了，事实上，我们只使用刚刚描述的 KDF ，其输出看起来可能并不随机，这样，攻击者可能可以预期某些我们使用的会话密钥，进而破解会话。</p>
<p><strong>为什么这个源密钥会不是随机分布的呢？</strong>原因有很多，比如：</p>
<p>①如果使用一个密钥交换协议，很可能这个密钥交换协议会生成一个高熵的密钥（高熵，意味着字符串的分布接近均匀，但不是均匀分布），高熵的密钥分布于密钥空间的一个子空间，那么这个密钥不是均匀分布的字符串，它会是某个更大集合的子集上的均匀分布，所以，KDF 必须适应密钥交换协议不能生成均匀分布的字符串这一事实。</p>
<p>②大家使用的硬件随机数发生器可能也会生成不均匀的输出，我们不想依赖输出不均匀的硬件随机数发生器，所以，我们只假设输出结果含有高熵，但可能是不均匀的。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E9%9D%9E%E5%9D%87%E5%8C%80%E5%88%86%E5%B8%83%E7%9A%84%E6%BA%90%E5%AF%86%E9%92%A5.PNG" class title="非均匀分布的源密钥">
<p>在这种情况下，我们必须从某种意义上清楚这种不均匀，因此引入了<strong>“先提取再扩展”机制</strong>构建 KDF 。</p>
<p><strong>“先提取再扩展”机制工作过程</strong>：</p>
<p>①从实际源密钥中<u>提取一个伪随机密钥</u>。从下图可知，某种意义上，源密钥有多种可能的值，下图为这些值的概率分布，左图是一个分布崎岖的函数，说明源密钥并不是再密钥空间上均匀分布的，这里我们使用提取器（这种提取器最后不一定产生均匀分布的输出，但生成的分布与真的均匀分布不可区分。）取这个不均匀的函数为输入，把它变成一个密钥空间上的均匀分布。现在，提取器取一个<strong>盐</strong>作为输入，这个盐的作用就是捣乱，不管输入分布如何，输出分布依然与随机分布不可区分。盐不是秘密的字符串，是公开知道的，攻击者知道盐也无所谓，而且，盐是<u>固定的</u>值，盐是<u>随机选择的</u>，试图提取的有趣的分布在本质上并不依赖于选择的盐，因此使用盐的结果是得到一个看起来与随机分布不可区分的分布，某种意义上，盐是用来防御可能会干扰提取器的恶意的坏分布。</p>
<p>②使用安全的 PRF 把密钥扩展成我们需要的那么多位来保证会话安全。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E2%80%9C%E5%85%88%E6%8F%90%E5%8F%96%E5%86%8D%E6%89%A9%E5%B1%95%E2%80%9D%E6%9C%BA%E5%88%B6%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.PNG" class title="“先提取再扩展”机制工作过程">
<h2 id="hkdf"><a href="#HKDF" class="headerlink" title="HKDF"></a>HKDF</h2><p>HKDF 是一个 KDF ，是使用 HMAC 构建的密钥推导函数，这里 HMAC 既用于 PRF 进行扩展，又用于提取器来提取最初的伪随机密钥。</p>
<p><strong>工作过程</strong>：</p>
<p>在进一步提取中，我们使用盐（随机选择的、固定的、公开的）作为 HMAC 的密钥，然后把源密钥作为 HMAC 的数据，当我们使用 HMAC 时，获得的密钥看起来与随机的不可区分。</p>
<p>假设源密钥有足够的熵，现在我们有了这个伪随机密码，我们将要使用 HMAC 作为一个 PRF 来生成一个我们需要的、用于会话密钥那么多位的会话密钥。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/HKDF.PNG" class title="HKDF">
<p>注意！一旦有了从硬件或密钥交换协议得来的源密钥，把它转换成会话密钥，不是通过使用直接的取样，永远不要直接使用源密钥作为协议里的会话密钥。将源密钥交给一个 KDF ，KDF 会给你所有的密钥和你需要的输出。</p>
<h2 id="基于密码的-kdfpbkdf从密码中提取密钥"><a href="#基于密码的-KDF（PBKDF-从密码中提取密钥）" class="headerlink" title="基于密码的 KDF（PBKDF/从密码中提取密钥）"></a>基于密码的 KDF（PBKDF/从密码中提取密钥）</h2><p>密码通常含有较低的熵，约为 20 位左右，对于根据密码生成会话密钥来说是不够的，因此，我们需要根据密码推导加密密钥和 MAC 密钥，做法如下：首先，出于这种目的，不要使用 HKDF ，因为其设计与我们的目标不符，若使用 HKDF ，推导出的密钥对于字典攻击是脆弱的。</p>
<p>PBKDF 通过两种手段防御造成字典攻击的低熵问题，①在使用盐前，盐是一个公开的固定值；②使用慢哈希函数。</p>
<p><strong>PKCS#5</strong> ：一种从密码推导密钥的标准方法，我们讨论 PBKDF1 版本，这个机制在大多数密码学库中都已实现，我们不应该自己去实现，我们只需要调用一个函数，由密码推导密钥，不过，这个密钥没有高熵，而这个 PBKDF 试图<u>让这个猜测问题尽可能困难</u>（只是更困难，不是不可能），工作过程如下：首先，它们计算密码联结上盐后所得字符串的哈希值，然后这个哈希函数被设计成一个非常慢的哈希函数，构造一个慢哈希函数的方法是取一个特定的哈希函数，迭代它很多次，记为 c 次（只需要很短的时间），所说的迭代，是取密码和盐放在这个哈希函数的输入里，然后应用哈希函数获得一个输出，然后再应用哈希函数获得另一个输出，一次又一次后，我们获得了最后的输出作为这个密钥推导函数的密钥输出。</p>
<p>但是，攻击者可以尝试字典里的所有密码，因为人们更愿意选择字典里的密码，攻击者也知道公开的盐，他可以一个一个尝试这个哈希，但字典里的密码很多，需要花掉很长时间，从而减缓了字典攻击，从而使得攻击者更难猜中会话密钥。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%9F%BA%E4%BA%8E%E5%AF%86%E7%A0%81%E7%9A%84KDF.PNG" class title="基于密码的KDF">
<h1 id="deterministic-encryption"><a href="#Deterministic-Encryption" class="headerlink" title="Deterministic Encryption"></a>Deterministic Encryption</h1><p>确定性加密，是指一个加密系统总是把给定明文映射到同一个密文，没有用到新鲜值，只是一个一致性加密机制。</p>
<h2 id="查找加密数据库的例子"><a href="#查找加密数据库的例子" class="headerlink" title="查找加密数据库的例子"></a>查找加密数据库的例子</h2><p>有一个服务器，存储了一个加密数据库，它存储的是记录，每条记录都有一个索引，一些数据存储在记录里，现在，服务器首先要加密这条记录，索引被密钥 $k_1$ 加密了，数据被密钥 $k_2$ 加密了，加密好的记录发送给数据库，同样的事情发生在许多记录上，这样整个数据库保存了许多加密的记录。</p>
<p>如果加密是确定性的，当服务器想提取数据库中的一条记录时，他只需要向数据库发送加密后的服务器感兴趣的记录的索引，这里它会发送加密后的索引 Alice ，获得的密文与最初写入数据库时生成的密文一样，数据库可以找到这个记录，把结果发送给服务器，在这里，数据库完全不知道自己存储了什么数据，也不知道服务器提取了什么记录，因为数据库看到的请求都是密文形式的。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%8A%A0%E5%AF%86.PNG" class title="确定性加密">
<p><u>确定性加密不可能是选择明文安全的</u>，攻击者可以看到不同的密文，如果看到同样的密文两次，他就知道被加密的明文一定是一样的，即，通过密文攻击者可以学到一些对应明文的信息。在实际中，这会带来非常严重的攻击，当明文空间很小时，确定性加密是不安全的。在加密数据库的情况下，攻击者会看到，如果有两个记录在索引位置正好有同样的密文，那么他就知道了这两条记录对应同一个索引，尽管他不知道索引是什么，他也能学习到明文的信息。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E7%A1%AE%E5%AE%9A%E6%80%A7%E5%8A%A0%E5%AF%86%E4%B8%8D%E5%8F%AF%E8%83%BD%E6%98%AF%E9%80%89%E6%8B%A9%E6%98%8E%E6%96%87%E5%AE%89%E5%85%A8%E7%9A%84.PNG" class title="确定性加密不可能是选择明文安全的">
<h2 id="cpa选择明文攻击的游戏"><a href="#CPA（选择明文攻击）的游戏" class="headerlink" title="CPA（选择明文攻击）的游戏"></a>CPA（选择明文攻击）的游戏</h2><p>这个游戏开始时，攻击者选择发送两条明文信息 $m_0$ 和 $m_0$ ，在这个游戏里，攻击者总能得到左边或右边明文信息的加密结果，在当前情况下，左右两边的明文信息是一样的，攻击者将会得到信息 $m_0$ 的加密，下一次，攻击者会发送明文信息 $m_0$ ，$m_1$，现在，他将获得 $m_0$ 或 $m_1$ 的加密，攻击者的目标是确定他得到的是哪一个信息的加密，由于这个加密是确定的，攻击者很容易分辨，他只需要测试 c 是否等于 $c_0$ ，如果 c=$c_0$ ，他就知道获得的是 $m_0$ 的加密，否则就是 $m_1$ 的加密。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/CPA%E6%B8%B8%E6%88%8F.PNG" class title="CPA游戏">
<p>事实上，这不是一个确定性加密的 CPA 攻击，因为两次询问了同样的信息 $m_0$ 的加密。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>限制能够使用单个密钥加密的信息的类型，想法是，让加密者永远不要用单个密钥来加密同样的明文信息，换句话说，信息密钥对 (k,m) 总是不同的。</p>
<p>①如果明文正好是随机的，当我们加密时，事实上，很可能所有使用一个主密钥加密的明文是互不相同的，因为这些密钥不太可能重复。</p>
<p>②明文之所以不会重复，是因为明文空间中的某些结构，如，加密唯一用户的id。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E4%B8%A4%E4%B8%AA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.PNG" class title="两个解决方法">
<h2 id="确定性的cpa安全游戏"><a href="#确定性的CPA安全游戏" class="headerlink" title="确定性的CPA安全游戏"></a>确定性的CPA安全游戏</h2><p>通常我们把密码定义为一对加密、解密算法，所以我们有一个密钥空间、信息空间和密文空间，我们要定义安全性，依照惯例使用两个实验来定义，这个游戏与标准的 CPA 游戏几乎一样。</p>
<p>攻击者发送询问，可以看到这些询问包含了明文信息 $m_0$ 和 $m_1$ ，并且它们的长度必须一样，对于每个询问，攻击者会获得 $m_0$ 或 $m_1$ 的加密结果，他反复这样做 q 次，在游戏的最后要判断他获得的是左边信息的加密还是右边信息的加密，这是标准的选择明文攻击游戏。</p>
<p>但是，如果最左侧给挑战者的 <u>b=0</u> ，换句话说，攻击者总能看到左边明文的加密，那么碰巧，<u>左边的信息都是不同的</u>，正是因为所有的信息 $m_0$ 都是不同的，那么，他不会看到同样的信息被同样的密钥加密，类似地，我峨嵋你要求所有的信息 $m_1$ 也都是不同的，如果 b=1 ，攻击者永远不会看到两条信息被同一个密钥加密。以上是说，<u>加密者不会使用同样密钥多次加密同样的明文信息</u>。因此，攻击者不能多次询问，用同样的密钥对同样的信息进行加密的结果。<u>这个机制是语义安全的</u>。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E7%A1%AE%E5%AE%9A%E6%80%A7CPA%E5%AE%89%E5%85%A8%E6%B8%B8%E6%88%8F.PNG" class title="确定性CPA安全游戏">
<h2 id="带固定-iv-的-cbc-不是确定的-cpa-安全的"><a href="#带固定-IV-的-CBC-不是确定的-CPA-安全的" class="headerlink" title="带固定 IV 的 CBC 不是确定的 CPA 安全的"></a>带固定 IV 的 CBC 不是确定的 CPA 安全的</h2><p>假设我们有一个 PRP 正好定义在 n 位分组上，我们要以 CBC 模式使用这个 PRP ，如果信息中有 5 个分组，那么这个 PRP E 会被调用 5 次来解密各个分组，攻击如下进行：</p>
<p>攻击者首先询问信息 $0_n<script type="math/tex">1_n$ 的加密结果，即，第一个分组全是 0 第二个分组全是 1 .左边的信息等于右边的信息，意味着他想得到 $0_n</script>1_n$ 的密文。为求完整性，写下固定的 IV 作为密文的第一个元素，如果考虑 CBC 然后工作，密文的第二个元素是 IV 异或明文的第一个分组，在这个情况下第一个明文分组全是 0 ，所以我们所加密的就是一个固定的 IV ，那么密文的第二个分组将是这个固定 IV 的加密。</p>
<p>接下来，攻击者会输出两个单分组的信息，第一个信息在左边，是全 0  的分组，第二个信息在右边，是全 1 的分组，观察到这是一个有效的确定性 CPA 询问，因为左边的信息不相同，右边的信息也不相同，现在，攻击者得到如下回复，如果他获得了左边信息的加密，那么全是 0 的一个分组的明文信息加密后就是固定 IV 的加密结果；如果他获得右边信息的加密，那将是 1 异或固定 IV 后的加密。如果图中两个黄圈中的分组正好是一样的，那么我们知道他收到了左边明文信息的加密，b=0 ，如果不一样，攻击者就知道 b=1 ，这就证明了带固定 IV 的 CBC 不是确定的 CPA 安全的。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%B8%A6%E5%9B%BA%E5%AE%9AIV%E7%9A%84CBC%E4%B8%8D%E6%98%AF%E7%A1%AE%E5%AE%9A%E7%9A%84CPA%E5%AE%89%E5%85%A8%E7%9A%84.PNG" class title="带固定IV的CBC不是确定的CPA安全的">
<p><strong>关于固定 IV 的计数器模式，是不是确定的 CPA 安全的？</strong></p>
<p>答案是否定的，因为这是一次性补齐的加密，如果使用这个一次性密码本来加密不同的明文信息，我们会得到一个二次密码本，CPA 安全游戏如图，可以实施两次密码本攻击。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%B8%A6%E5%9B%BA%E5%AE%9AIV%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8D%E6%98%AF%E7%A1%AE%E5%AE%9A%E7%9A%84CPA%E5%AE%89%E5%85%A8%E7%9A%84.PNG" class title="带固定IV的计数器模式不是确定的CPA安全的">
<h1 id="deterministic-encryption-constructions-siv-and-wide-prp"><a href="#Deterministic-Encryption-Constructions-SIV-and-wide-PRP" class="headerlink" title="Deterministic Encryption Constructions: SIV and wide PRP"></a>Deterministic Encryption Constructions: SIV and wide PRP</h1><p>当加密数据库时，确定的安全性加密是需要的，例如，当加密数据库索引时，稍后想要使用这个加密的索引查找记录，由于加密是确定的，能够保证，当查找加密的索引时，这个索引和当初记录被写进数据库时给出的索引是一样的，这个确定性加密可以让我们以简单快捷的方式根据加密的索引查找记录。</p>
<h2 id="确定性-cpa-安全的机制-1siv"><a href="#确定性-CPA-安全的机制-1：SIV" class="headerlink" title="确定性 CPA 安全的机制 1：SIV"></a>确定性 CPA 安全的机制 1：SIV</h2><p><strong>合成 IV 机制的工作流程</strong>如下：</p>
<p>有一个通用的 CPA 安全加密系统，以密钥、明文信息、r 为输入，r 是加密算法里使用的随机性，如果一个 CPA 安全系统不使用新鲜值的话，必须是随机的，所以写下变量 r 表示被用于加密算法的随机字符串。</p>
<p>现在，我们还需要一个伪随机函数 f ，这个函数 f 取信息空间里的任意信息作为输入，输出一个字符串 R ，这个 CPA 安全的加密系统可使用 R 作为随机性，r 实际上是集合 R 的一个元素。</p>
<p>SIV 使用两个密钥 $k_1$ 和 $k_2$ 来加密明文信息 m ，首先 SIV ①应用伪随机函数 f ，根据明文 M 来推导用于 CPA 安全的加密机制 E 的随机性，然后②使用推导出的随机性来加密明文 m ，③我们会得到密文 c 并输出。</p>
<p>如果加密机制 E 正好是随机计数器模式的，那么随机性 r 就是随机 IV，这个 IV 会随密文一并输出，这意味着，密文比明文略长，但在这里，不是要去生成短密文，而是要确保加密机制的确定性，所以如果我们多次加密了同样的明文，每次我们应当获得同样的密文，其实我们每次都会获得同样的随机性 r 。</p>
<p>很容易证明，这个加密机制在确定的选择明文攻击下是语义安全的。因为我们应用伪随机函数 F 来处理多个信息，那么生成的随机字符串看起来像是真随机字符串，每条信息都有不同的随机字符串，因此，这个 CPA 安全的加密机制总是使用真随机字符串。</p>
<p>这对于一个 AES 分组的明文来说特别合适，事实上，对于短明文信息，我们将看到一个稍有不同的加密机制，更适合这些短明文信息。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/SIV.PNG" class title="SIV">
<p>SIV 免费获得了密文完整性，事实上，如果想加上完整性的话，我们不必使用特定的 MAC ，某种意义上，SIV 已经构建了完整性机制。</p>
<p>首先，我们的目标是构建<strong>确定的认证加密</strong>（<strong>DAE</strong>），确定性认证加密的意思是，确定性的 CPA 安全加上密文完整性。密文完整性的意思是，攻击者询问他选择的信息的加密结果，而他不能产生另一个密文可以被解密成有效的明文。</p>
<p><strong>随机计数器模式的SIV加密过程</strong>：</p>
<p>看一个 SIV 的特例，其底层的加密机制是随机计数器模式，记为 <strong>SIV-CTR</strong> ，我们取明文信息，然后对明文应用 PRF ，推导出一个 IV ，然后 IV 被用在使用随机计数器模式加密明文信息，特别地，我们要使用这个 PRF Fctr 表示 F 计数器，随机计数器模式计算 Fctr 在 IV 处的值，在 IV+1 处的值，一直到 IV+L ，然后给出最终的密文。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E9%9A%8F%E6%9C%BA%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84SIV%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B.PNG" class title="随机计数器模式的SIV加密过程">
<p><strong>随机计数器模式的SIV解密过程</strong>：</p>
<p>在随机计数器模式的 SIV 的解密过程中，我们增加一个检查以提供密文完整性，这里我们有包含 IV 和密文的 输入密文，首先我们将使用给定的 IV 解密密文，我们会得到一个候选明文，现在再次应用 PRF F 来处理这个得到的明文信息，根据 SIV 的定义，如果得到的明文有效，我们应该获得与攻击者在密文中所提供的同样的 IV，如果我们得到一个不同的 IV ，那么这个明文不是有效的，我们就拒绝这个明文，解密中的这个检查实际上足以提供密文完整性。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E9%9A%8F%E6%9C%BA%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84SIV%E8%A7%A3%E5%AF%86%E8%BF%87%E7%A8%8B.PNG" class title="随机计数器模式的SIV解密过程">
<p>所以，确定的认证加密，用一个简单的定理来表述：<strong>如果 F 是一个安全的 PRF ，在计数器模式中这是由 CPA 安全的 Fctr 推出的，然后事实上得到的机制是确定性的认证加密系统</strong>。</p>
<p>为了证明这个定理，我们只需要证明密文完整性，因为之前已经证明了这个系统有确定性的 CPA 安全。</p>
<p>为了证明这个系统有密文完整性，我们看这个密文完整性是如何工作的：攻击者询问一组他选择的明文的加密结果，然后他获得相应的密文，目标是<u>产生一个新的有效的密文</u>，如果这个有效密文在解密时被解密成了全新的明文，那么我们把这个新信息带入 PRF F ，我们将获得某个随机 IV ，这个 IV 基本上不可能是攻击者在输出的密文中提供的 IV ，这就是说，当攻击者输出它的伪造密文时，伪造密文里的信息应该等于他在选择明文询问里得到的信息之一，否则，得到的 IV 以很高的概率不等于伪造的密文中提供的 IV，但如果明文等于攻击者问过的明文之一，那么我们得到的密文将等于提供给攻击者的密文之一，也就是说，攻击者伪造的密文就是我们曾给他的密文之一，所以，这不是一个有效的伪造。</p>
<h2 id="确定性-cpa-安全的机制-2just-use-a-prp"><a href="#确定性-CPA-安全的机制-2：just-use-a-PRP" class="headerlink" title="确定性 CPA 安全的机制 2：just use a PRP"></a>确定性 CPA 安全的机制 2：just use a PRP</h2><p>这个机制很简单，只需要直接使用 PRP ，假设 (E,D) 是一个安全的 PRP ，E 是加密，D 是解密，如果我们直接使用 E ，就已经给了我们确定性 CPA 安全性。证明如下：</p>
<p>假设 F 是从 X 到 X 的真随机可逆函数，在 实验0 里，攻击者将看到他提交的一组明文信息，也就是左边的信息，攻击者会看到函数 f 在左边信息上的值，在这个确定性的 CPA 游戏里，所有这些信息都不一样，他会得到 q 个不同 X 中的随机值。现在我们想 实验1 ，在 实验1 中，攻击者收到右边信息的加密，从 m11 到 mq1 ，这些信息也都是不同的所以攻击者韩式获得 q 个 X 中的随机的不同值，实验0 和 实验1 的这两个分布是相等的，因此，他不能区分 实验0 和 实验1 ，由于他对真随机函数不能区分，他对这个 PRP 也不能区分。</p>
<p>因此，直接用 PRP 加密已经给了我们一个 CPA 安全系统。</p>
<p>这说明，如果我们只想加密短信息，比如说，少于 16 字节的信息，我们只需要直接使用 AES 加密它们，得到的结果事实上就是确定性的 CPA 安全的。但是注意，这<u>不会提供完整性</u>。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E4%BD%BF%E7%94%A8PRP%E6%9E%84%E5%BB%BA%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84CPA%E5%AE%89%E5%85%A8.PNG" class title="使用PRP构建确定性的CPA安全">
<p><strong>如果我们的明文长于 16 个字节，怎么办？</strong></p>
<p>①使用 SIV。</p>
<p>②还是使用这个机制，我们能不能构建大明文空间的 PRP ？我们曾根据小明文空间的 PRF ，组建过大明文空间的 PRF ，这里要从小明文空间出发，组建大明文空间的 PRP ，可以这样做：</p>
<p>假设 E，D 是一个安全的 PRP ，定义在 n 位分组上，有一个标准模式叫做 <strong>EME</strong> ，会组件一个 N 位分组上的 PRP ，N 远远大于 n ，这使得我们可以进行确定性加密，能加密长于 16 字节的明文信息。<strong>EME工作流程</strong>如下：</p>
<p>EME 使用了两个密钥 K 和 L ，事实上，在 EME 中，L 是由 K 推出的，不过为了我们的目标，我们假定 K 和 L 是不同的密钥。首先，我们取明文 x ，把它分解成若干分组，我们对每个分组使用函数 P 用密钥 L 来推导一个不同的密码本，然后把每个分组都异或这个特定的密码本，接下来我们应用 PRP E，使用密钥 K ，对每个分组进行操作，我们叫这些输出为 PP0，PP1，PP2 。接下来，我们把所有的 PPP 异或起来，我们叫异或结果为 MP ，用 E 和 密钥 K 加密这个 MP ，加密的输出叫做 MC ，然后计算 MP⊕MC ，得到 PM ，我们使用 PM 来推导更多的密码本，然后我们把这个密码本的输出和所有 PPP 异或，得到 CCC ，然后把所有这些 CCC 异或我们得到的一个值叫 CCC0 ，然后我们使用这些 E 再加密一次，用 P 做更多的密码本，最后我们得到 EME 的输出。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/EME.PNG" class title="EME">
<p>如果底层分组密码 E 是个安全的 PRP ，这个 EME 机制在这个大分组上是安全的 PRP 。这个机制的好处是，他是可并行的。事实上，EME 可能比 SIV 慢很多，PRP 机制擅长处理短明文信息，而 SIV 擅长处理长信息的加密。</p>
<p><strong>如果我们想对于这个基于 PRP 的机制加上完整性，怎么办？</strong></p>
<p>取明文信息，在信息后面附一堆 0 ，然后应用 PRP 给出密文。</p>
<p>解密时，看获得的明文的这些低位如果它们不等于 0 ，就拒绝这个明文；如果等于 0 ，就输出有效信息。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%9F%BA%E4%BA%8EPRP%E7%9A%84%E7%A1%AE%E5%AE%9A%E6%80%A7%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86.PNG" class title="基于PRP的确定性认证加密">
<p>如果附了 n 个 0 ，你需要 1/$2^n$ 是可忽略的，如果是这样，这个直接基于 PRP 的加密提供了确定性的认证加密，为什么呢？我们已经论证了 CPA 安全，只需论证它提供了密文完整性。</p>
<p>在这个密文游戏里，输入空间是明文空间和 n 位 0 ，攻击者会提交 q 个明文信息，然后收到了 q 个他选择的点联结上 n 位后对应的 PRP 的值，对于随机置换来说，他会看到，这个置换在他选的 q 个点的值，在这个密文完整性游戏中，攻击者的目标是产生一些与他之前获得的密文都不同的新的密文，这些新密文可以顺利解密，顺利解密的意思是，当我们对密文 C 应用逆置换后，C 的最低 n 位最好都是 0 ，这个发生的可能性有多大呢？最多是 1/$2^n$ 。因此，攻击者以可忽略的概率赢得这场游戏。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%AF%86%E6%96%87%E5%AE%8C%E6%95%B4%E6%80%A7%E6%B8%B8%E6%88%8F.PNG" class title="密文完整性游戏">
<h1 id="tweakable-encryption"><a href="#Tweakable-encryption" class="headerlink" title="Tweakable encryption"></a>Tweakable encryption</h1><h2 id="硬盘加密"><a href="#硬盘加密" class="headerlink" title="硬盘加密"></a>硬盘加密</h2><p>硬盘加密是指我们想加密硬盘上的扇区，比如，每个扇区是 4KB 长度，问题是没有空间来扩展，那么密文大小也必须是 4KB ，我们的目标是，<u>构建一个不扩展的加密，其密文长度严格等于明文长度</u>。加密不能扩展是什么意思？就是说明文空间等于密文空间。在这个情况下，我们必须使用确定性的加密，因为如果加密是随机的，那么将<u>没有空间来存储随机性</u>，同样，因为不能扩展密文，也不能加完整性的位，<u>也没有空间来存储完整性</u>，因此，最多可以获得确定性的 CPA 安全性。</p>
<p>实际上，可以证明一个简单的引理：<strong>如果给我一个确定性的 CPA 安全的密码，其明文空间等于密文空间，没有扩展，那么这个密码事实上是个 PRP</strong> 。没有扩展，必须使用二号机制 PRP 加密。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E7%A1%AC%E7%9B%98%E5%8A%A0%E5%AF%86.PNG" class title="硬盘加密">
<p>我们把硬盘分解成各个扇区，现在，如果我们使用 PRP 用同样的密钥来加密每一个扇区，我们要看确定性加密的标准问题，如果 扇区1 和 扇区3 正好有同样的明文，那么解密后的 扇区1 正好等于解密后的 扇区3 ，攻击者就知道对应的明文是一样的。如果一些扇区是空的，它们的数据都被设置为 0 ，那么事实上加密的扇区将是一样的，攻击者就会知道哪些扇区是空的。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E7%A1%AC%E7%9B%98%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B.PNG" class title="硬盘加密流程">
<p>我们首先想到的方法是，对每个扇区使用不同的密钥来加密，即使 扇区1=扇区3 ，它们的密文也不会相同，这样就防止了之前讨论的信息泄露，但是，这个模式下也会有很多信息泄露，如果用户正好改变了 1 号扇区里的一位然后这个扇区被加密成了一个不同的密文，就完全被篡改了，因为这是一个伪随机置换，即使明文中的一位改变了，这个扇区也会被映射到一个完全崭新的随机输出，但是，如果撤销了这个改变还原到原先的扇区，那么加密的扇区也会回到原先的状态，攻击者可以知道，一个改变做出后又撤销了，所以还是有一点信息泄露的，但是这种信息泄露，如果不牺牲系统性能，我们无能为力，所以我们忽略这点，姑且认为是可以接受的。</p>
<p>现在，我们的硬盘容量越来越大，有很多扇区这意味着我们要产生很多的密钥，不过我们不需要去存储所有的这些密钥，我们可以使用一个伪随机函数生成这些密钥，工作方法是：有一个主密钥 k ，记扇区号为 t ，各个扇区使用主密钥加密，加密的结果是特定扇区的密钥 $k_t$ ，这步是安全的，因为 PRF 与随机函数不可区分。但是，我们对每个扇区都必须应用这个 PRF 就有问题了，怎样做的更好呢？</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E7%A1%AC%E7%9B%98%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B2.PNG" class title="硬盘加密流程2">
<p>实际上我们可以引入<strong>微调分组密码</strong>的概念。</p>
<h2 id="微调分组密码"><a href="#微调分组密码" class="headerlink" title="微调分组密码"></a>微调分组密码</h2><p>我们只需要一个主密钥 k ，我们需要这个主密钥来推导很多 PRP ，一种方法是使用 PRP 数加密密钥 k ，不过还有一个更有效的方法，现在这个 PRP 数就是所谓的微调。</p>
<p>在微调分组密码中，加密和解密算法，通常取密钥 K 、微调 T 、数据 X 为输入，T 为微调空间，输出集合 X 里的数据。</p>
<p>有一个性质是，对每个微调空间里的微调 t ，对每个随机密钥 k ，如果我们固定密钥和微调，那么我们会得到一个可逆的函数，集合 X 上一一映射的函数。因为密钥是随机的，这个函数事实上与随机函数不可区分，换句话说，对每个微调的设定，我们都有一个 X 到 X 的独立 PRP 。</p>
<p>作为这个的应用，我们使用扇区号作为微调，这样一来，每个扇区都有它自己的独立的 PRP 。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%BE%AE%E8%B0%83%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81.PNG" class title="微调分组密码">
<h2 id="安全的微调分组密码"><a href="#安全的微调分组密码" class="headerlink" title="安全的微调分组密码"></a>安全的微调分组密码</h2><p>有一个微调空间 T 和一个信息输入空间 X ，通常我们定义两个实验，在 实验1 中，我们选择一个真随机置换集合，我们不仅仅只选择一个置换，而是与微调数目一样多的置换。我们将选择一个随机密钥，我们根据微调空间里的微调来定义我们的置换集合，然后攻击者提交一个微调和一个 x ，他将看到由微调 $t_1$ 定义的置换在点 $x_1$ 处的值，攻击者会一次又一次地看到这些，攻击者地目标是，<u>分辨出他是在与真随机置换交互，还是与伪随机置换交互</u>，如果攻击者不能做到正确分辨，我们就说这个微调分组密码是安全的。</p>
<p>它<strong>与常规的分组密码的区别</strong>是，在常规的分组密码中，你只能与一个置换进行互动，那么你的目标是，分辨出你是在与一个伪随机置换交互，还是在和一个真随机置换交互；而在这里你是在和 |T| 个随机置换交互，那么你的目标是，区分这 |T| 个随机置换是真是伪。如果攻击者在这两个实验中表现相同，我们说这个 PRP 是一个安全的微调 PRP 。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E5%AE%89%E5%85%A8%E7%9A%84%E5%BE%AE%E8%B0%83%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81.PNG" class title="安全的微调分组密码">
<h2 id="安全微调分组密码的例子"><a href="#安全微调分组密码的例子" class="headerlink" title="安全微调分组密码的例子"></a>安全微调分组密码的例子</h2><h3 id="例子1简单机制"><a href="#例子1：简单机制" class="headerlink" title="例子1：简单机制"></a>例子1：简单机制</h3><p>在这个例子中，我们假设密钥输入空间等于输入信息空间，这个 PRP 将 X×X 映射到 X 。</p>
<p>以 AES 为例，密钥空间 128 位，数据空间 128 位，输出空间也是 128 位，我们定义一个微调分组密码为有一个密钥、一个微调、待加密的输入数据，使用微调和主密钥，然后使用得到的随机密钥加密数据。如果我们想使用这个微调分组密码来加密 n 个分组，会要求 2n 次分组密码的计算，n 次用于加密给定的微调，另外 n 次用于加密给定的数据。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E4%BE%8B%E5%AD%901.PNG" class title="例子1">
<h3 id="例子2xts-机制"><a href="#例子2：XTS-机制" class="headerlink" title="例子2：XTS 机制"></a>例子2：XTS 机制</h3><p>XTS 机制起源于 Phil Rogaway 的 XEX 模式，如下工作：</p>
<p>假设给我一个常规的定义在 n 位分组上的分组密码（不是微调分组密码），我们来定义一个微调分组密码，这个微调分组密码取两个密钥作为输入，为了简便，我们假设这个微调空间由两个值组成 t 和 i ，t 是某个微调值，i 是某个索引，x 是 n 位字符串，我们将用微调分组密码加密 x 。</p>
<p>首先我们使用密钥 $k_2$ 加密微调 t 的左半部分，把加密结果记为 N ，接下来我们把信息 m 和某个密码本函数在 N 处的值进行异或，索引是 i ，这个密码本函数极快，可以忽略它的运行时间。接下来，我们使用密钥 $k_2$ 加密，然后再使用同样的密码本进行异或，得到密文 c 。</p>
<p>这个机制的好处在于，如果我们想加密 n 个分组，我们只需要计算 n+1 次，然后对索引 1，2，3，4，对每个分组，我们只需要计算 PRP E 一次。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/XTS%E6%9C%BA%E5%88%B6.PNG" class title="XTS机制">
<p><strong>真的有必要在用微调前加密它嘛？</strong>如下机制是否是一个安全的微调分组密码？</p>
<p>在这个机制中，这个微调被直接使用，作为密码本函数的输入，再异或。这不是一个安全的微调分组密码。</p>
<p>如果我们把数据设为 P(t,1)，然后把它和对应的微调进行异或，对应的微调也是 P(t,1)，所以我们得到的是 0 ，所以我们无论输出什么，我们的加密就是 0 ，我们记输出为 $c_0$ ，那么实际输出为 $c_0$⊕P(t,1) ，现在我们对 P(t,2) 做同样的事，我们会得到 $c_0$⊕P(t,2) ，两者进行异或，我们得到 P(t,1)⊕P(t,2)。这意味着，攻击者可以以这个微调和这个数据询问挑战者，如果等式成立，我们是在和一个伪随机函数交互，否则我们是在和一个真随机函数交互。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E4%B8%8D%E5%9C%A8%E5%BE%AE%E8%B0%83%E5%89%8D%E5%8A%A0%E5%AF%86%E7%9A%84%E4%BE%8B%E5%AD%90.PNG" class title="不在微调前加密的例子">
<p><strong>总结</strong>：XTS 用于硬盘加密，把扇区分为若干分组，每个分组 16 字节，分组1 使用微调 $t_1$ 加密，</p>
<p>分组2 使用微调 $t_2$ 加密，… ，每个分组都有自己的 PRP ，整个扇区使用一系列 PRP 被加密，这是一个分组级别的 PRP ，不是扇区级别的 PRP ，事实上，不是每个扇区都用它自己的 PRP 加密的，只是每个分组是用它自己的 PRP 加密的，扇区与分组之间的差别在某种意义上是人为的。实际上，这个 <strong>XTS 模式提供了扇区级的确定性的 CPA 安全的加密</strong>。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/XTS%E6%80%BB%E7%BB%93.PNG" class title="XTS总结">
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E6%80%BB%E7%BB%93.PNG" class title="总结">
<h1 id="format-preserving-encryption"><a href="#Format-preserving-encryption" class="headerlink" title="Format preserving encryption"></a>Format preserving encryption</h1><p>一般来说，信用卡号有 16 位数字，分成 4 组，每组 4 个数字，，前 6 个数字叫做 <strong>BIN 码</strong>，代表了发行方的 ID ，后面 9 位数字是账号，最后一位是校验和，由前 15 位计算得到。</p>
<p>假设我们想加密信用卡号，使得当用户在销售终端刷信用卡时，使用密钥 k 加密信用卡号，并始终保持加密直到银行需要，这些信用卡号经历了许多处理环节，它们都希望获得某些看起来像是信用卡号的信息。如果我们只想在端点加密，在另一端点解密，这并不容易，因为如果我们使用 AES 加密，即使我们使用的是确定的 AES ，加密后的信用卡号将是 128 位的分组，16 字节，将会从一个系统发送给下一个系统，直到它到达目的地，但是这些处理节点每个都必须改变，因为它们都希望获得信用卡号，所以，问题是我们能否在销售终端处加密，使得获得的加密本身看上去像是一个信用卡号，因此，这些中间系统都无需做出改变，只有端点需要改变。</p>
<p>通过这样做，我们实际上获得了端到端的加密，不需要改变太多的沿途的软件，如何构造这种机制，即所谓的<strong>保格式加密</strong>呢？我们的目标是：<strong>加密一个信用卡号能产生某些类似信用卡号的信息</strong>，加密的信用卡号应该看起来像一个正常的有效信用卡号。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E4%BF%9D%E6%A0%BC%E5%BC%8F%E5%8A%A0%E5%AF%86.PNG" class title="保格式加密">
<h2 id="保格式加密的构建"><a href="#保格式加密的构建" class="headerlink" title="保格式加密的构建"></a>保格式加密的构建</h2><p>我们试图在集合 {0，1，… ，s-1} 上构建一个伪随机置换，s 是任意的，对于信用卡号的集合来说，s 大约为 2^42 ，我们的目标是：<strong>构建一个从 0 到 s-1 的区间上的 PRP</strong> 。</p>
<p>我们已有某个 PRF ，这个 PRF 可以处理长得多的分组，某种意义上，我们试图压缩这个 PRF 的定义域，使之适应我们已有的数据，怎么办呢？</p>
<p>①取给定的信用卡号，我们加密它，使它能用从 0 到信用卡号总数之间的某个数来表示。</p>
<p>②应用 PRP ，加密这个信用卡号，使用确定性加密的 2 号机制。</p>
<p>③把最后的数映射到一个有效的信用卡号，然后发送。</p>
<p>这也是非扩展加密，我们目前最多只能使用 PRP 加密，这里的困难之处在于，我们需要一个 PRP 在这个看上去很有趣的集合上操作。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E4%BF%9D%E6%A0%BC%E5%BC%8F%E5%8A%A0%E5%AF%862.PNG" class title="保格式加密2">
<p><strong>机制的构建过程</strong>：</p>
<p>①压缩 PRF 的定义域，t 是最接近以 2 为底 s 的对数的值，即，$2^t$ 最接近 s ，这个机制使用 Luby-Rackoff 机制，我们需要一个 PRF F’ ，在长度为 t/2 的分组上操作，信用卡例子 s=42 ，一种方法是取 AES 分组密码，把它当成 128 位输入的 PRF ，然后截断输出，取低 21位。实际上有更好的截断 n 位 PRF 的方法，以生成 t 位 PRF 。姑且用第一种方法，现在，我们已经把 AES 分组密码转换成了一个 t/2 的 PRF ，但我们真正想要的是一个 PRP ，所以，我们只要把我们的新 PRF F’ 直接带入到 Luby-Rackoff 机制中，这是一个 Feistel 机制，将一个安全的 PRF 转换成一个安全的 PRP ，事实上，7 轮 Feistel 机制具有最好的误差参数。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E6%9C%BA%E5%88%B6%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B1.PNG" class title="机制的构建过程1">
<p>②取 {0,1}^t 里的值，映射到我们感兴趣的集合 {0,1,…,s-1} ，我们有这个 PRP 了，可以置换这个 t 位集合里的元素，我们想让这个 PRP 可以在更小的集合上工作。我们有输入 x，x 属于我们想要的集合 {0,1,…,s-1} ，接下来，一次次地迭代以下流程：首先，把 x 映射到某个临时变量 y ，现在加密输入 x ，把结果放在 y 里，如果 y 在我们的目标集合里，我们就停止迭代，输出 y ；如果不在，就继续迭代下去，直到 y 落在我们的目标集合里，输出 y 。很显然，这是可逆的，求逆时，我们只要解密，然后反方向逐次尝试，解密，再解密，直到落在集合 {0,1,…,s-1} 中，这就给了一个点地逆置换结果。我们平均需要迭代多少次才能知道过程收敛？2次。</p>
<img src="/2020/07/15/%E3%80%90DanBoneh%E3%80%91OddsAndEnds/%E6%9C%BA%E5%88%B6%E7%9A%84%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B2.PNG" class title="机制的构建过程2">
<p>第②步是紧的，即，没有附加的安全性开销，从 {0,1}^t 到 {0,1,…,s-1}，下图定理可以证明：如果给我两个集合 Y 和 X ，Y 包含于 X ，那么应用刚才看到的变换，从一个 X 到 X 的随机置换出发，得到一个 Y 到 Y 的随机置换，这意味着，如果我们从一个 X 上的真随机置换出发，最后会得到一个 Y 上的真随机置换。因此，我们开始时的置换与 X 上的随机置换不可区分。</p>
<p>第①步的分析与 Luby-Rackoff 的分析一致。</p>
<p><u>这里没有任何的密文完整性，没有任何随机性，我们能取得的最好结果是确定的 CPA 安全</u>。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】绪论</title>
    <url>/2020/03/23/%E3%80%90DanBoneh%E3%80%91%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<p><strong>TLS</strong>（安全传输层协议）：由两部分组成。第一部分为<strong>握手协议</strong>（Handshake），Alice与Bob互相交谈，在握手的最后，双方分享一个密钥，Alice与Bob都知道这个密钥，但攻击者不知道会话密钥K，运用了公钥密码技术。第二部分为<strong>记录协议</strong>（Record），双方共享密钥时，如何使用密钥加以保护通信数据。</p>
<p><strong>对称加密</strong>：以分组的形式保护流量的技术。在对称加密系统中，只有通信双方知道密钥K，他们使用<strong>加密算法 E</strong> 和<strong>解密算法 D</strong> 进行通信加密。加密算法以<u>原信息</u>和<u>密钥</u>为输入，产生<u>密文</u>；解密算法以<u>密文</u>和<u>密钥</u>为输入，输出<u>原信息</u>。<strong>算法是公开的，密钥是保密的</strong>。很多私有的算法一旦被逆向工程很容易破解。</p>
<p><strong>一次密钥</strong>（one time key）每个密钥只加密一个信息。</p>
<a id="more"></a>
<p><strong>WEP</strong>用来加密WiFi流量。</p>
<p>密码学的核心是安全通信，含有两个部分：<strong>安全的密钥建立</strong>、<strong>安全的通信</strong>。</p>
<p>现代密码学描述的每一个概念都依照非常严格的三步：</p>
<ol>
<li>当引入新的原型时，如数字签名，要准确描述模型的威胁是什么，如攻击者如何攻击数字签名、伪造签名的目的。</li>
<li>提出架构，证明攻击者在这个威胁模型下可以攻击这个架构。</li>
<li>攻击者可以用来解决根本性难题，如果问题很难，则证明攻击者无法在威胁模型下破解这个架构。</li>
</ol>
<p>eg：对于数字签名，我们定义数字签名不可伪造的意义，然后给出一个架构，假如有人能够破解这个架构，他也可以用他破解的方法来解决因子分解问题。</p>
<p><strong>凯撒密码</strong>：并不是密码，因为没有密钥，是一个固定替换的替换式密码，利用字母移位，<em>可轻易破解</em>。</p>
<p><strong>简单的替换式密码</strong>：密钥是一张字母映射替换表，替换表是随机选择的。假设有26个字母，密钥空间是 26！个，约为 2^88 ，意味着描述一个替换密钥需要88位，每个密钥以88位表示，但依然不安全，可以通过<strong>唯密文攻击</strong>仅凭密文就能还原密钥以及明文，首先可以使用<u>字母的频率</u> e&gt;t&gt;a 分析，其次，通过<u>字母配对的频率</u> he、an、in、th 等。所以，替换式密码<em>可轻易破解</em>。</p>
<p><strong>Vigener加密</strong>：密钥是一个单词，将密钥字母不断重复以覆盖整个明文信息，将密钥字母和信息字母相加，模 26 得到密文。解密时，将密文信息（不够则 +26 ）减去密钥。通过<strong>唯密文攻击</strong>破解，破解时，首先假设<u>密钥长度已知</u>为 6 ，将密文按照密钥长度分组，然后看每组的第一个字母，它们都被同一个字母加密，eg：假设第一个密钥字母为 C ，则密文分组第一个字母是明文移动 3 位。收集所有字母，最常见的字母很可能是 E 的加密结果，设想每隔 5 个字母最常见的是 M ，我们知道 E 加上第一个密钥字母等于 M ，则 M-E=H，得出 H 为第一个密钥字母。同理，看每个密文分组的第二个字母，重复操作，找出最常见字母，它很可能是 E 的加密结果，减去 E 就是密钥的第二个字母，可以还原整个密钥。<u>密钥长度未知</u>的情况下，先假定密钥长度是 1 ，然后假定长度是 2 、是 3 等等，再运行解密过程，知道了密钥长度和密钥信息，直到得到一个说得通的明文信息。</p>
<p><strong>单个轴轮机</strong>：密钥在碟片里，每按一次打字机，碟片转一个刻痕，实际上是一个<u>替换表的编码</u>，如图所示，连续按下 C 三次，三次输出均不同，依次为 T、S、K。通过<strong>唯密文攻击</strong>破解，分析<u>字母频率</u>、<u>配对频率</u>、<u>三合字母频率</u>。</p>
<img src="/2020/03/23/%E3%80%90DanBoneh%E3%80%91%E7%BB%AA%E8%AE%BA/%E8%BD%B4%E8%BD%AE%E6%9C%BA.PNG" class title="轴轮机">
<p><strong>Enigma机</strong>：是一种复杂的轴轮机，使用了3、4或5个轴轮。密钥是轴轮的初始设定，打字时，轴轮以不同速率旋转输出密文，4 个轴有 26^4 个不同的密钥，约 2^18，密钥空间较小。可通过<strong>唯密文攻击</strong>破解。</p>
<p><strong>DES</strong>：一种将 64 比特的明文加密成 64 比特的密文的对称密码算法，密钥长度为 56 比特，每隔 7 比特会设置一个用于错误检查比特，密钥空间为 2^56 ，一次加密 64 位（8个字母），密钥空间很小，可以使用<strong>暴力破解</strong>，新项目中不能继续使用。</p>
<p><strong>AES</strong>：分组长度固定，使用 128 位密钥，密钥长度 128、192、256 比特。</p>
<img src="/2020/03/23/%E3%80%90DanBoneh%E3%80%91%E7%BB%AA%E8%AE%BA/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%8701.JPG" class title="离散概率01">
<img src="/2020/03/23/%E3%80%90DanBoneh%E3%80%91%E7%BB%AA%E8%AE%BA/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%8702.JPG" class title="离散概率02">]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Stream Ciphers</title>
    <url>/2020/03/24/%E3%80%90DanBoneh%E3%80%91StreamCiphers/</url>
    <content><![CDATA[<p>在流密码中，密钥不是完全随机的，而是一种<u>伪随机密钥</u>。</p>
<p><strong>伪随机数发生器</strong>（PRG）：是一个<u>本身没有随机性</u>的<u>完全确定</u>的<u>函数 G</u> ，取一个种子为输入（<u>种子具有随机性</u>），用 {0,1}^s 表示所有长度为 s 的字符串，{0,1}^s 叫做<u>种子空间</u>，将 s 位种子映射到一个长得多的字符串 {0,1}ⁿ ，<code>G：{0,1}^s→{0,1}ⁿ，n&gt;&gt;s</code>。种子可能只有128位，但能扩展成一个长得多的字符串。</p>
<p>以<u>种子</u>为私钥 k ，使用<u>发生器</u>将种子扩张成长得多看起来随机的<u>伪随机序列</u> G(k) ，将伪随机序列和明文异或，得到密文。<code>c = E(K,m) = m⊕G(k)</code>；<code>m = D(K,c) = c⊕G(k)</code>。</p>
<p>流密码是安全的，安全性依赖于使用的发生器，但其密钥比明文短得多，不是完美安全的。</p>
<a id="more"></a>
<p><strong>不可预测性</strong>：对于各个位置，即对所有 i ，没有有效的破解算法 A ，以不可忽略的概率预测出第 i+1 位。</p>
<p>安全的发生器必须具有<strong>不可预测性</strong>，即不能由前面的部分预测出后面的部分。如：拿到密文，而明文的前半部分已知，可以异或出伪随机序列的前半部分，如果伪随机序列可预测，就可以预测出完整的伪随机序列，从而密文完全破解，还原整个明文。</p>
<p><strong>线性同余法</strong>：将当前伪随机数的数值乘以 A 再加上 C ，然后将除以 M 得到的余数作为下一个随机数，A 和 C 是整数，M 是质数，迭代执行 <code>$R_0$ = (A × 种子 + C) mod M</code>，输出后一位。线性同余法<u>不具备不可预测性</u>，不能用于密码技术。</p>
<h5 id="对一次性密码本的攻击"><a href="#对一次性密码本的攻击" class="headerlink" title="对一次性密码本的攻击"></a>对一次性密码本的攻击</h5><p><strong>两次密码本攻击</strong>：如果同样的密码本为不同的明文加密，就不再安全。</p>
<p>$C_1$ ← $m_1$⊕PRG(k)</p>
<p>$C_2$ ← $m_2$⊕PRG(k)</p>
<p>攻击者截获 $C_1$ 和 $C_2$ 可以得出 $m_1$⊕$m_2$ ，由于英语有足够的冗余，如果给定两明文的异或，是可以还原出两个明文的。因此，<u>流密钥不能被重复使用</u>。</p>
<p><strong>利用可修改性攻击</strong>：一次性密码本和流密钥不提供完整性保护。攻击者截获密文 m⊕k ，将密文和一特定值 p （子置换密钥）异或得到 (m⊕k⊕p)⊕k ，解密后得到 m⊕p ，成功对明文造成特定影响，而对密文的修改不会被检测出来。</p>
<h5 id="几种流密码"><a href="#几种流密码" class="headerlink" title="几种流密码"></a>几种流密码</h5><p><strong>RC4</strong>（面向软件）：种子大小可变，被用作流密码的密钥。将 128 位密钥扩展成 2048 位，执行一个简单的循环，每轮输出一个字节。</p>
<p>Google在 HTTPS 中使用RC4。</p>
<p>RC4已被伪随机数发生器取代。</p>
<p>RC4弱点：</p>
<ol>
<li>第二个字节等于 0 的概率为 2/256 ，而不是 1/256 ，加密时，第二个字节可能不会被加密。此外，第一个和第三个字节也是不均匀的。</li>
<li>观察一段很长的输出，出现序列 00 的可能性更大。</li>
<li>密钥关联攻击。</li>
</ol>
<p><strong>CSS</strong>（面向硬件）：已被完全破解，用于加密DVD电影。CSS是基于线性反馈移位寄存器（LFSR）的。</p>
<p>CSS密钥是 5 个字节，40 位。（seed = 5 bytes = 40 bits）</p>
<p>CSS使用 2 个LFSR，一个 17 位（1联结上前2个字节），一个 25 位（1联结上后3个字节）。</p>
<p><strong>eStream</strong>：</p>
<p>PRG：{0,1}^s × R →{0,1}ⁿ，n&gt;&gt;s，{0,1}^s 为seed，R 为新鲜值（只要密钥定下来，永不重复的值）。</p>
<p><code>E(k, m; r) = m⊕PRG(k; r)</code>。(k; r) 这个有序对永不重复，不被多次使用，底线是可以重复使用密钥，新鲜值确保了有序对唯一。</p>
<img src="/2020/03/24/%E3%80%90DanBoneh%E3%80%91StreamCiphers/PRG.PNG" class title="PRG">
<img src="/2020/03/24/%E3%80%90DanBoneh%E3%80%91StreamCiphers/%E7%BB%9F%E8%AE%A1%E6%B5%8B%E8%AF%95.JPG" class title="统计测试">
<p>一个生成器是安全的，不仅特定的统计测试认为它的输出是随机的，事实上，对于所有<u>有效</u>（测试算法总在有限步内终止并返回结果）的统计测试，都认为输出是随机的。</p>
<p><strong>完美安全</strong>：</p>
<p>对于任意等长的消息m，只要这个m属于消息空间（就是说用这个加密算法可以加密m），那么用加密密钥k加密后，加密结果“看起来都一样”，没法看出来这是从m，还是从其他什么消息加密得来的。</p>
<img src="/2020/03/24/%E3%80%90DanBoneh%E3%80%91StreamCiphers/%E5%AE%8C%E7%BE%8E%E5%AE%89%E5%85%A8.jpg" class title="完美安全">
<p><strong>语义安全</strong>：</p>
<p>计算机在多项式复杂度内看加密结果，觉得“看起来都一样”。</p>
<img src="/2020/03/24/%E3%80%90DanBoneh%E3%80%91StreamCiphers/%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A8.jpg" class title="语义安全">
<p><a href="https://www.zhihu.com/question/37203836" target="_blank" rel="noopener">可参考链接</a></p>
<p><u>安全的PRG是语义安全的</u>。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】Using Block Ciphers</title>
    <url>/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/</url>
    <content><![CDATA[<p><strong>电子密码本</strong>（ECB）不是语义安全的，永远不应被用来加密长于一个分组的信息。</p>
<img src="/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/ECB.PNG" class title="ECB">
<a id="more"></a>
<p>在确定的计数器模式下，由分组密码构建一个流密码。</p>
<img src="/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/PRF%E6%9E%84%E9%80%A0%E7%9A%84%E6%B5%81%E5%AF%86%E7%A0%81.PNG" class title="PRF构造的流密码">
<p>同一个密钥加密多个信息，允许攻击者实施<strong>选择明文攻击</strong>（<strong>CPA</strong>，即攻击者可任选一条信息交给Alice加密，然后给攻击者相应的密文。）目标是破解语义安全。</p>
<p>确定的加密机制不可能是 CPA 安全的。</p>
<p>用同一个密钥加密两段相同的明文，最好产生两段不同的密文，可以通过<u>随机加密</u>（在加密过程中，选择一些随机的字符串进行加密）和<u>基于新鲜值的加密</u>（构造对选择明文攻击安全的加密机制）来解决。</p>
<p><strong>密码分组链接模式</strong>（CBC）：使用一个分组密码，以实现对选择明文攻击是安全的。首先选择一个随机的<u>初始向量 IV</u> （ IV 必须不可预测，其大小就是分组密码的一个分组大小，IV就是一个分组密码），IV 和第一个明文分组进行异或，得到的结果使用分组密码进行加密，输出第一个分组的密文。以此类推，将第二个明文分组与第一个密文分组进行异或，再加密，得到第二个分组的密文。最后的密文是选择的 IV 以及所有的密文分组。</p>
<img src="/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/CBC.PNG" class title="CBC">
<img src="/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/CBC%E8%A7%A3%E5%AF%86.PNG" class title="CBC解密">
<p>无法对单独的一个中间明文分组加密。解密时，若一个密文分组受损，只要长度不变化，只会影响 2 个明文分组，若长度变化，分组错位，则无法解密。</p>
<p>带 IV （IV不可预测）的 CBC 模式对选择明文攻击是语义安全的。</p>
<p><strong>基于新鲜值的CBC加密</strong>：IV 被某个<u>不随机</u>但<u>唯一</u>的新鲜值取代。在这个模式中，要使用两个独立的密钥 k 和 $k_1$ ，k 用来加密单独的明文分组， $k_1$ 用来加密新鲜值。在CBC链接使用新鲜值前需要使用  $k_1$ 加密新鲜值，没有的话就不是 CPA 安全的。</p>
<img src="/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/CBC.PNG" class="nonce-based" title="nonce-based CBC">
<p>当加密的明文长度不是分组密码的分组长度的倍数时，需要在最后一个分组后面进行补齐，解密者会将其移除。如果不需要补齐，为避免出错，最后还是需要加一个没用的分组，解密者根据信息内容会将其移除。</p>
<p><strong>随机计数器模式</strong>（CTR）：使用安全的 PRF ，不使用分组密码。是一种通过逐次累加的计数器进行加密来生成密钥流的流密码，能以任意顺序处理分组，实现<u>并行</u>计算。IV 被包含在密文里，密文要比明文稍微长一点。</p>
<img src="/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/CTR.PNG" class title="CTR">
<p><strong>CTR与CBC的比较</strong></p>
<ol>
<li>CBC 必须使用分组密码，解密过程时逆向的运行分组密码，CTR 只使用正向的加密功能。</li>
<li>CBC 串行，CTR 可并行。</li>
<li>CTR 的安全上界、误差项比 CBC 好。</li>
<li>CBC 需要加一个假的补齐分组，有一个 CBC 变种叫做 CBC 密文偷窃可以用来避免产生假的分组。</li>
<li>基于新鲜值的模式下，新鲜值需要被扩展成 16 字节的分组才能加密，CBC 模式的密文比原来扩展了 16 倍；CTR 模式可以加密一字节的信息，通过与 CTR 模式产生的流的第一个字节进行异或，产生的每个密文都是一个字节的，无需扩张，和明文一样。</li>
</ol>
<img src="/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/CTRvsCBC.PNG" class title="CTRvsCBC">]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【DanBoneh】基于陷门置换的公钥加密</title>
    <url>/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="公钥加密系统"><a href="#公钥加密系统" class="headerlink" title="公钥加密系统"></a>公钥加密系统</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>公钥加密机制的应用：会话建立、密钥交换等。</p>
<a id="more"></a>
<p><a href="https://lemongx.github.io/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/" target="_blank" rel="noopener">相关链接</a></p>
<p><strong>仅对窃听攻击安全的密钥交换协议的工作过程</strong>：Alice 会产生一个公钥、私钥对，把公钥发给 Bob ，Bob 产生一个随机 x ，x 被作为共享密钥，Bob 将 x 使用 Alice 的公钥加密后发送给 Alice ，Alice 解密还原 x 。他们可以使用共享密钥 x 进行通信。攻击者只能看到公钥和使用公钥加密后的 x ，根据这些他不应该能获得任何关于 x 的信息。</p>
<p>我们将更加精确的定义不能学到任何关于 x 的信息是什么意思。</p>
<h2 id="对抗窃听的安全性"><a href="#对抗窃听的安全性" class="headerlink" title="对抗窃听的安全性"></a>对抗窃听的安全性</h2><p>见 <a href="https://lemongx.github.io/2020/07/19/%E3%80%90DanBoneh%E3%80%91BasicKeyExchange/" target="_blank" rel="noopener">《4.2 公钥加密系统的安全游戏》</a></p>
<p>当讨论<strong>对称密码</strong>的窃听攻击时，我们区分了两种情况，①密钥只使用一次，②密钥使用多次。</p>
<p>对于<strong>公钥加密</strong>，如果系统的一次性密钥是安全的，那么它对多次密钥也是安全的。我们不必赋予攻击者请求加密他选择的明文的能力，因为他可以自己创建这些加密。公钥私钥对 天生就是用来加密多个信息的。</p>
<h2 id="对抗主动攻击的安全性"><a href="#对抗主动攻击的安全性" class="headerlink" title="对抗主动攻击的安全性"></a>对抗主动攻击的安全性</h2><p>看一个电子邮件的例子，Bob 想发送邮件给他的朋友 Caroline ，Caroline 正好在 Gmail 上有账号，过程如下：这份加密的邮件发送给 Gmail 服务器，Gmail 服务器解密邮件查看接收方，如果接收方是 Caroline ，它会把这份邮件转发给 Caroline ，如果接收方是攻击者，它会把邮件转发给攻击者。</p>
<p>假设 Bob 加密了邮件，使用的系统允许攻击者篡改密文，且不会被检测到。想象这份邮件是使用计数器模式加密的，当攻击者截获了这个邮件，他可以改变接收方，使得接收方变成 attacker ，对于计数器模式这是非常容易做到的，攻击者知道邮件是发往 Caroline 的，他只对邮件内容感兴趣，所以他可以修改接收方，这样当服务器接收到邮件时，他会解密，看到接收方是攻击者，就把邮件转发给了攻击者。这是一个经典的主动攻击的例子，注意，攻击者只能解密接收方是攻击者的邮件。</p>
<p>我们的目标是设计安全的公钥系统，即使攻击者可以篡改密文，还可以解密特定的密文。攻击者的目标是获得明文内容。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E7%BB%8F%E5%85%B8%E7%9A%84%E4%B8%BB%E5%8A%A8%E6%94%BB%E5%87%BB.PNG" class title="经典的主动攻击">
<h2 id="选择密文安全"><a href="#选择密文安全" class="headerlink" title="选择密文安全"></a>选择密文安全</h2><p>事实上，这是公钥加密的标准安全性观念。</p>
<p>我们有一个加密机制 (G,E,D) ，我们定义在明文空间和密文空间 (M,C) 上，定义两个实验，实验0 和 实验1 ，b 表示挑战者是实现 实验0 或是 实验1 。</p>
<p>挑战者开始时生成一对公钥和私钥，然后把公钥给攻击者，现在攻击者可以请求解密很多密文，攻击者提交密文 $c_1$ ，获得了密文 $c_1$ 的解密 $m_1$ ，攻击者可以一次次这么做，然后说游戏结束。现在，他提交两个等长度的明文 $m_0$ 和 $m_1$ ，他会收到<u>挑战密文 c</u> ，也就是 $m_0$ 或 $m_1$ 的加密，现在攻击者可以继续提交这些密文询问，他可以继续请求解密，那么他提交了一个密文并获得了该密文的解密。</p>
<p>注意，如果攻击者可以提交他选择的任意密文，那么他可以破解这个挑战，他只需提交挑战密文 c 作为解密请求，然后他被告知他在挑战阶段获得的是 $m_0$ 还是 $m_1$ 的加密结果，因为我们有这么一个限制，攻击者可以提交任何他选择的密文，<strong>除了挑战密文</strong>，那么攻击者可以询问他选择的任何密文的解密，除了挑战密文。即使攻击者有所有这些的解密，他依然不能分辨出他得到的是 $m_0$ 还是 $m_1$ 的加密。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E5%AE%89%E5%85%A8%E6%B8%B8%E6%88%8F.PNG" class title="选择密文安全游戏">
<p>通常，攻击者无法判断密文来自 $m_0$ 还是 $m_1$ ，我们说这个选择密文 CCA 安全的。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/CCA%E5%AE%89%E5%85%A8.PNG" class title="CCA安全">
<h2 id="选择密文安全的攻击方法"><a href="#选择密文安全的攻击方法" class="headerlink" title="选择密文安全的攻击方法"></a>选择密文安全的攻击方法</h2><p>假设使用的加密系统满足 给定信息的加密，攻击者可以改变接收方，那么我们可以这样赢得游戏。</p>
<p>①攻击者得到了公钥，发出两个等长度的明文，第一个明文内容是 0 ，第二个明文内容是 1 ，两个明文都给 Alice ，Alice 回复后，攻击者会得到挑战密文 c 。</p>
<p>②攻击者修改接收方，返回给 Alice 一个密文 c’ ，c’ 是 ”给 Charlie 的明文，挑战密文的内容 b“ 的加密结果，现在因为明文不同，我们知道密文也不同，c’ 一定和挑战密文 c 不一样，根据 CCA 游戏的定义，挑战者必须解密任何不同于挑战密文的密文，挑战者解密后给攻击者解密结果 m’ ，他给了攻击者 b ，攻击者可以输出挑战结果 b ，他以优势 1 赢得了游戏。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E5%AE%89%E5%85%A8%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95.PNG" class title="选择密文安全的攻击方法">
<h1 id="公钥加密的构建"><a href="#公钥加密的构建" class="headerlink" title="公钥加密的构建"></a>公钥加密的构建</h1><h2 id="陷门函数-tdf"><a href="#陷门函数-TDF" class="headerlink" title="陷门函数 TDF"></a>陷门函数 TDF</h2><p>陷门函数是一个函数，从集合 X 映射到集合 Y ，它定义为三个算法：一个通用的算法 G ，函数 F ，函数 F 的逆。</p>
<p>通用算法 G 运行时，会生成一对密钥，一个公钥和一个私钥。公钥定义了一个从集合 X 映射到集合 Y 的特定函数，私钥定义了这个函数的逆，从集合 Y 映射到集合 X 。</p>
<p>这里的想法是，你可以使用公钥 pk 计算这个函数再任意点的值，你可以使用私钥 sk 来计算函数的逆。<strong>逆是什么意思？</strong>如果我们看这个密钥生成算法 G 生成的公钥、私钥对，如果计算函数在点 x 的值，然后计算所得点的逆，应该获得原点 x 。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E9%99%B7%E9%97%A8%E5%87%BD%E6%95%B0.PNG" class title="陷门函数">
<h2 id="安全的陷门函数-tdfs"><a href="#安全的陷门函数-TDFs" class="headerlink" title="安全的陷门函数 TDFs"></a>安全的陷门函数 TDFs</h2><p><strong>如果这个函数 F(pk,·) 是所谓的单向函数，我们说这个三元组 (G,F,$F^{-1}$) 是安全的。</strong></p>
<p>单向函数的想法是，这个函数可以在任一点计算，但如果没有私钥 sk 的话，求它的逆是困难的。通常使用如下游戏定义：</p>
<p>挑战者生成一个公钥和私钥，生成一个随机 x ，挑战者把公钥发给攻击者，挑战者会计算函数在点 x 的值，然后把所得结果 y 也发给攻击者。攻击者看到一个公钥，定义了这个函数是什么，然后攻击者看到这个函数在一个随机点 x 处的像，他的目标是求这个函数在点 y 的逆，他输出某个 x’ 。</p>
<p>如果攻击者求出在点 y 的逆的概率是可忽略的，这个陷门函数是安全的。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%AE%89%E5%85%A8%E7%9A%84%E9%99%B7%E9%97%A8%E5%87%BD%E6%95%B0.PNG" class title="安全的陷门函数">
<h2 id="使用-tdfs-构建公钥加密系统"><a href="#使用-TDFs-构建公钥加密系统" class="headerlink" title="使用 TDFs 构建公钥加密系统"></a>使用 TDFs 构建公钥加密系统</h2><p>构建公钥加密系统如下需要三个原件：</p>
<p>我们有①<u>陷门函数</u> (G,F,$F^{-1}$) ，我们需要的另一个工具是一个②<u>对称加密机制</u>，我们假设这个加密机制对主动攻击是安全的，特别地，我需要提供认证加密。</p>
<p>注意！对称加密系统取 K 中的密钥，陷门函数取 X 中的元素为输入。这是两个不同的集合，所以我们需要③<u>哈希函数</u>从 X 映射到 K ，换句话说，它把集合 X 中的元素映射成密钥用于对称加密系统。</p>
<p>公钥加密系统的密钥生成 与 陷门函数的密钥生成 是完全一样的。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%89%E4%B8%AA%E5%8E%9F%E4%BB%B6.PNG" class title="公钥加密系统的三个原件">
<h3 id="公钥加密系统工作过程"><a href="#公钥加密系统工作过程" class="headerlink" title="公钥加密系统工作过程"></a>公钥加密系统工作过程</h3><p><strong>加密工作流程</strong>：</p>
<p>①加密算法取一个公钥和明文为输入，它会生成一个集合 X 里的随机元素 x ；</p>
<p>②然后它会对随机元素 x 应用这个陷门函数，获得 y ，y 是 x 在陷门函数下的像；</p>
<p>③然后它会通过取 x 的哈希值，生成一个对称密钥，这是对称加密系统的对称密钥；</p>
<p>④最终它使用刚刚生成的密钥加密明文 m ，然后输出刚刚计算得到的值 y 与 m 在对称密码下的加密结果 c 。</p>
<p><strong>注意</strong>：<strong>陷门函数只用于随机值 x ，而信息本身是用对称密钥系统由 x 推出的密钥加密的</strong>。</p>
<p><strong>解密工作流程</strong>：</p>
<p>①解密算法取私钥和密文作为输入，密文本身包含两个部分，值 y 和 c ，首先应用陷门函数的逆变换，逆向陷门函数作用于值 y 返回 x ；</p>
<p>②对 x 取哈希值得到与加密时得到的一样的密钥 k ；</p>
<p>③应用对称解密算法解密密文 c ，获得最初明文 m 。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.PNG" class title="公钥加密系统工作过程">
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%9B%BE%E7%A4%BA%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.PNG" class title="图示工作流程">
<h3 id="安全性定理"><a href="#安全性定理" class="headerlink" title="安全性定理"></a>安全性定理</h3><p>①如果开始的陷门函数是安全的，换句话说，这是个<u>单向函数</u>；②如果攻击者没有私钥的话，对称加密系统提供了<u>认证加密</u>；③哈希函数是一个<u>随机神谕</u>，即是个从集合 X 映射到密钥空间 K 的随机函数。在这三个条件下，系统是<u>选择密文安全</u>的，即 $CCA^{ro}$ 安全，ro 表示这个安全性是建立在所谓的随机神谕模型上的。</p>
<p><strong>如果陷门函数是安全的，那么对称加密系统是安全的，能抵抗篡改，提供了认证加密。</strong></p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E7%90%86.PNG" class title="安全性定理">
<h2 id="错误使用-tdf-构建的公钥加密系统"><a href="#错误使用-TDF-构建的公钥加密系统" class="headerlink" title="错误使用 TDF 构建的公钥加密系统"></a>错误使用 TDF 构建的公钥加密系统</h2><p><strong>为什么不要用陷门函数来加密？</strong></p>
<p>我们首先能想到的是直接对明文 m 使用陷门函数，我们使用陷门函数加密明文 m ，然后使用陷门函数的逆函数解密密文 c ，以还原明文 m 。</p>
<p>事实上，解密是加密的逆过程，这是完全不安全的。最简单的方法证明它不安全，在于这是一个确定的加密，在这里没有随机性被使用到，当我们加密一个明文 m ，由于算法是确定的，它不可能是语义安全的。当我们将这个陷门函数具象化，使用特定的实现，例如 RSA 陷门函数，那么这种机制会有很多可能的攻击。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8TDF%E6%9E%84%E5%BB%BA%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F.PNG" class title="错误使用TDF构建的公钥加密系统">
<h1 id="陷门置换-rsa-的构建"><a href="#陷门置换-RSA-的构建" class="headerlink" title="陷门置换 RSA 的构建"></a>陷门置换 RSA 的构建</h1><h2 id="数论回顾"><a href="#数论回顾" class="headerlink" title="数论回顾"></a>数论回顾</h2><img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E6%95%B0%E8%AE%BA%E5%9B%9E%E9%A1%BE.PNG" class title="数论回顾">
<p>详见 <a href="https://lemongx.github.io/2020/07/23/%E3%80%90DanBoneh%E3%80%91NumberTheory/" target="_blank" rel="noopener">《Number Theory》</a></p>
<h2 id="rsa-陷门置换"><a href="#RSA-陷门置换" class="headerlink" title="RSA 陷门置换"></a>RSA 陷门置换</h2><p>SSL 和 TLS 都使用了 RSA ，用于证书和密钥交换；有很多安全的电子邮件系统和安全的文件系统，使用了 RSA 加密电子邮件和文件系统里的文件。</p>
<p>RSA 是一个陷门置换，本身不是一个加密系统，只是一个函数。</p>
<p>密钥生成算法函数 f 和 逆函数 $f^{-1}$ </p>
<p><strong>密钥生成算法工作流程</strong>：</p>
<p>①我们生成两个质数 p 和 q ，每个大约是 1000 位，约 300 十进制位，然后 RSA 模就是这两个质数的乘积。</p>
<p>②接下来我们选取两个指数 e 和 d ，满足 e·d = 1 (mod φ(N)) ，这意味着 e 和 d 首先必须与 φ(N) 互质，其次，他们必须互为模 φ(N) 的逆。</p>
<p>③输出公钥为 (N,e) ，私钥为 (N,d) 。这个指数 e 有时被称为<u>加密指数</u>，指数 d 有时被叫做<u>解密指数</u>。</p>
<p>RSA 函数本身的定义是很简单的，为求简便，把它定义成从 Z_N^<em> 到 Z_N^</em> 的函数，这个函数有输入 x ，我们只需取 x ，计算 $Z_N$ 中 $x^e$ 。</p>
<p>解密时，我们只需给定输入 y ，计算 $y^d$ 模 N 就行了。假设 y 本身正好是 RSA 函数在某个值 x 处的值，这时，$y^d$ 就是 $RSA(x)^d$ ，而 x 本身 $x^e$ mod N ，因此，$y^d$ 就是 $x^{ed}$ mod N ，由于 e·d = 1 (mod φ(N)) ，这意味着存在某个整数 k 满足 ed = kφ(N)+1 ，根据欧拉定理，$x^{φ(N)}$ = 1 ，得出最后结果 x ，这意味着 d 次方就是 RSA 的逆。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/RSA%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2.PNG" class title="RSA陷门置换">
<p><strong>为什么这个函数是安全的？</strong>即，为什么在没有私钥的条件下这个函数是单向的？</p>
<p>RSA 假设告诉我们给定公钥，RSA 函数是一个单向置换，因此，它是一个陷门置换，因为它有陷门，<u>陷门指的是私钥里的 d</u> ，这个陷门使得所有知道陷门的人，可以很容易的求逆。</p>
<p>形式化地，我们说对所有有效的算法 A ，如果我生成两个随机的质数 p 和 q ，把它们乘起来，获得模 N ，然后随机选择一个 $Z_N^<em>$ 中的 y ，指数 e 由公钥指定，可以得到 RSA 在点 y 的逆的概率 $y^{1/e}$ ，这个概率是可忽略的，这个假设叫做 <em>*RSA 假设</em></em>。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/RSA%E5%81%87%E8%AE%BE.PNG" class title="RSA假设">
<h2 id="公钥加密系统"><a href="#公钥加密系统-1" class="headerlink" title="公钥加密系统"></a>公钥加密系统</h2><p>将 RSA 陷门置换带入 ISO 标准机制，这个机制是基于一个必须提供认证加密的对称加密系统的，还是基于一个哈希函数的，从 RSA 的角度看，这个哈希函数把 $Z_N$ 里的元素映射到对称密钥系统的密钥，<strong>加密机制的工作方式</strong>如下：</p>
<p>算法 G 运行 RSA 的密钥生成算法，产生一个公钥和一个私钥，这个公钥包含了加密指数，私钥包含了解密指数。</p>
<p><strong>加密过程</strong>如下：</p>
<p>①随机选择一个 $Z_N$ 中的元素 x ；</p>
<p>②对 x 应用 RSA 函数；通过对 x 取哈希先推导出一个对称密钥 k ，在实际中，这个哈希函数 H 使用 SHA-256 实现；</p>
<p>③输出 y 和使用密钥 k 加密后的信息。</p>
<p><strong>解密过程</strong>：首先使用密钥来求密文开头的逆，即 y 的 RSA 逆，这回给我们值 x ，我们对 x 应用哈希函数得到密钥 k ，运行解密算法得到明文。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E7%B3%BB%E7%BB%9F.PNG" class title="公钥加密系统">
<h2 id="对教科书-rsa-的攻击例子"><a href="#对教科书-RSA-的攻击例子" class="headerlink" title="对教科书 RSA 的攻击例子"></a>对教科书 RSA 的攻击例子</h2><p>如果试图使用教科书 RSA ，换句话说，如果试图<u>直接使用 RSA 来加密一个明文</u>，会受到攻击。</p>
<p>设想我们有一个网页服务器，这个服务器有 RSA 私钥 (N,d) ，网页浏览器试图与网页服务器建立起一个安全的 SSL 会话，那么 SSL 的工作方式是：</p>
<p>①网页浏览器开始时发送这个客户端 hello 消息，我想和你建立一个安全会话；</p>
<p>②网页服务器回复一个服务端 hello 消息，其中包含了服务器的公钥；</p>
<p>③网页浏览器生成一个随机数，这个随机数叫做<strong>预备主密钥 k</strong> ，把结果以密文形式发送给网页服务器，服务器会解密获得 k 。</p>
<p>现在，双方都有了共享密钥，他们可以使用它来安全会话。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/SSL%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F.PNG" class title="SSL的工作方式">
<p>如果我们直接使用 RSA 函数加密 k 会发生什么错误？换句话说，如果 k 直接加密成 $k^e$ mod N 的话，为了论证方便，我们假设 k 是一个 64 位密钥，我们把 k 当作范围从 0 到 $2^{64}$ 的一个整数，现在我们做如下事情：</p>
<p>①首先，假设 k 正好能分解成几个差不多大小的数的乘积，我们可以把 k 写成 $k_1$ 乘 $k_2$ ，$k_1$ 和 $k_2$ 是整数，比如说，两个都小于 $2^{34}$ ，那么实际上，k 可以被写成这样，有 20% 的概率会发生。但现在如果我们把这个 k=$k_1$ × $k_2$ 带入到定义密文的函数 c=$k^e$ in $Z_N$ 中，把 k 替换成 $k_1$ × $k_2$ ，我们会得到方程 c / ${k1}^e$ = ${k2}^e$ in $Z_N$ ，在这个方程中有两个变量 $k_1$ 和 $k_2$ ，我们把它们放在方程的两边，攻击者知道 c 、e 、N ，现在可以进行<strong>中间相遇攻击</strong>了。</p>
<p>②我们构建一张表，里边存放左边  c / ${k1}^e$ 的所有可能值，有 $2^{34}$ 个，然后对右边  ${k2}^e$ 所有的可能值，我们检查这个值是都在我们构建的表里，如果在，我们就找到了一个碰撞，我们就有了这个方程的一个解。一旦我们找到了一个元素具有形式  ${k2}^e$ 在我们构建的表里面，我们就已经解决了这个方程，并找到了 $k_1$ 和 $k_2$ ，一旦找到了 $k_1$ 和 $k_2$ ，我们可以很容易的还原 k ，k=$k_1$ × $k_2$ ，我们就破解了这个加密系统。暴力的搜索，我们可以在 $2^{64}$ 的时间里破解它。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB.PNG" class title="中间相遇攻击">
<p><strong>永远不要直接用 RSA 去加密。</strong>必须通过一个加密机制来使用它，比如 ISO 的标准。</p>
<h1 id="公钥密码学一号标准-pkcs1"><a href="#公钥密码学一号标准-PKCS1" class="headerlink" title="公钥密码学一号标准 PKCS1"></a>公钥密码学一号标准 PKCS1</h1><p>在应用 RSA 函数前，必须对明文做些处理。ISO 的标准，我们生成了一个随机 x ，用 RSA 加密 x ，然后从这个 x 推出一个对称加密密钥，不过这不是 RSA 在实际中的应用。</p>
<p>在实际中，系统生成一个对称加密密钥，然后让 RSA 去加密这个给定的对称加密密钥，而不是生成加密密钥。在实际中，RSA系统有一个输入的对称密钥需要加密，例如，可能是一个 AES 密钥，128 位，然后这个密钥被加密，首先我们取这 128 位，把它扩展成整个模的大小，例如这个模是 2048 位，然后应用 RSA 函数。<strong>这是怎样预处理的？如何论证得到的系统是安全的呢？</strong>这在实际中是广泛应用的，即 PKCS1 1.5 。</p>
<h2 id="pkcs1-v15"><a href="#PKCS1-v1-5" class="headerlink" title="PKCS1 v1.5"></a>PKCS1 v1.5</h2><p><u>PKCS1 模式 2 表示加密，模式 1 表示签名</u>。</p>
<p><strong>PKCS1 加密工作过程</strong>：</p>
<p>取明文，比如这里是 128 位 AES 密钥，把它放在你要产生的值的最低 128 位，接下来在它前面附上 16 个 1 ，即十六进制的 FF ，接下来把它附在这个随机密码本的后面，这个密码本中任何地方都不含 FF ，最后在结果的最高位放上数 02 ，意味着这个明文已经被 PKCS1 模式 2 编码了。这整个值就是 2048 位的字符串，作为 RSA 函数的输入，去计算它的 e 次方模 N ，得到的就是 PKCS1 的密文。</p>
<p><strong>PKCS1 解密工作过程</strong>：</p>
<p>解密者要求 RSA 函数的逆，还原这个分组，他会看最高位，发现是 02 ，意味着这是 PKCS1 格式的，他会移除这些 02 ，移除所有的这些随机密码本，直到遇见 FF ，剩下的就是最初明文，然后用这个明文来解密密文的内容。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/PKCS1.PNG" class title="PKCS1">
<h2 id="针对-pkcs1-v15-的攻击"><a href="#针对-PKCS1-v1-5-的攻击" class="headerlink" title="针对 PKCS1 v1.5 的攻击"></a>针对 PKCS1 v1.5 的攻击</h2><p>在没有安全性证明的情况下，实际上系统会被破解，这里有一个非常优雅的攻击，由 Bleichenbacher 在 1998 年提出。</p>
<p>当 PKCS1 被使用在 HTTPS 中时的<strong>攻击过程</strong>：</p>
<p>假设攻击者截获了一个特定密文 ciphertext ，这是 PKCS1 密文，它是用 PKCS1 编码的，然后结果作为 RSA 函数的输入，我们把这个密文叫做 RSA 函数的输出。</p>
<p>攻击者想解密密文，我们简化 SSL ，比如说攻击者可以直接发送密文给网页服务器，服务器将试图使用它的私钥去解密密文，在解密之后，首先它问：密文的解密结果是否是 PKCS1 编码的？即，它会问最高两位是 02 吗？如果是，才继续正常的解密，然后继续执行协议；如果这些最高位不是 02 ，就会声明一个错误，告诉攻击者他发送了一条无效的密文。这一点，让攻击者得以测试出给定密文的最高 16 位是否为 02 ，从某种意义上讲，这就给了攻击者一个神谕，使得他可以测试任意密文的逆是否以 02 开头。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E9%92%88%E5%AF%B9PKCS1%E7%9A%84%E6%94%BB%E5%87%BB.PNG" class title="针对PKCS1的攻击">
<p>实际上，这足以完全解密攻击者想解密的任何密文，一点点的信息泄露，因为 RSA 的特性，让攻击者完全解密一个给定密文。攻击者会这么做，他有一个想解密的密文，他把密文直接交给网页服务器询问它是否以 02 开头，接下来，攻击者选择一个随机值 r ，他要构建一个新密文 c’ ，也就是 $r^e$·c mod N ，这会造成什么？如果我们把 r 带入 RSA 函数，我们只是与 RSA 明文相乘，PKCS1 封装的明文 m ，用 r 去乘它，计算整项的 e 次方，r 是攻击者控制的值。然后攻击者会把 c’ 发送给网页服务器，服务器回答是肯定的，以 02 开头；或是否定的，不以 02 开头。</p>
<p>现在，把这个问题进行抽象，推广到更一般的情况，考虑如下情形：我知道 PKCS1(m) 这个数 x ，这个数是我想获得的 PKCS1 对 m 的编码，然后让你选择 r ，我会告诉你 r·x mod N 是否以 02 开头，实际上通过足够多的这样的问题，你就可以还原 x 的全部了。这意味着攻击者可以抓取一个给定的密文，在攻击的最后给出密文 c 的解密结果。</p>
<p><strong>怎么能够只通过学习明文的最高位是否是 02 就能还原整个明文呢？</strong></p>
<p>举个简单的例子，<strong>幼儿 Bleichenbacher</strong> ，只求表达这个攻击的基本想法。</p>
<p>设想攻击者可以发送密文 c ，网页服务器会用私钥解密，不过我们假设服务器不检查开头是否是 02 ，而是看最高位是否为 1 ，如果最高位是 1 ，网页服务器会说：是，如果最高位不是 1 ，网页服务器会返回：不。</p>
<p>为求进一步简化，我们假设 RSA 的模 N 是 2 的某次幂，即 N=$2^n$ ，当然，这不是一个有效的 RSA 模，RSA 模是一个两指数的乘积，但为求简便假定 N 是 2 的幂。</p>
<p>现在发现，通过给网页服务器发送密文 c ，攻击者只是学习<u>明文 x 的最高位</u>，服务器的行为完全泄露了最高位，现在攻击者可以把密文乘以 $2^e$ ，现在乘以 $2^e$ 就有去乘明文 x 的效果，就是把 x 乘以 2 ，因为我们是工作在 2 的 n 次方模下，乘以 2 意味着左移，当我们左移时，事实上我们学到了 2x 的最高位，也就等于学到了 <u>x 的次高位</u>。2x 的最高位，左移了 x ，并取模 N ，那么现在， 2x mod N 的最高位，也就是 x 的次高位，我们就学到了 x 的另一位内容。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%B9%BC%E5%84%BFBleichenbacher.PNG" class title="幼儿Bleichenbacher">
<p>现在重复这步，询问 c·$4^e$ ，这对应于 ${4x}^e$ ，询问 4x 会得到 4x mod N 的最高位，4 对应着左移两位，这意味着我们学到了 <u>x 的第三高位</u>，当我们一次次重复，对于不同的 c 的倍数，可以看出经过一些询问，就还原了 x 。</p>
<p>Bleichenbacher 需要一百万次的原因在于，他不是测试一位，而是测试最高两位是否为 02 。</p>
<h2 id="抵抗-pkcs1-v15-的攻击"><a href="#抵抗-PKCS1-v1-5-的攻击" class="headerlink" title="抵抗 PKCS1 v1.5 的攻击"></a>抵抗 PKCS1 v1.5 的攻击</h2><p>看 RFC ，提出的方案如下：</p>
<p>如果在你应用 RSA 解密之后，你会获得一个明文，它并不是 PKCS1 编码的，换句话说，它不是以 02 开头的，你可以选取某个随机字符串 r ，只假定明文是一个随机字符串 r ，只当什么也没发生，稍后协议会失败。具体地说，如果 PKCS1 编码不正确，你会说预备主密钥是这个随机字符串，或只是随机接收的，我们继续协议，当然建立会话会失败，因为客户端和服务端最终达成的交换密钥不一致，这会导致会话终止。</p>
<p>我们实际上不告诉攻击者明文是否以 02 开头，我们只是假定明文是某个随机值，对于许多网页来说，这只是一点点的代码改动，是容易布置的。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/RFC.PNG" class title="RFC">
<p><strong>PKCS1 是否应该都被改变，使得我们得以证明选择密文安全？</strong>这让我们以一种不同的方法来进行使用 RSA 的加密，即所谓的<strong>优化非对称加密补齐 OAEP</strong> 。</p>
<h2 id="pkcs1-v20-oaep"><a href="#PKCS1-v2-0-OAEP" class="headerlink" title="PKCS1 v2.0 OAEP"></a>PKCS1 v2.0 OAEP</h2><p>OAEP 是更好的使用 RSA 加密的方法，由 Bellare 和 Rogaway 于 1994 年提出，<strong>OAEP 工作流程</strong>如下：</p>
<p>取你想加密的明文信息 msg ，例如 128 位的 AES 密钥，然后首先在明文后面附上一小段密码本，在前面附上 01 ，然后再根据标准来加一组 0 ，假设这里有 128 位 0 。然后也可以选择一个随机值 rand ，使得这整个字符串与你的 RSA 模一样大，比如说 2047 位。</p>
<p>在你应用 RSA 函数之前，首先取你选的随机数，把它交给哈希函数 H ，这个哈希函数产生一个值，这个值与你编码的左边一样大，你把输出求异或，把得到的结果交给另一个哈希函数 G ，你用一个随机值去异或，最后会得到两个值，把它们联结起来得到 2047 位长的字符串，这也就是你应用 RSA 函数的字符串，结果就是 RSA 加密。</p>
<p>现在有一个 2001 年证明的理论，由 Fujisaki ，Okamoto ，Pointcheval 和 Stern 提出，证明了事实上<strong>如果你只假设 RSA 函数是一个安全的陷门函数，事实上这个模式使用 RSA 加密是选择密文安全的话，我们还必须假设函数 H 和 G 是某种理想的哈希函数才行</strong>，我们假设 H 和 G 是随机函数，从它们的定义域映射到它们的值域，这些叫做随机神谕。在实际中，当实现 OAEP 时，对于 H 和 G ，人们就使用 SHA-256 。这个定理依赖于 RSA 的性质，<u>事实上如果你使用一个普通的陷门置换，这个定理不成立，其它的置换未必具备 RSA 的代数性质</u>。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/OAEP.PNG" class title="OAEP">
<p><strong>为什么这叫做优化非对称加密补齐呢？</strong></p>
<p>原因在于，如果你看密文，会注意到，其密文是尽可能短的，密文与 RSA 输出一样长，没有附在密文后面的值。例如 ISO 标准中，即使你必须加密一个非常短的明文，你必须使用 RSA 加密 x ，然后在 x 后面附上使用对称加密系统加密的短消息，即使你必须加密 128 位 AES 密钥，根据 ISO 标准，你会获得一个 RSA 输出加上一段对称密码。而在 OAEP 中，你只获得了一个 RSA 输出，没有其他东西。从某种意义上这是优化的，密文长度是优化的。</p>
<p><strong>如果我们拥有一个普通的陷门置换，如何正确的使用 OAEP 呢？</strong></p>
<p>实际上，对 OAEP 有一个小修改，可以使得结果更为一般，这是 Shoup 于 2001 年给出的结果。证明了如果给我一个普通陷门置换 f ，实际上如果不用 OAEP 里的固定补齐，而是使用这个哈希函数 W ，它是你要加密的明文 m 和随机性 r 的哈希函数，然后在解密时，检测这个哈希函数的值是否正确，那么当你解密时，检查 W(m,r) 是否与明文中这个位置的内容一致，这种改进后的 OAEP 叫做 <strong>OAEP+</strong> ，事实上，<u>它是 CCA 安全的，对任意陷门置换都是选择密文安全的，不必依赖于 RSA 的特定性质</u>。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/OAEP+.PNG" class title="OAEP+">
<p>还有一个结果叫做<strong>简单非对称加密补齐 SAEP+</strong> ，就是说如果要依赖 RSA 的性质，那么在特殊情况下，当 RSA 的公钥指数等于 3 时，实际上你不需要第二阶段的加密工作，这里这个简单的补齐机制使用了函数 W 就足以保证选择密文安全了。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/SAEP.PNG" class title="SAEP">
<p>它们是 OAEP 的变种，但并没有被实际使用。</p>
<p><strong>如何解密 SAEP 密文 ct ？</strong>这里你有密文 ct ，如图那种方法是正确的密文解密？</p>
<p>第一个。有了密文，我们首先需要应用 RSA 逆函数作用于密文，我们会得到 RSA 明文，正好就是 x 和 r ，接下来我们需要使用函数 h 计算 r 的哈希值，然后把结果与 x 异或，这会给我们 m 和 (m,r) ，最后我们需要确保补齐 W(m,r) 是正确的，我们检查 w 是否等于 W(m,r) ，如果是，我们输出 m ；如果不是，我们输出 ⊥ ，表示密文无效。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%AF%86SAEP%E5%AF%86%E6%96%87ct.PNG" class title="如何解密SAEP密文ct">
<p>解密中的补齐检查在我们看过的所有的机制中都是很重要的，例如 OAEP+ 和 SAEP+ 就是这样解密的，检查补齐是否正确是很重要的。类似地在 OAEP 中，在解密时这个检查也很重要，如果补齐不是 01000 ，就输出 ⊥说密文是无效的。</p>
<p><strong>事实上实现 OAEP 可能是很困难的。</strong>假设你写了一个 OAEP 解密程序，首先取密文为输入，对密文应用 RSA 逆函数，比如说你希望得到 n 位值输出，2047 位，在 2048 位 RSA 模的情形下，如果你获得了某个比 $2^{2047}$ 大的数，你就拒绝，我们说错误=1 ，然后离开，接下来我们检查补齐是否是正确的，如果补齐不正确，我们还是拒绝和离开。这个实现的问题是，<strong>对于计时攻击来说是脆弱的</strong>。通过泄露时间信息，攻击者可以解出是什么导致了错误，是 RSA 解密后数太大的错误，还是因为补齐太大的错误，如果攻击者通过计时可以区分这两种错误，那么与 Bleichenbacher 类似，实际上是可能完全解密任何你选择的密文的，一丁点的信息泄露都可以让攻击者完全解密任何他想要的密文。这展示了，即使你正确的实现了 OAEP 的数学部分，你也可能会搞砸，使自己暴露于计时攻击中。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/OAEP%E5%AF%B9%E8%AE%A1%E6%97%B6%E6%94%BB%E5%87%BB%E6%98%AF%E8%84%86%E5%BC%B1%E7%9A%84.PNG" class title="OAEP对计时攻击是脆弱的">
<p>不要自己去实现密码学，特别是 RSA 、OAEP 。</p>
<h1 id="rsa-陷门置换的安全性"><a href="#RSA-陷门置换的安全性" class="headerlink" title="RSA 陷门置换的安全性"></a>RSA 陷门置换的安全性</h1><h2 id="rsa真的是一个单向函数吗"><a href="#RSA真的是一个单向函数吗？" class="headerlink" title="RSA真的是一个单向函数吗？"></a>RSA真的是一个单向函数吗？</h2><p>如果一个攻击者想求 RSA 函数的逆，攻击者有公钥 (N,e) ，现在他有 $x^e$ ，他的目标是还原 x 。那么，有了 $x^e$ mod N ，还原 x 的难度有多大？也就是，<strong>计算合数模的 e 次方根有多难？</strong>如果这个问题实际上很难，那么 RSA 事实上就是一个单向函数；如果很简单，那么 RSA 就会被破解了。</p>
<p>这个问题目前最好的算法，需要我们首先分解模 N ，一旦我们分解了模，就容易计算模 p 的 e 次方根，容易计算模 q 的 e 次方根，然后有了这些 e 次方根，实际上容易把它们组合起来，使用中国剩余定理，即可以还原模 N 的 e 次方根，我们一旦能够分解模，计算模 N 的 e 次方根就会很容易，但是分解模，就目前来看是一个非常困难的问题。</p>
<p>但一个自然的问题是，<strong>为了计算模 N 的 e 次方根，真的一定要分解模吗？</strong></p>
<p>就目前我们所知道最好的计算模 N 的 e 次方根的算法，是需要将 N 因子分解的，但是也许就有一条捷径可以让我们计算模 N 的 e 次方根而不用分解模。为了证明这是不可能的，我们必须证明一个规约，就是说我们必须证明，<u>如果我给大家一个有效算法可以计算模 N 的 e 次方根，这个算法也可以被改造成一个计算因子分解的算法，这会证明任何人都不能以比分解模更快的速度计算模 N 的 e 次方根，如果我们有这么一个结果，就会证明破解 RSA 实际上与分解大合数一样难</u>。</p>
<p>假设我给你一个算法，可以计算模 N 的立方根，对任意 $Z_N$ 中的 x ，这个算法会计算出 x 的模 N 立方根，你能证明，使用这样一个算法能分解模 N 吗？即使整个证明我们还不知道，我们知道的是，e = 2 时，如果我给你一个计算模 N 平方根的算法，那么事实上这就蕴含着分解模的算法，那么，计算平方根事实上与分解模一样困难。如果回想 RSA 的定义要求 ed = 1 mod Φ(N) ，这意味着，e 与 模 Φ(N) 必须是互质的，第一个方程是说，e 是 Φ(N) 可逆的，但是，如果 e 是 Φ(N) 可逆的，这必将意味着 e 必须与 Φ(N) 互质，而 Φ(N)=(p-1)(q-1) ，由于 p 和 q 都是大质数，p-1 和 q-1 总是偶数，因此 gcd(2,Φ(N))=2 ，因为 Φ(N) 是偶数，因此，公钥指数 2 与 Φ(N) 不互质。这意味着，<u>即使我们有了一个从计算平方根到因子分解的规约，e=2 也不能被拿来当作 RSA 指数，真正合法的最小 RSA 指数等于 3 ，但是等于 3 ，问题就是计算立方根，与因子分解一样难</u>。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E4%B8%80%E4%B8%AA%E8%A7%84%E7%BA%A6.PNG" class title="一个规约">
<p>我们目前只知道 RSA 是一个单向函数，事实上，破解 RSA，计算 e 次方根，都要求因子分解模。</p>
<p>现在有很多研究工作，试图提高 RSA （加密或解密）的性能。</p>
<h2 id="一个试图提高-rsa-性能的错误例子"><a href="#一个试图提高-RSA-性能的错误例子" class="headerlink" title="一个试图提高 RSA 性能的错误例子"></a>一个试图提高 RSA 性能的错误例子</h2><p>设想如果我想加速 RSA 解密，解密是通过计算密文的 d 次方，而指数算法的运行时间与 d 的长度大小成线性关系，与 log(d) 呈线性。试想，如果要加速 RSA 解密，为什么不使用一个小 d 呢？比如说，使用一个解密指数，大约是 $2^{128}$ ，这已经够大了，穷举 d 实际上是不可能的，但正常情况下，解密指数 d 约与模一般大，比如说 2000 位，通过使用仅为 128 位的 d ，从 2000 位降到 100 位，可以提高 RSA 解密速度 20 倍，实际上这是一个非常糟糕的点子。</p>
<p>看下面的思路，Michael Winener 有一个攻击，证明了事实上，一旦私钥指数 d 小于模的 1/4 次方，RSA 是不安全的。如果模大约是 2048 位，这意味着如果 d 小于 $2^{512}$，那么 RSA 是完全不安全的，而且这是最坏的一种不安全。即，给定一个公钥 e ，你可以很快还原出私钥 d 。有传言说，这个攻击可以针对最多 512 位，那么为什么我们不让这个模，比如说 530 位，那么这个攻击就不能用了，但是我们依然可以让 RSA 解密加速 4 倍，因为我们把指数从 2000 位降到 530 位，实际上，这是不安全的。Wiener 的攻击有一个扩展，证实了如果 d 小于 $N^{0.292}$，那么 RSA 也是不安全的。事实上，这个猜想是说，这对最多 $N^{0.5}$ 来说是正确的，这是一个开放的问题。</p>
<p>为了准确，当说 RSA 是不安全时，意思是，有了公钥 (N,e) ，你的目标是还原私钥 d 。</p>
<img src="/2020/08/05/%E3%80%90DanBoneh%E3%80%91%E5%9F%BA%E4%BA%8E%E9%99%B7%E9%97%A8%E7%BD%AE%E6%8D%A2%E7%9A%84%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/%E4%B8%80%E4%B8%AA%E8%AF%95%E5%9B%BE%E6%8F%90%E9%AB%98RSA%E6%80%A7%E8%83%BD%E7%9A%84%E9%94%99%E8%AF%AF%E4%BE%8B%E5%AD%90.PNG" class title="一个试图提高RSA性能的错误例子">
<p>这里的教训是，<strong>任何人都不应该在 d 上强加任何结构以期提高 RSA 性能</strong>。</p>
<h2 id="wieners-attack"><a href="#Wiener’s-attack" class="headerlink" title="Wiener’s attack"></a>Wiener’s attack</h2><p>它涉及的只是操作一些不等式。在 Wiener 的攻击里，我们有模和 RSA 指数：(N,e)，目的是还原私钥指数 d 。我们只知道 d 是小于 N 的四次方根的，事实上我将假设 d 小于 N 的四次方根再除以 3 ，这个 3 不重要，但这里主要起作用的项是，d 小于 N 的四次方根。</p>
<p>首先，因为 e 和 d 是 RSA 的公钥和私钥指数，我们知道 ed = 1 mod Φ(N)，这是什么意思？这意味着，存在某个整数 k ，满足 ed = k·Φ(N)+1 ，事实上，ed = k·Φ(N)+1 这个等式是这个攻击的关键所在，首先我们将两边同时除以 d·Φ(N) ，得到 e/Φ(N) - k/d = 1/(d·Φ(N)) ，加上绝对值，不会改变等性，|e/Φ(N) - k/d| = 1/(d·Φ(N))，现在 Φ(N) 几乎等于 N ，</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【PHP】Basic PHP</title>
    <url>/2020/03/14/%E3%80%90PHP%E3%80%91BasicPHP/</url>
    <content><![CDATA[<p><strong>PHP基础知识</strong></p>
<ul>
<li>PHP支持的8种原始数据类型</li>
</ul>
<ul>
<li><p>| 4种标量类型 | boolean布尔型；integer整形；float浮点型；string字符串型 |<br>| —————- | ———————————————————————————- |<br>| 2种复合类型 | array数组；object对象                                   |<br>| 2种特殊类型 | resource资源；NULL                                      |</p>
<a id="more"></a>
</li>
<li><p>布尔值：true、false，不区分大小写</p>
</li>
<li>整型值0、浮点值0.0、空白字符串、字符串“0”、没有成员变量的数组、NULL都是false，除此之外为true</li>
<li>整数可以用十进制、十六进制（0x）、八进制（0）符号制定</li>
<li>字符串：<strong>单引号</strong>定义的字符串如实输出，<strong>双引号</strong>定义的字符串可以输出变量、换行符等</li>
<li>数组：<ul>
<li>索引数组：形如：<code>$arr=array(1,2,3,4);</code></li>
<li>关联数组：形如：<code>$arr=array(&#39;a&#39;=&gt;1, &#39;b&#39;=&gt;2, &#39;c&#39;=&gt;3);</code></li>
<li>用array()定义：<code>$users=array(&quot;name1&quot;=&gt;&quot;test1&quot;, &quot;name2&quot;=&gt;&quot;test2&quot;);</code></li>
<li>用方括号定义：<code>$users[&#39;name1&#39;]=&#39;test1&#39;;</code> <code>$users[&#39;name1&#39;]=&#39;test1&#39;;</code></li>
</ul>
</li>
<li><p><strong>NULL类型：</strong></p>
<ul>
<li>NULL表示一个变量没有值</li>
<li>NULL不区分大小写</li>
<li>尚未被赋值的变量为NULL</li>
<li>被unset()的变量为NULL</li>
<li>NULL类型唯一可能的值是NULL</li>
<li>预定义变量</li>
</ul>
</li>
<li><p>$GLOBALS      当前脚本全局变量</p>
</li>
<li>$_SERVER        变量由web服务器设定</li>
<li>$_GET              网页提交的GET变量</li>
<li>$_POST           网页提交的POST变量</li>
<li>$_COOKIE       网页cookie变量</li>
<li>$_FILES           上传文件的变量</li>
<li><p>$_ENV             执行环境提交至脚本的变量</p>
<ul>
<li>常见函数</li>
</ul>
</li>
<li><p>strlen()       检查字符串长度</p>
</li>
<li>strpos()      检索字符串内指定的字符或文本<ul>
<li>strcmp() / strcasecmp() / strncmp()   字符串比较函数</li>
<li>ctrcmp(str1,str2)，如果str1<str2 返回<0；如果str1>str2 返回&gt;0；如果str1=str2 返回=0。假如str2为一个array，也返回0。</str2></li>
</ul>
</li>
<li>strstr() / stristr()                  查找替换</li>
<li>trim() / ltrim() / rtrim()       删除空白符<ul>
<li>逻辑运算符优先级从高到低是：&amp;&amp;、||、AND、OR</li>
<li><strong>“==” 与 “===”</strong></li>
</ul>
</li>
<li>=== 在比较的时候，会判断两种字符串的类型是否相等，再比较</li>
<li>== 在比较的时候，会先将字符串类型转化成相同，再比较</li>
<li>如果 比较一个数字和字符串 或者 比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行<ul>
<li><strong>empty</strong>：当var存在，并且是一个非空非零的值时返回FALSE，否则返回TRUE。以下东西被认为是空的：</li>
</ul>
</li>
<li>“”（空字符串）</li>
<li>0（作为整数的0）</li>
<li>0.0（作为浮点数的0）</li>
<li>“0”（作为字符串的0）</li>
<li>NULL</li>
<li>FALSE</li>
<li>array()（一个空数组）</li>
<li>$var;（一个声明了，但是没有值的变量）</li>
</ul>
]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】next踩坑TOC锚点undefined问题</title>
    <url>/2021/01/30/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91TOC%E9%94%9A%E7%82%B9undefined%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>hexo 搭建博客，文章的导航栏不能正常使用：文章左侧导航栏可以正常生成，但是在点击导航栏后并不能跳转到文章的对应位置，查看网页源代码，Console 报错如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Cannot <span class="keyword">read</span> <span class="keyword">property</span><span class="title"> </span>'top' of undefined</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>报错原因</strong></p>
<p> Markdown 的插件并未渲染 heading 的 id ，所以导致锚点失效。</p>
<p>原来会被编译成 <code>&lt;h2 id=&quot;title&quot;&gt;title&lt;/h2&gt;</code></p>
<p>而现在会被编译成 <code>&lt;h2&gt;&lt;span id=&quot;title&quot;&gt;title&lt;/span&gt;&lt;/h2&gt;</code></p>
<p><strong>解决方案</strong></p>
<p>进入你项目根目录的 <code>node_modules/hexo-toc/lib/filter.js</code> 中，把28行~31行修改为：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="variable">$title</span>.attr(<span class="string">'id'</span>,<span class="built_in"> id</span>);</span><br></pre></td></tr></table></figure>
<p>即，仅保留28行，其他的内容注释掉。</p>
<p>问题得以解决。</p>
<p><a href="https://www.dazhuanlan.com/2019/12/05/5de8d9ba57a52/" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>hexo踩坑记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【Web安全】Web安全基础</title>
    <url>/2021/09/28/%E3%80%90Web%E5%AE%89%E5%85%A8%E3%80%91Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="常见的web安全漏洞"><a href="#常见的Web安全漏洞" class="headerlink" title="常见的Web安全漏洞"></a>常见的Web安全漏洞</h1><p>2017年版OWASP Top 10</p>
<a id="more"></a>
<ol>
<li>注入。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据</li>
<li>失效的身份认证。</li>
<li>敏感数据泄露。</li>
<li>XML外部实体（XXE）。</li>
<li>失效的访问控制。</li>
<li>安全配置错误。</li>
<li>跨站脚本（XSS）。</li>
<li>不安全的反序列化。</li>
<li>使用含有已知漏洞的组件。</li>
<li>不足的日志记录和监控。</li>
</ol>
<h1 id="http基础"><a href="#HTTP基础" class="headerlink" title="HTTP基础"></a>HTTP基础</h1><h3 id="http之url"><a href="#HTTP之URL" class="headerlink" title="HTTP之URL"></a>HTTP之URL</h3><p>URL标准格式</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">协议:<span class="regexp">//</span>服务器域名[:端口<span class="regexp">/路径/</span>[?查询]</span><br></pre></td></tr></table></figure>
<p>eg</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http:<span class="regexp">//</span>www.ctfs-wiki.com<span class="regexp">/SQLi/</span>sqli.php?id=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>协议。<code>HTTP</code></li>
<li>服务器域名。<code>www.ctfs-wiki.com</code>，也可使用ip地址表示</li>
<li>端口。不是URL必须的部分，如果省略，将采用默认端口，HTTP默认端口是80</li>
<li>路径。<code>SQLi/sqli.php</code></li>
<li>查询。<code>id=1</code></li>
</ol>
<h3 id="http请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><p>HTTP请求包括3部分：请求行、请求头（消息报头）、请求正文。</p>
<ol>
<li>请求行：请求方法+请求路径+协议版本。</li>
<li>请求头：有关客户端环境和请求正文的有用信息。</li>
<li>请求正文：客户端请求提交的查询字符串信息。</li>
</ol>
<p>tips：请求头和请求正文之间是一个空行，表示请求头已经结束。</p>
<h3 id="http响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><p>HTTP相应包括3部分：响应行、响应头（消息报头）、响应正文。</p>
<ol>
<li>响应行：协议版本+状态码+状态消息。</li>
<li>响应头：用来传递不能放在响应行中的附加响应信息、关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。</li>
<li>响应正文：服务器返回给客户端的文本信息。</li>
</ol>
<h3 id="http状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><img src="/2021/09/28/%E3%80%90Web%E5%AE%89%E5%85%A8%E3%80%91Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB.JPG" class title="HTTP状态码分类">
<h3 id="http请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><ol>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
</ol>
<h1 id="cookie和session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><p>懒得码了，决定斥巨资买书，祥见《Web安全原理分析与实践》。</p>
]]></content>
      <categories>
        <category>信安之路</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】next踩坑no such file or directory open ... \.swig </title>
    <url>/2020/06/22/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91no-such-file-or-directory-open-swig/</url>
    <content><![CDATA[<p>更换 hexo 主题为 next 时，首先根据 hexo 官方文档进行主题设定。</p>
<p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档链接</a></p>
<a id="more"></a>
<p>主题设定完成，发布过程<strong>报错</strong></p>
<p>ERROR ENOENT: no such file or directory, open ‘D:\MyWork\hexo\themes\next\layout_scripts\schemes.swig’</p>
<img src="/2020/06/22/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91no-such-file-or-directory-open-swig/cmd%E6%8A%A5%E9%94%99.PNG" class title="cmd报错">
<p><strong>解决方案</strong></p>
<p>对主题配置文件代码（_config.yml）进行格式检查，推荐使用 YAML Lint 在线检测。</p>
<p><a href="http://www.yamllint.com/" target="_blank" rel="noopener">检测地址链接</a></p>
<img src="/2020/06/22/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91no-such-file-or-directory-open-swig/yamllint%E6%A3%80%E6%B5%8B.PNG" class title="yamllint检测">
<p>检测发现第100行代码冒号后缺少空格，错误得以解决。</p>
]]></content>
      <categories>
        <category>hexo踩坑记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【hexo】next踩坑侧边栏菜单链接乱码问题</title>
    <url>/2020/06/22/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%8F%9C%E5%8D%95%E9%93%BE%E6%8E%A5%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="乱码一"><a href="#乱码一" class="headerlink" title="乱码一"></a>乱码一</h4><p>点击首页、归档、分类、标签、关于等导航时，链接地址为：<a href="https://xxx.github.io/%20，页面出现404错误。" target="_blank" rel="noopener">https://xxx.github.io/%20，页面出现404错误。</a></p>
<a id="more"></a>
<img src="/2020/06/22/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%8F%9C%E5%8D%95%E9%93%BE%E6%8E%A5%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/%E5%AF%BC%E8%88%AA%E6%A0%8F.PNG" class title="导航栏">
<p><strong>解决方案</strong></p>
<p>链接中的%20代表空格，修改主题配置文件_config.yml，将||之前的所有空格删掉，问题解决。</p>
<img src="/2020/06/22/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%8F%9C%E5%8D%95%E9%93%BE%E6%8E%A5%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.PNG" class title="主题配置文件">
<h4 id="乱码二"><a href="#乱码二" class="headerlink" title="乱码二"></a>乱码二</h4><p>点击“日志”导航时，链接地址为：<a href="https://xxx.github.io/%20，页面出现404错误。" target="_blank" rel="noopener">https://xxx.github.io/%20，页面出现404错误。</a></p>
<img src="/2020/06/22/%E3%80%90hexo%E3%80%91next%E8%B8%A9%E5%9D%91%E4%BE%A7%E8%BE%B9%E6%A0%8F%E8%8F%9C%E5%8D%95%E9%93%BE%E6%8E%A5%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/%E6%97%A5%E5%BF%97%E5%AF%BC%E8%88%AA.PNG" class title="日志导航">
<p><strong>解决方案</strong></p>
<p>在 themes\next\layout_macro 下找到 sidebar.swig 文件，找到如下代码：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> config.archive_dir != '/' and site.posts.length &gt; 0 %&#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-state-item site-state-posts"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.menu.archives %&#125;</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(theme.menu.archives).split('||')[0] | trim &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">else</span></span> %&#125;</span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(config.archive_dir) &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml">	  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-count"</span>&gt;</span></span><span class="template-variable">&#123;&#123; site.posts.length &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">	  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-name"</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('state.posts') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(theme.menu.archives).split('||')[0] | trim &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>替换为</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(theme.menu.archives.split('||')[0]) | trim &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo踩坑记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>【pptx】对称密码1</title>
    <url>/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/</url>
    <content><![CDATA[<p><strong>随机序列</strong>：</p>
<p>性质：<u>不能可靠重复产生</u>（用完全相同的输入操作两次，得到两个不相关的序列）</p>
<p>数学解释：概率服从<u>均匀分布</u>（①产生每个比特概率为 1/2  ②任意两个比特统计上相互独立）</p>
<p>计算机不能产生真正的随机序列，其本身只能产生<u>伪随机序列</u>。相同计算环境下，对于相同输入，计算机只能产生相同的输出。</p>
<a id="more"></a>
<p>一次一密（one-time pad）密钥流是随机序列，且不重复使用。</p>
<p>如何定义“安全”：</p>
<ol>
<li>不能恢复密钥？$E_k$(m)=m 虽没有泄露密钥，但泄露了明文。</li>
<li>不能恢复所有明文？$E_k$($m_0$||$m_1$) = $m_0$ || k ⊕$m_1$ 只加密了后半段，前半段明文泄露。</li>
</ol>
<p>香农认为，在唯密文攻击下，<u>密文</u>不能泄露明文的<u>任何信息</u>（只包含明文的内容）</p>
<p><strong>完善保密性</strong>：见《【DanBoneh】One Time Pad》<a href="https://lemongx.github.io/2020/03/24/%E3%80%90DanBoneh%E3%80%91OneTimePad/" target="_blank" rel="noopener">密码完美安全</a>。</p>
<p><strong>香农定理</strong>：满足完善保密性，所需密钥至少和明文一样长。</p>
<p><strong>一次一密</strong>总结：</p>
<p>优点：</p>
<ol>
<li>只用异或运算，实现简单/效率高</li>
<li>唯密文攻击无效，再牛的攻击者也无计可施（具备完善保密性）</li>
</ol>
<p>不实用的原因：</p>
<ol>
<li>密钥是(真)随机的（如何获得真随机序列是一个现实的问题）</li>
<li>每个密钥只用一次</li>
<li>密钥至少和明文一样长(完善保密性, 香农定理)（分发/存储如此长的密钥，并确保安全性很困难）</li>
</ol>
<p><strong>流密码</strong>：为使一次一密更加实用，降低安全性要求，缩短密钥长度，使用<u>“伪随机”密钥流</u>代替<u>“随机”密钥流</u>，利用一个短的随机密钥（种子k）作为伪随机数发生器（PRG/PRNG）的输入，产生伪随机密钥流 G(k)，再与明文异或。</p>
<p><strong>PRG</strong>：见《【DanBoneh】Stream Ciphers》<a href="https://lemongx.github.io/2020/03/24/%E3%80%90DanBoneh%E3%80%91StreamCiphers/" target="_blank" rel="noopener">PRG</a>。</p>
<p><strong>PRG的安全性</strong>：对于任何高效可计算的算法，成功区分出 PRG 的输出和随机序列的概率都是可忽略的。（计算上不可区分）</p>
<p><u>一个PRG是安全的 = 一个PRG是不可预测的</u>。</p>
<p>流密码不具有完善保密性。</p>
<p><strong>完善保密性 VS 语义安全性</strong></p>
<p>完善保密性</p>
<ol>
<li>唯密文攻击无效</li>
<li>无条件安全（即使拥有无限计算资源，唯密文攻击也无法破译）</li>
</ol>
<p>语义安全性</p>
<ol>
<li>选择明文攻击无效（密钥只用一次）比唯密文攻击更强</li>
<li>计算上安全（攻击者的计算资源有限，更符合现实）</li>
</ol>
<p>在实验中，攻击者发送等长的两条明文进行加密，实验前黑盒中 b 的值已经确定，攻击者根据加密结果判断 b 的值（即发生的实验是实验一还是实验二）</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B.PNG" class title="语义安全模型">
<p><strong>语义安全性</strong>：在上述模型中，对于所有高效可计算的攻击者A，优势Adv：=| Pr[A($E_k$($m_0$)) = 1] - Pr[A($E_k$($m_1$)) = 1] |（即 b 为 0 或 1 的概率差）是可忽略的。</p>
<p>对于任何高校可计算的攻击者选择的明文 $m_0$ 和 $m_1$ ：{$E_k$($m_0$)} $≈_c$ {$E_k$($m_1$)} （计算上不可区分）</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A8%E7%AD%89%E4%BB%B7%E6%A8%A1%E5%9E%8B.PNG" class title="语义安全等价模型">
<p><strong>语义安全性</strong>等价定义：在上述模型中，对于所有高效可计算的攻击者A，优势Adv：=| Pr[b’ = b] - 1/2 |（攻击者猜对 b 的概率）是可忽略的。</p>
<p>对于任何高效可计算的攻击者选择的明文 $m_0$ 和 $m_1$ ：猜中 b 的概率可以忽略不计。</p>
<p><strong>一次一密是语义安全的。</strong></p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E4%B8%80%E6%AC%A1%E4%B8%80%E5%AF%86%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A8%E8%AF%81%E6%98%8E.PNG" class title="一次一密语义安全证明">
<p><strong>PRG具有不可预测性 ⇒ 相应的流密码是语义安全的。</strong></p>
<p>目的是证明流密码在计算上不可区分</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E6%B5%81%E5%AF%86%E7%A0%81%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A81.PNG" class title="流密码语义安全1">
<p>首先证明下图，由于 PRG 具有不可预测性，则 PRG 与真随机在计算上不可区分</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E6%B5%81%E5%AF%86%E7%A0%81%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A82.PNG" class title="流密码语义安全2">
<p>一次一密是语义安全的，在计算上不可区分</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E6%B5%81%E5%AF%86%E7%A0%81%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A83.PNG" class title="流密码语义安全3">
<p>PRG 与真随机在计算上不可区分</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E6%B5%81%E5%AF%86%E7%A0%81%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A84.PNG" class title="流密码语义安全4">
<p>因此流密码在计算上不可区分，是语义安全的。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%811/%E6%B5%81%E5%AF%86%E7%A0%81%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A8.PNG" class title="流密码语义安全">
<p><strong>一次一密 VS 流密码</strong></p>
<p>一次一密：符合<u>完善保密性</u>、<u>语义安全性</u>，密钥长度至少和明文<u>一样长</u>，不实用。</p>
<p>流密钥：符合<u>语义安全性</u>，密钥长度比明文<u>短很多</u>，实用。</p>
<p>一次一密和流密码的<strong>密钥都不能重复使用</strong>，想重复使用密钥，不要“直接”使用流密码。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【vps】vps搭建</title>
    <url>/2020/03/12/%E3%80%90vps%E3%80%91vps%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<ul>
<li>github博客搭建，<a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">参考链接</a></li>
</ul>
<p><strong>vps搭建</strong></p>
<ul>
<li><p>Vultr购买账号</p>
</li>
<li><p>利用 Xshell 和 ShadowSocks 搭建vps</p>
<p><a href="http://www.pianshen.com/article/133225018/" target="_blank" rel="noopener">参考链接1</a></p>
<p><a href="http://www.pianshen.com/article/8499260352/" target="_blank" rel="noopener">参考链接2</a></p>
<p><a href="https://www.jianshu.com/p/4716cc35750f" target="_blank" rel="noopener">参考链接3</a></p>
</li>
</ul>
<p><strong>错误</strong>：vps代理连接失败，经学长指导，关闭vps防火墙，连接成功</p>
<p><strong>解决方法</strong>：</p>
<a id="more"></a>
<ol>
<li><p>在Xshell输入以下代码，关闭vps防火墙</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">mkdir -p ~<span class="regexp">/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="regexp">curl https:/</span><span class="regexp">/1248.ml/my</span><span class="regexp">/keys/</span>Phuker.keys &gt;&gt; ~<span class="regexp">/.ssh/</span>authorized_keys &amp;&amp; \</span><br><span class="line">chmod <span class="number">700</span> ~<span class="regexp">/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="regexp">chmod 600 ~/</span>.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
</li>
<li><p>在cmd设置代理地址</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">set</span> <span class="attribute">ALL_PROXY</span>=http://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
</li>
<li><p>在cmd尝试连接网页</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">curl -vv http<span class="variable">s:</span>//ip.<span class="keyword">cn</span>/   或者  curl -vv http<span class="variable">s:</span>//www.google.<span class="keyword">com</span>/</span><br></pre></td></tr></table></figure>
</li>
<li><p>在浏览器尝试连接，连接成功（以上操作随时观察vps详细日志记录）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>【pptx】对称密码2</title>
    <url>/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/</url>
    <content><![CDATA[<p><strong>分组密码</strong>：见《【DanBoneh】Block Ciphers》<a href="https://lemongx.github.io/2020/03/27/%E3%80%90DanBoneh%E3%80%91BlockCiphers/" target="_blank" rel="noopener">分组密码</a>。</p>
<p>设计分组密码的两种基本技术：为了<u>抵抗攻击者对密码系统的统计分析</u>，香农提出<strong>混乱</strong>和<strong>扩散</strong>。</p>
<a id="more"></a>
<p><strong>混乱</strong></p>
<ol>
<li>目的：使明文和密文之间、密文和密文之间的相关统计特性极小化，从而使攻击者无法找到密钥。</li>
<li>方法：代换。</li>
</ol>
<p><strong>扩散</strong></p>
<ol>
<li>目的：将明文及密钥的影响尽可能迅速地散布到较多个密文比特中。</li>
<li>方法：置换。</li>
</ol>
<p>目前，绝大多数的分组密码都是通过<strong>迭代技术</strong>构造的。轮密钥（子密钥）：$k_1$~$k_d$，轮函数：R($k_i$,..)。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E8%BF%AD%E4%BB%A3.PNG" class title="分组密码迭代">
<h5 id="des"><a href="#DES" class="headerlink" title="DES"></a>DES</h5><p>核心思想：<strong>Feistel网络</strong>，是使用<u>任意函数</u>构造<u>可逆函数</u>（分组密码）的一般方法。d 个函数无需可逆，构造出的Feistel网络仍然可逆。</p>
<p>Feistel网络</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/Feistel%E7%BD%91%E7%BB%9C.PNG" class title="Feistel网络">
<p>Feistel网络求逆</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/Feistel%E7%BD%91%E7%BB%9C%E6%B1%82%E9%80%86.PNG" class title="Feistel网络求逆">
<p>DES结构</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/DES%E7%BB%93%E6%9E%84.PNG" class title="DES结构">
<p>Feistel网络一轮的结构中，乘积函数 F 有三个关键函数 E-box、S-box、P-box。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/DES%E4%B8%80%E8%BD%AE%E7%BB%93%E6%9E%84.PNG" class title="DES一轮结构">
<p>DES安全性：密钥空间只有 $2_56$ ≈ $10_17$，56 bits不足以抵抗<u>穷举攻击</u>。DES 依靠 S-box 实现非线性变换，但 NSA 被指责在 S-box 设计上隐藏了“陷门”。</p>
<p><strong>PRF and PRP</strong>：见《【DanBoneh】Block Ciphers》<a href="https://lemongx.github.io/2020/03/27/%E3%80%90DanBoneh%E3%80%91BlockCiphers/" target="_blank" rel="noopener">PRF、PRP</a>。</p>
<p><strong>PRF开关引理</strong></p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/PRF%E5%BC%80%E5%85%B3%E5%BC%95%E7%90%86.PNG" class title="PRF开关引理">
<p><strong>分组密码工作模式</strong></p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.PNG" class title="分组密码工作模式">
<h5 id="ecb模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h5><p>对于包含两个或两个以上分组的明文，ECB 不是语义安全的。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/ECB%E8%AF%AD%E4%B9%89%E5%AE%89%E5%85%A8%E8%AF%81%E6%98%8E.PNG" class title="ECB语义安全证明">
<p>优点</p>
<ol>
<li>简单、高速。</li>
<li>无差错传播：单个密文分组在传输或存储时出现错误，只会影响该分组的解密，不会影响到其他分组。</li>
</ol>
<p>缺点：安全性差，暴露明文数据的格式和统计特征</p>
<p><strong>确定的计数器模式</strong></p>
<p>F 是安全的 PRF，与真随机函数不可区分，可以构造一个安全的 PRG。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/%E7%A1%AE%E5%AE%9A%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8%E6%A8%A1%E5%BC%8F.PNG" class title="确定的计数器模式">
<h5 id="cpa"><a href="#CPA" class="headerlink" title="CPA"></a>CPA</h5><p>CPA安全性：<u>选择明文攻击下</u>的<u>语义安全性</u>（密钥可以重复使用）。</p>
<p>对称加密体制不是CPA安全的。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%BD%93%E5%88%B6.PNG" class title="对称加密体制">
<p><strong>随机化加密</strong></p>
<p>选取随机数和密钥 k 共同加密明文，使得加密相同的明文，输出不同的密文。</p>
<p>密文比明文长，密文长度 =  明文长度 + “随机比特长度”，“随机比特长度” ≠ 随机比特长度，只是相关。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/%E9%9A%8F%E6%9C%BA%E5%8C%96%E5%8A%A0%E5%AF%86.PNG" class title="随机化加密">
<p><strong>nonce-based加密</strong></p>
<p>nonce：只使用一次的数值，每加密一个明文，就换一个新的。(k，n)不重复使用。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/nonce-based%E5%8A%A0%E5%AF%86.PNG" class title="nonce-based加密">
<p>如何选择nonce？</p>
<ol>
<li>计数器方式：设置nonce为计数器，使用每次数值加 1 ，如果发送者和接收者保持相同的状态，则nonce无需发送。</li>
<li>随机数方式：设置nonce为随机数，随机数需与密文一起发送。</li>
</ol>
<p>文件加密：随机数方式（加密文件时无需保持状态）</p>
<p>SSL（按顺序发送）: 计数器方式 （无需向对方发送nonce）</p>
<p>IP sec（无序发送）: 计数器方式即可, 但发送每个报文时，需附带所用nonce一起发送</p>
<h5 id="cbc模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h5><p>密钥可以重复使用，CPA安全的。加密串行，解密可以并行。使用 PRP。</p>
<p>见《【DanBoneh】Using Block Ciphers》<a href="https://lemongx.github.io/2020/03/28/%E3%80%90DanBoneh%E3%80%91UsingBlockCiphers/" target="_blank" rel="noopener">CBC</a>。</p>
<p>差错传播：单个密文分组在传输或存储过程中发生错误，会影响该分组和后面一个分组的解密。</p>
<p>可自同步：只要后面的分组没发生错误，便不会影响后续分组的解密。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/CBC%E5%B7%AE%E9%94%99%E4%BC%A0%E6%92%AD.PNG" class title="CBC差错传播">
<h5 id="ctr模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h5><p>密钥可以重复使用，CPA安全的。加密、解密都可以并行。使用安全的 PRF。</p>
<img src="/2020/03/30/%E3%80%90pptx%E3%80%91%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%812/CTR%E7%9A%84IV%E9%80%89%E6%8B%A9.PNG" class title="CTR的IV选择">]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【安全综合实践】逆向实验</title>
    <url>/2020/08/28/%E3%80%90%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5%E3%80%91%E9%80%86%E5%90%91%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="lab1思维导图"><a href="#lab1思维导图" class="headerlink" title="lab1思维导图"></a>lab1思维导图</h1><img src="/2020/08/28/%E3%80%90%E5%AE%89%E5%85%A8%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5%E3%80%91%E9%80%86%E5%90%91%E5%AE%9E%E9%AA%8C/lab1.png" class title="lab1">
<h1 id="lab1实验手册"><a href="#lab1实验手册" class="headerlink" title="lab1实验手册"></a>lab1实验手册</h1>

	<div class="row">
    <embed src="lab1实验手册.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>信安之路</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>gdb</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>【总结归纳】对称加密知识点串讲</title>
    <url>/2020/06/19/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/</url>
    <content><![CDATA[<h4 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h4><p>\1.    一个东西是不是随机的与长什么模样无关，即使是一串0或者一串1他也有可能是随机的。一个随机的东西符合两点，①它的每一个比特是等概率产生的，即产生每一个比特的概率都是1/2，②任何一个比特的产生与其它比特的产生都是相互独立的。随机与产生的方式有关，与产生的结果无关。</p>
<p>\2.    第一个给“安全”①正式下定义的是香农，他也②提出了完善保密性，并证明了一次一密OTP能够达到完善保密性，③给出了香农定理，提出若一个体制能够达到完善保密性，它就一定要求密钥的长度不能小于明文的长度。一次一密它虽然能达到完善保密性，但并不实用。</p>
<p>\3.    考虑安全性应考虑两个方面，①攻击者能发动什么样的攻击，②攻击者的目标是什么。</p>
<p>\4.    完善保密性是在唯密文攻击下的概念，目标是给了两个明文，区分密文里包含的是哪一个明文。</p>
<p>\5.    虽然一次一密不实用，但它加解密都十分容易只要做一个异或就可以了，人们想既保留优点又实用，因此提出流密码。</p>
<p>\6.    想要实用，需要一个短的密钥去加密明文，又要达到完善保密性，这与香农定理冲突，因此，需要对“安全”重新下定义。</p>
<p>\7.    一次一密的密文没有泄露明文的任何一个信息。为了实用，人们提出计算上安全的概念，即在计算资源有限的情况下，允许密文泄露一些明文信息，只要泄露的信息在计算资源有限的条件下对破译密文的帮助可忽略即可。</p>
<p>\8.    语义安全模型下，攻击者只能询问挑战者一次m0或m1，并且m0和m1的长度相等，挑战者返回密文，在这个条件下攻击者区分密文对应的是m0还是m1。</p>
<p>\9.    PRG，给它一个很短的种子，它能产生一个很长的输出，与明文进行异或。</p>
<p>\10.   一个PRG必须满足不可预测性。</p>
<p>\11.   PRG的安全性和流密码的安全性是两回事，PRG的安全性要求它的输出与真随机的输出必须是不可区分的，流密码的安全性要求能够达到语义安全性。</p>
<p>\12.   “PRG具有不可预测性”与“PRG的输出与真随机的输出不可区分，即PRG是安全的”是等价的，只不过探讨的角度不同。</p>
<p>\13.   PRG的输出是可以截断的，截取PRG中的一段，它与等长的真随机是不可区分的。</p>
<p>\14.   使用流密码时，密钥不能重复使用。</p>
<p>\15.   语义安全性是选择明文攻击下的概念，目的是区分两个不同的消息。语义安全性的模型攻击者只能询问一次，CPA下攻击者可以询问多次。</p>
<p>一次一密在唯密文攻击下可以达到完善保密性，在选择明文攻击下可以达到语义安全性。</p>
<h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><p>\1.    分组密码输入是一个固定长度的明文分组，输出一般是和明文分组长度相同的分组叫做密文分组（DES：64bits，AES：128bits），分组密码只能处理固定长度的分组信息。</p>
<p>\2.    根据香农的研究，在设计分组密码的时候有两个常用的基本技术，①混乱，②扩散，主要目的是抵抗攻击者对密码系统的统计分析。</p>
<p>\3.    混乱，经常用代换（S盒）的技术实现；扩散，通常用置换（P盒）的技术实现。</p>
<p>\4.    绝大多数的分组密码都是通过迭代技术构造的，迭代技术是一轮一轮的，每一轮都会有一个密钥（轮密钥or子密钥），每一轮也会有一个函数（轮函数），把上一轮的输出作为输入，最后一轮的输出就是密文，第一轮的输入就是明文，轮密钥是由一个密钥扩展来的，扩展的过程会用一个密钥扩展函数把输入的密钥进行一些变换产生每一轮的子密钥。密钥长度不同，轮数不同。（DES 16轮，AES 10轮）</p>
<p>\5.    DES的核心是Feistel网络，Feistel网络由Feistel置换组合在一起，DES的每一轮都是一个Feistel置换，16轮置换构成Feistel网络，不论Feistel网络的f是不是可逆的，最终组合在一起都是可以置换的。（搞懂Feistel网络为什么是可逆的）</p>
<p>\6.    DES明文长度，密文长度，密钥长度都是64bits，密钥虽然是64bits，但有8bits在转换成子密钥时是不用的，因此有效密钥长度只有56bits。</p>
<p>\7.    目前，没有一个实用的攻击对DES有效，不用DES而用AES是因为DES的密钥长度太短，穷举就可以攻破。</p>
<p>\8.    AES使用SPN网络，S盒和P盒交替使用。</p>
<p>\9.    伪随机函数PRF和伪随机置换PRP是用来研究分组密码安全性的，证明时用它们代替分组密码。</p>
<p>\10.   随机函数是指在一个空间有一大堆函数，我们随机挑选一个出来就叫随机函数，不论这个函数的输出怎样，只要是从这个空间随机选择出来的就叫随机函数。是不是随机函数与函数的输出结果无关，与选择的方式有关。</p>
<p>\11.   伪随机置换与伪随机函数类似，是从所有的置换空间随机选择一个出来。</p>
<p>\12.   PRP是PRF的一个特例。</p>
<p>\13.   一个PRP就是一个PRF，但一个安全的PRP未必就是一个安全的PRF。</p>
<p>\14.   PRF安全引理，只有当分组的长度足够大的时候，一个安全的PRP才是一个安全的PRF。</p>
<h4 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h4><p>\1.    ECB模式（电子密码本模式），是一种不安全的模式，不是语义安全的，简单地把明文分成一组一组，用分组密码进行加密，两个相同的明文分组加密后的密文分组相同，当攻击者看到两个相同的密文，虽然不知道明文的内容，但知道对应的明文也相同。</p>
<p>\2.    ECB不是语义安全的。</p>
<p>\3.    CTR（确定的计数器模式），用PRF构造PRG，可并行。</p>
<p>\4.    CPA安全性（选择明文攻击下的语义安全性），攻击者发送多次询问，获得多次对应的密文，即密钥可重复使用。在语义安全性的模型里攻击者只能发送一次询问，获得一次密文，即密钥只用一次。</p>
<p>\5.    凡是确定的加密方案（DES、AES），一定不是CPA安全的。因为给定相同的明文，加密的结果总是相同，但是是语义安全的，因为语义安全刻画的是密钥使用一次。</p>
<p>\6.    一个加密体制如果不是语义安全的，那它也一定不是CPA安全的。</p>
<p>\7.    CPA安全性改造思路：加密相同的明文，输出不同的密文。</p>
<p>\8.    改造方法：①随机化加密。选择一个随机数，用密钥和随机数一起加密明文。导致密文必然会比明文要长，密文里不仅包含明文信息，还包含了随机数信息。②nonce-based加密。每加密一个明文就换一个新的nonce（新鲜值），nonce可以作为加密算法的输入，保证加密明文nonce不能重复，除非换一个新的密钥，即（k，n）这个组合不重复使用。</p>
<p>\9.    nonce的选择方法：①计数器方式。初始为0，每次加1。如果发送者和接收者保持相同状态，则nonce无需发送。②随机数方式。随机数需与密文一起发送。</p>
<p>\10.   CBC模式（密码分组链接模式）和CTR模式（计数器模式）都能够证明在CPA安全性下是安全的，使用时密钥可以重用。</p>
<p>\11.   CBC模式是一种级联的形式，整个加密过程是一个串行的过程，解密可以并行。在加密下一个明文时需要用到前一个密文分组，与当前的明文分组进行异或，再加密。为了隐藏第一个明文的信息，在加密时需要一个初始向量与第一个明文分组进行异或，初始向量在发送给接收者时不需要加密，以明文的形式和密文一起发送给接收者。</p>
<img src="/2020/06/19/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/CBC%E5%8A%A0%E5%AF%86.png" class title="CBC加密">
<img src="/2020/06/19/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/CBC%E8%A7%A3%E5%AF%86.png" class title="CBC解密">
<p>\12.    CBC模式中差错传播，单个密文分组在传输或存储过程中发生错误，会影响该分组和后面一个分组的解密。只要后面的分组没发生错误，便不会影响后续分组的解密。</p>
<img src="/2020/06/19/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/CBC%E5%B7%AE%E9%94%99%E4%BC%A0%E6%92%AD.png" class title="CBC差错传播">
<p>\13.    CBC模式中初始向量IV的选择：①取随机数（不能是可预测的，即从上一个IV可预测下一个IV），与密文一起发送。如果IV可预测，则不是CPA安全的。②用nonce作为IV，若nonce随机，则与前面随机数取IV相同，若nonce不随机，可预测，则使用前必须对其进行一次加密，使用双密钥，其中一个密钥用来加密IV，另外一个密钥用在CBC链条里。使用nonce的好处是双方都知道下一个nonce，不需要再发送。</p>
<img src="/2020/06/19/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/nonce-basedCBC.png" class title="nonce-basedCBC">
<p>\14.    CBC模式中，若分组后最后一个分组的长度不够，则需要进行填充。若明文分组的长度是分组长度的整数倍，依然需要填充，需要额外追加一个完整的分组（dummy block），接收者就会知道不管长度够不够都有填充，若长度不够时填充，整数倍不填充，接收者不知道是否填充，可能会导致解密失败。注：密文窃取填充技术中，不需要追加dummy block。</p>
<img src="/2020/06/19/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/%E5%A1%AB%E5%85%85%E6%8A%80%E6%9C%AF.png" class title="填充技术">
<p>\15.    CTR模式，本质上是用一个PRF来构造一个流密码，加解密都可以并行。首先对IV、IV+1、IV+2…进行加密，然后分别与每一个明文分组进行异或，得到密文分组，IV与密文分组一起发送给接收方。CTR不存在差错传播，但不影响其他的分组。</p>
<img src="/2020/06/19/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/CTR%E5%8A%A0%E5%AF%86.png" class title="CTR加密">
<p>\16.    CTR模式中初始向量IV的选择：①取随机数，与密文一起发送。②nonce加密，需要保证Fk(x)不会重复出现。</p>
<h4 id="pdf-文件"><a href="#PDF-文件" class="headerlink" title="PDF 文件"></a>PDF 文件</h4>

	<div class="row">
    <embed src="对称加密知识点串讲.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h4 id="李师兄整理的dan-boneh学习笔记"><a href="#李师兄整理的Dan-Boneh学习笔记" class="headerlink" title="李师兄整理的Dan-Boneh学习笔记"></a>李师兄整理的Dan-Boneh学习笔记</h4>

	<div class="row">
    <embed src="Dan-Boneh学习笔记.pdf" width="100%" height="550" type="application/pdf">
	</div>



<p><a href="https://muzibing.github.io/2020/04/30/2020.04.30%EF%BC%88114%EF%BC%89/" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
        <tag>总结归纳</tag>
      </tags>
  </entry>
  <entry>
    <title>【现代密码学理论与实践】一个简单的通信游戏“电话掷币”</title>
    <url>/2020/03/18/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p><strong>协议</strong>：一个适当定义的、在<strong>多个参与实体</strong>之间执行的规程。（如果一个规程仅由一个实体执行，那么它只是一种程序，不能称之为协议。）</p>
<p><strong>奇妙函数f</strong></p>
<ol>
<li>对任意整数x，由x计算f(x)是容易的，而给出f(x)，要找出对应的原像x是不可能的，不管x是奇数还是偶数。</li>
<li>不可能找出一对整数(x,y)，满足x≠y且f(x)=f(y)。</li>
</ol>
<p>奇妙函数是构成现代密码学的一个基本要素—<strong>单向函数</strong>。</p>
<ol>
<li>单向函数的存在性意味着安全密码系统的存在性。</li>
<li>安全密码系统的存在性意味着单向函数的存在性。</li>
</ol>
<p><strong>实际效率</strong>：一个密码算法一方面应该设计成容易处理的，以便能被合法用户使用；另一方面还应该是困难的，以便对非用户和攻击者构成一个要解的困难问题。</p>
<p><strong>通信轮数</strong>：通信交互的次数。一个协议的通信轮数超过线性函数，它就不会被人为是实际有效的。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【机器学习】K近邻算法(KNN)</title>
    <url>/2021/09/29/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%91K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>存在一个样本数据集合，也称作为训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一个数据与所属分类的对应关系。输入没有标签的新数据后，将新的数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本最相似数据(最近邻)的分类标签。</p>
<a id="more"></a>
<p>一般来说，我们只选择样本数据集中前k个最相似的数据，这就是K近邻算法中K的出处，通常K是不大于20的整数。最后，选择K个最相似数据中出现次数最多的分类，作为新数据的分类。</p>
<h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>在二维实数向量空间，可以使用两点距离公式计算距离。如果数据是更高维的，可以用欧氏距离(也称欧几里德度量)。</p>
<p>如果算法直接根据距离最近的结果，判断数据分类，这个算法就是最近邻算法，而非K近邻算法。</p>
<p><strong>k-近邻算法步骤</strong>：</p>
<ol>
<li>计算已知类别数据集中的点与当前点之间的距离；</li>
<li>按照距离递增次序排序；</li>
<li>选取与当前点距离最小的K个点；</li>
<li>确定前K个点所在类别的出现频率；</li>
<li>返回前K个点所出现频率最高的类别作为当前点的预测分类。</li>
</ol>
<h3 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h3><ol>
<li>收集数据：可以使用爬虫进行数据的收集，也可以使用第三方提供的免费或收费的数据。一般来讲，数据放在txt文本文件中，按照一定的格式进行存储，便于解析及处理。</li>
<li>准备数据：使用Python解析、预处理数据。</li>
<li>分析数据：可以使用很多方法对数据进行分析，例如使用Matplotlib将数据可视化。</li>
<li>测试算法：计算错误率。</li>
<li>使用算法：错误率在可接受范围内，就可以运行k-近邻算法进行分类。</li>
</ol>
<p><a href="https://jackcui.blog.csdn.net/article/details/75172850" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      <categories>
        <category>人工智能之路</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【总结归纳】哈希函数知识点串讲</title>
    <url>/2020/07/10/%E3%80%90%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3%E3%80%91%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h1>

	<div class="row">
    <embed src="哈希函数知识点串讲.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
        <tag>总结归纳</tag>
      </tags>
  </entry>
  <entry>
    <title>【测试题】对称加密测试题</title>
    <url>/2020/07/10/%E3%80%90%E6%B5%8B%E8%AF%95%E9%A2%98%E3%80%91%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%B5%8B%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="320bff3142a06501d6804be547f1d78c108a1598bf8e813092ffc4e4b82b1483">0c040d35b08962555cdd92e32e511a1860bcaa2de913303e7a607193e3c9d33bb1e12d55ec5b068dd87d8ad1f967dc59e95ef508cd80f6e0a7da28bf9b06b6eb356d4cb9b117b0c1f1f5de0edc6cc0b3d5b01b81ef4761dbd6ece4e986a742d9f8ec786641ffc43956de66c81bf019ecaac804ce60032059736dd153c64d7fb667b644ee4a0bf2988da3dfaa79e9f7e94950a1feb9195c1d55be0566f2a5d681eb9a9658fcb2640f6f4e36bc6142c30f0ea97c106430a214d3344fbf64f8a6c7a7d43611b5dc6b07d468cde32c36b1f291564903dbdd108e83026c0374c80898121b9f56df6235322ffdbe23ab05c652b6d37a48395f763cdb55595a328e805d0418ca5bbbec18bf9b30da402e5f9d8522e129b52e466aa6550156d0b8962261459f50182bcea75d243b095e4ca19c32c55ef1a8eeabab3a28559b069eae7271086dc04e9c06b32f87bf49cbd0039b12f2d908109c7ffcea694eccd662093d3662458c66dcdcc9c2db361d3fad424d7a9e05f5d6b7353863187d8fcf0ee5019602208a74806dec1b049efc6f87528c6116e436cf6220e4ae0a9cbb16bd1e488cfe06d0b43fa2407db33715f1d683f3206be2a4a80ca090229a68dc4cbe7135a639df9c5e28c4d9c1f9ffa52171a7a6e809aed3f7dd99aeda88e8ec1a1f118fd3fe7d744e70ee55a92e455e20ea2bd9c6aef1bdafcfcf15b2f61c6dfaf29b46520c22cc1cd538a80d8833d83383b4eba3c62c75dcdd732f25c9a3c629456e653c27df5e5d1cccd21dfdecb24f57a973bd31cdf12d407d811bdbfc89dda0bf2b31b8e8b7fccf8adba4192f7f30b03db4377e323dfbc844553dcfc89a5b3efeab0d332bdd981c87cfaedb9e999692036f26b7f8dbb4e7610122f58a6cdf1764e569383320324432cb9a0e140c5ece9249f405387e24e11834518b0cf0b4efedc36f20091c445d1dc486e2de170839b6b1d309a2f9ee4dd77720a359bbaa52c8b1c3313140437a97f401f93a644a6a521c9ba3d8698e4bd0325ce53c7d096cc00acc68f0a05eef2d4e1d4b0f1a2216d93252fd3482f933e34b1c9cfb76f65c3df335dda84fd0636fa3a07c8889a030473ad4d47475ced903db6534afe5118579ac4b4d71d20df5c675c41e7ec63881774a46066a9f36cf5be073b639b1f8f03f2b33da8ef6f6390f73a0e526058ef87fb2e1bc2eb6cda256e7d8d2f846e260ffa6577c058383c428fcba7448dd7c157edaa7fb64268bf976aec8470ca62c3349ce71b014bdf9f73546d3681424b2ce8321669280158b70dcbad1e4a7a55c241b6b8172d0bddd5b2c249b7e9cffadb16480d69614e4e6ccd26474a156b133984d1c484a1576e51cac0ce1b49255d0633f47db087e7d52c2de92332aff0d1a428f98ee541ccde71f44d20975b7183dfb164eb943ec5e874469f805b86a298b7a20db4f262ded84e8f4ea2aa5eb1b1eccdd5da62d8cbe4120c76d8e7d77c99b234d763d5a78143835aa0ecbb83585f681894229d62d85bb17d61686e5c31768116e46a4c239bd8b892241a21b3704eba77e1a1ab4a2b17b21d42e1791fac0558e4ac22f210b045a4adf94a29ccb822d5fa41944027837b58c2b713ada73d89b8417280fb061463d70fcc7757321c0fbdce73521c87f489ce16f5970bfceac16267e738aa94bab417ec0b402a3f5295c06bce4e2d915a423f8bafcff8d50eaba2ccc7aa7987c23500f627d08566c7e6e2d3130d7e7d900a5a12ef390f06cee309541c041e374468cb7e7eebc600789649baaa497adcb908907866ed970c498338d21c52510cad0962e4635f27b2893750688a5a0c99c625b7aedca3a62013d7b8d62d43c0c073663a1a0ddd68519c9475830bd593a2b78ba2c63e84c2de9392f3cb9202bf73f62f6cf9669f0a90a6d073f61f692c029051543716205075efd39696f7bdec0ef8609b3a09966b9a94021f644d9e1af941858ed7008921759c0c04477099920075e7d526de6f9b464a576f28efbfff15bcf9b20d2a521a7ca32c884176c8a27f9bf8a00815569e48c5e70af0fcb088e53b488a333b52759d15cfff82eb6c1e4f1efcaaccde16c76f3d4e7f4b3c03a50b5cdfd5d99ec3561642c05a94c7d5b9f48637b1f017f751c78be2673e51aa2749955c20a44a8866e2a1bc48ab0cdbd75a1bb5733079656bf3c5e310fc75171eedeb5e85a989b922f24625a0ee8edac827b7e4baf1600f3fac731ce3096b0e8af4629e2ccfe8f2d38495f1ecb34c8ebd738473cfdb6aa91a1fda28b2b5268bf8095d8e7115036d36bef8035686922d5f6a4ef0e27fcdf60f66f16424e7504e9edf21cdab69012c8abf5c9eea17cce34050dc801b1df2be24a4154a158d42512f468227bb0b727cba8d0538fa035d30b76db63386c7e24d3a158a0399b8767334b51d9d1f1b21134fbb0bc89f546abaef5e5bbab609d3571edf662df69975077a9da17f6cc3f79e4859016c339d19e84eb9efada3b748c9a98f690948b519b2188d3c293cc595c77907895fd41a3208d0506970a3b054e99615e2d79ea40021bd1ddeecdd9a83e1af010cb4ea321ef30b26773058de43852944072f9058f11ed4902b3240fb9d3533258565d66c15b9149dfef57577072e00e3d8d896b00c3662f2bf9ed201fdf8d55cbe3e6d27b07a33b31a2a302bf83866aa29f443b82b64d3911d6bcf150c8894e8da5bd37a2bd44d8b8f376ebb49422443887c65cce98981edcf3a0cdc9a8f50137d4ff838e46df359754eeb45d6f42d75ba1bcbb78f4c387eaa363529d2ce86f8e2aac4578404ed1749730e500903a4a24e920dd72367c58dcf5afbbac794dd38f4b93b4f20a425725fabc904185b31bbe4f31ea434797532435c2f524a1eb010e9b25e145615ee431493b858cf8ceeeb0c2af21590e49f7053fa0a39df944a02ae0f80503ebd7ae9d84f1baad56c654300ffa0d864b1eb1d2155a9e0c7c63a382e075968aa1b9fc942dee6e12358891d5d226ac225840dda64ca9f3634522658d97901dfb9f016ecce27c93610bc6d682aeb650542a6f7b2f99dee0620c63c35c08341d1cd588a42dcf114f611571e4a33375fdafd53c7457b40d104746f26ce64ebd3fc4bb3de09c920acfc040f5061ea6db7a9b8e8caf3663bc1511106f22dd60ccf5b193fb</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>DanBoneh密码学</tag>
        <tag>测试题</tag>
      </tags>
  </entry>
  <entry>
    <title>【现代密码学理论与实践】概率论和信息论</title>
    <url>/2020/03/22/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E4%BF%A1%E6%81%AF%E8%AE%BA/</url>
    <content><![CDATA[<h4 id="标准符号"><a href="#标准符号" class="headerlink" title="标准符号"></a>标准符号</h4><img src="/2020/03/22/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E4%BF%A1%E6%81%AF%E8%AE%BA/%E6%A0%87%E5%87%86%E7%AC%A6%E5%8F%B701.png" class title="标准符号01">
<a id="more"></a>
<img src="/2020/03/22/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E4%BF%A1%E6%81%AF%E8%AE%BA/%E6%A0%87%E5%87%86%E7%AC%A6%E5%8F%B702.png" class title="标准符号02">
<h4 id="概率论的基本概念"><a href="#概率论的基本概念" class="headerlink" title="概率论的基本概念"></a>概率论的基本概念</h4><p>令S为一个任意确定的点的集合，称之为<strong>概率空间</strong>（或<strong>样本空间</strong>）。任意元素 x∈S 成为<strong>样点</strong>（也称为<strong>结果</strong>、<strong>简单事件</strong>或<strong>不可分事件</strong>。一个<strong>事件</strong>（也成为<strong>合成事件</strong>或<strong>可分事件</strong>）是 S 的一个子集，通常用以一个大写字母表示（比如 E ）。<strong>一次实验或观察</strong>是一种从 S 中产生（取出）一个点的动作。一个事件 E 的发生就是一个实验产生某个点 x∈S ，并满足 x∈E 。</p>
<h5 id="概率的经典定义"><a href="#概率的经典定义" class="headerlink" title="概率的经典定义"></a>概率的经典定义</h5><p>假设一个实验可以从 n=#S 个等可能的点中产生一个点，并且每次实验必须产生一个点。令 m 表示事件 E 包含的点的数目，那么称 m/n 为事件 E 发生的概率，并记为</p>
<script type="math/tex; mode=display">
Prob[E]=\frac{m}{n}</script><h5 id="概率的统计定义"><a href="#概率的统计定义" class="headerlink" title="概率的统计定义"></a>概率的统计定义</h5><p>假设在相同条件下进行了 n 次实验，其中事件 E 发生了 μ 次。如果对所有足够大的 n ， μ/n 保持不变，那么就说事件E的概率为 μ/n ，记为</p>
<script type="math/tex; mode=display">
Prob[E]≈\frac{μ}{n}</script><h4 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h4><h5 id="加法规则"><a href="#加法规则" class="headerlink" title="加法规则"></a>加法规则</h5><img src="/2020/03/22/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E4%BF%A1%E6%81%AF%E8%AE%BA/%E5%8A%A0%E6%B3%95%E8%A7%84%E5%88%99.png" class title="加法规则">
<h6 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h6><p>设 E、F 为两个事件，且 E 的概率不为 0 。在 E 发生的条件下 F 发生的概率称为已知 E 时 F 的条件概率，记为</p>
<script type="math/tex; mode=display">
Prob[E|F]=\frac{Prob[E∩F]}{Prob[E]}</script><h6 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h6><p>事件 E、F 是相互独立的，当且仅当</p>
<script type="math/tex; mode=display">
Prob[E|F]=Prob[F]</script><h5 id="乘法规则"><a href="#乘法规则" class="headerlink" title="乘法规则"></a>乘法规则</h5><img src="/2020/03/22/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E4%BF%A1%E6%81%AF%E8%AE%BA/%E4%B9%98%E6%B3%95%E8%A7%84%E5%88%99.png" class title="乘法规则">
<h5 id="全概率定律"><a href="#全概率定律★" class="headerlink" title="全概率定律★"></a>全概率定律★</h5><img src="/2020/03/22/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E4%BF%A1%E6%81%AF%E8%AE%BA/%E5%85%A8%E6%A6%82%E7%8E%87%E5%AE%9A%E5%BE%8B.png" class title="全概率定律">
<h4 id="随机变量及其概率分布"><a href="#随机变量及其概率分布" class="headerlink" title="随机变量及其概率分布"></a>随机变量及其概率分布</h4><h5 id="离散随机变量及其分布函数"><a href="#离散随机变量及其分布函数" class="headerlink" title="离散随机变量及其分布函数"></a>离散随机变量及其分布函数</h5><ol>
<li><p>一个（离散）随机变量是一个实验的数字化结果。它是定义在一个（离散）样本空间上的函数。</p>
</li>
<li><p>设 S 为一个（离散）概率空间，ξ 为一个随机变量。ξ 的（离散）分布函数是 S→R 的一个函数，以一个概率值</p>
<script type="math/tex; mode=display">
Prob[ξ=x_i]=p_i（i=1,2,...,S）</script><p>列表为条件，并满足下面的条件</p>
<script type="math/tex; mode=display">
1.p_i≥0</script><script type="math/tex; mode=display">
2.\sum_{1}^{S}{p_i}=1</script></li>
</ol>
<h5 id="二项式分布"><a href="#二项式分布" class="headerlink" title="二项式分布"></a>二项式分布</h5><p>如果随机变量 ξn 取值为0，1，…，n，且对每一个 p ，0&lt;p&lt;1 ，有</p>
<script type="math/tex; mode=display">
Prob[ξ_n=k]=(_k^n)p^k(1-p)^(n-k)（k=0,1,2,...,n）</script><p>那么称 ξn 服从<strong>贝努利分布</strong>，用 b(k ; n , p) 表示一个贝努利项，其中 k=0,1,2,…,n 且 0&lt;p&lt;1 。</p>
<h6 id="中心项"><a href="#中心项" class="headerlink" title="中心项"></a>中心项</h6><p>相邻的二项式两项的比值是</p>
<script type="math/tex; mode=display">
\frac{b(k；n，p)}{b(k-1 ；n ，p)}=\frac{(n-k+1)p}{k(1-p)}=1+\frac{(n+1)p-k}{k(1-p)}</script><p>当 k&lt;(n+1)p 时，其值为正；当 k&gt;(n+1)p 时，其值为负。因此在 k=(n+1)p 时，二项式 b(k ; n , p) 达到最大值。此二项式 b((n+1)p ; n , p) 称为<strong>中心项</strong>。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【现代密码学理论与实践】防守与攻击</title>
    <url>/2020/03/18/%E3%80%90%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%91%E9%98%B2%E5%AE%88%E4%B8%8E%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>对于消息M（不管是明文还是密文）、密码算法A（不管它代表加密还是解密）、密钥K（不管它是加密密钥还是解密密钥），我们可以用<code>M&#39;=A(K,M)</code>表示一个<strong>密码变换</strong>。</p>
<p>在对称密码体制种，我们可以认为K’=K；在公钥密码体制中，K’表示K的秘密部分或与K相匹配的部分。密文习惯记为${M}_K$。</p>
<p><strong>用符号${M}_K$表示的完善加密</strong></p>
<ol>
<li>不用密钥K（在对称密码体制中），或者不用与K相匹配的私钥（在公钥密码体制中），密文${M}_K$不提供任何求解明文消息M的密码分析方法。</li>
<li>密文${M}_K$也许还有一些关于明文消息M的已知信息，不提供任何求解密钥K（在对称密码体制中）或与K相匹配的私钥（在公钥密码体制中）的密码分析方法。</li>
<li>（用于消息认证服务）如果没有密钥K，即使知道明文M，要想更改${M}_K$而不被接收者在解密阶段发现是不可能的。</li>
</ol>
<p>具有这两个性质的完善加密是对现实世界中存在的加密算法的理想化。完善加密并不能防止协议含有安全缺陷。</p>
<a id="more"></a>
<p><strong>Dolve-Yao威胁模型</strong>——密码协议的标准威胁模型[102]</p>
<p>在这个模型中，攻击者有如下特征：</p>
<ol>
<li>他能获得经过网络的任何消息。</li>
<li>他是网络的一个合法使用者，因而能够发起与任何其他用户的对话。</li>
<li>他有机会成为任何主体发出信息的接收者。</li>
<li>他能够冒充任何别的主体给任意主体发消息。</li>
</ol>
<p>在不对“不能做”的意思量化的情况下，攻击者不能做的事情：</p>
<ol>
<li>攻击者不能猜到从足够大的空间中选出的随机数。</li>
<li>没有正确的密钥（或私钥），攻击者不能由给定的密文恢复出明文；对于完善加密算法，攻击者也不能从给定的明文构造出正确的密文。</li>
<li>攻击者不能求出私有部分，比如：与给定的公钥相匹配的私钥。</li>
<li>攻击者虽然能控制我们的计算和通信环境的大量公共部分，但一般他不能控制计算环境中的许多私有区域，如：访问离线主体的存储器。</li>
</ol>
<p><strong>认证服务器</strong>：它根据它所服务的主体的名字维护一个检索数据库，并能够递送通过请求主体密钥所计算出来的身份信息，而该密钥为服务器和主体所共享。认证服务器是一种特殊的主体，成为<strong>可信第三方</strong>或<strong>TTP</strong>。</p>
<p>在同一个认证服务器提供服务下，假定Alice和TTP共享一个密钥，密钥由<strong>$K_{AT}$</strong>表示，成为<strong>密钥-加密密钥</strong>或<strong>长期密钥</strong>。</p>
<p>一个<strong>共享密钥</strong>只能用于一次通信会话，因此这种密钥也称<strong>会话密钥</strong>和<strong>短期密钥</strong>。</p>
<p><strong>“消息认证”协议</strong>：将消息和通信主体相绑定。可利用<strong>消息重放攻击</strong>。</p>
<p>如果主体的身份对于消息的意义来说是必要的，那么为了保险起见，应当在消息中明确置入主体的名字。</p>
<p><strong>“询问-应答”协议</strong>：以运行的随机数为nonce，表示仅使用一次的数字。又称<strong>Needham-Schroeder对称密钥认证协议</strong>。阻截通信信道，利用消息重放攻击。</p>
]]></content>
      <categories>
        <category>密码学之路</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>【记录】实验室学习(研一寒假篇)</title>
    <url>/2021/01/30/%E3%80%90%E8%AE%B0%E5%BD%95%E3%80%91%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%AD%A6%E4%B9%A0-%E7%A0%94%E4%B8%80%E5%AF%92%E5%81%87%E7%AF%87/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1bcb323c411133d3f922b884e1013cbe2759de447422977251c8e2daaf0c0dfb">ac3471d48b2ea1bf8bfcc4b6afdfd16f5e07f70e1a6221325720049cccd56c68419eeb013f7780e3b53c6cc5c88f75e062f975bcd8c744fec58a8b6755a53c7a05ec7013dc6bad61f9807a7155df7b2f2a2f17afb77e1cbfb2c2da051956da1e27e0dfee97491cd670d36c4e1a44cccc533bd3f99e395f3d8eea77fb45f51dc07813d018dc8db48d63b5475ac5600ab28e27be1e348d407c7d1a5e5d9d6c22fd3696afc0dc0056b8499b5e0fe23afad883be2ef66c26b339e791db257fb774f89b584e0dc642f90f43597afe2d901b247e347729be69cb503a050a79e87b222db0fbd67406014a869017cc0f05c0debe9222571747377dbb7df9acc484522f5e6d868083c67d112cac37a422d1e8f77bcc5a7181e692a333b5956c9666f2c3b9b695f4812d1d09c2216963e566d8e708262e1f0216a53347f44fafeec0477e83f9941cbf765192d1369366d751a16debfb8dd8b4ea5cb17dadd7289e6c8e98405844c11e8976fc9ad1b91b134ddeaacb0f942f8e65d76b3fe161fbcda8dbb7fd0067bb809a241f8b1820b6f9b2ed5e302de1721e18fed6dba9ae9486bbd8e8d21b5fbbc833e86da1ca4061783473eb634c925094906749af67a7cf7ea7f01684c3a2ec95f17fe73e1972613d85bcef4dcf08904e0db5425c970ee4fdbb7e07b42bd2b81727623c47b2f2434df42dc9123ab1654e24272be9b3242fc3d31f883535c47d4a478898a17adb8c2337f9c478d90b3002f83464e0b90ae9de743da4e1942b1d2139ba92f4c7813342acc1d3ad40bde7f0c8cb72253f931b1bae2e6f3cf12bacfd4daa3526bea7c47af76f36cfe709facb54485a66939c0fe510164041366a284b5138951b530c3eb0cee62e7b0350419b3686f9c572d933ec318a7283f25872bff6101b93550c2e4274922efd8009a4e6df19d85b3fcfc3b9f08e729e62ada3a88f6ab1e9d08da4792a17bdbae4bc648800ab01b298e2a294ee6a3af1f8e266c9e8ce22a0c98bdae9588c9d690cb55eac89670b4227eeb27ad66a83610dec783edce12f4b0b59466c02eac6a393d33ec09667aeead645ce1d71578c4b8f2ef00a5713fd7d646d65a5fb148388f586a4a55346540fd6794adc3301d176198dfa721fb407a641ec8d8e9fd1be58186ac9bd50e6e6e98d97284cd7d15a6d0bbf024e31f004d40aadf0ef5c468798299268f7dc1c7bec68d1e0945858ac9055b09382e98adfd134b1bcd9e4d334a7bec4c50e084e097d66fbb62dc45d61bdc342b4a1cc693dfbd414f15565c0478e0bfdb1e9715e36d615faf5e7f7a2cb09efbfc29e27ce7964d068d5f101e547d1024bd57e30c2ccaec57c259efac247b8ccb9b326c45035a28699e6ad597dd2426bfe758cd5f9d8aea3f4ba3ce7589feede89ead9ecdcb31ffa69aa80fb920d4d6f466c55f21eafe58d39102067eb48ad3762d310c01bf804a1ac56c0dfa63e7915a974c232bb86fcbe212beb105adf1a38154b6568bf862ef8ee5c027c0bc9d985e6759236b0fbaeb64083814946efbce87c67507540a9d4d639752a8422895af572469c8e864caffad3fcaf4c075d8b5d30eed96a51c8b22933b1a3a56865bdc643e0cf10b62cb9479d9502b0e20b144aeffeec485375a455db48aed1557b8ce0e4d1b3046f593e42ad72efda138b31b2de79fd0775887b47eec82139aecfb1265a5e58c60ac2f727d39e693904248e9023e822e29c51f3eb0f03a2e86c28bedef7bd7d819cdd35dd79e8e4b18777e61e1ddc5db99f88c6a0fe00f256e7a50208806e212f90b5782154c887bced4fd40f735e734e23f23d3b4e18fc5dac281ff6378ced829fae866b94941f766ed2368492ace647bd2ab5ad03689d7800ac1b339ab4e479509246981a8cc1d945255b16592d302e0bb3ccf2bd164ca21dcd6cd2ca5e700d405500bf82a5e75f48139b7bac491945b1b1758e3a406942cda2cec63a60b95d7a08d103665d5cd66c0442d4f0b5c56fd72cde23563b7f27cf88a96aa9a5b0468c93168c2fff01ef5c799e489359f1d78d293669ffbb4164ab84772d5dcdf34e33f36842ce54889890ddb5e0c16521c159847e95b5c425cfb9563034ae8d2e54dad4ca195e32f16c5899bb0a58e3dc9a472ccc5e7fd43c3fbdff94a966a69aaafbae27844ab5dea0a50a5ad37d8cd09f0463b1cbde06a90fc1784550779cc69db23b8fd7fe629700501b8d3054b596d1afaf313cd3063e1ca958c705ff375a7ee19e69d9fec7d2d411f045033a15c87b440091b9349f3d9cc8dfb7068a8aabce046c48d595ad8f85d646d8cefc56d9d9d40c852ffe1f0055f12657703efeb86588d04d78f6f16646ee43617837f384634031eb154719d09fe5826d0e8458f2243514687bbf6b72473d26ddef60bb16bd9b1c50071125c4432c8f7ca7475dcbf38e1a3182ba01984d5c8aa7c065dd3e58dd615ddd7bec984e9db9379fc5e5d0eb51087595ac0413af50aca2987535fe24748a16fdc4f5ae34c6b3023ecd27b65d41867225a739a0e529a8fc023fc13b222d9d739c1429ccab59b6e545fc2d9d917c1536b30a8307c9cc9a14722db60243f8cc4430b95f2981ec570296c6ea21cacfcf1500584c9d90b334404a78ba382cc346458c8b91a27ce48ba27ffa98269910253d2b1c5d18ed224e5c36ed12136a8e3180fe8a3e950ed5e511c70a89c43e89cd3e57cc3909f368bd816407939b660c275252611fb47dcbf1d950640c3535fd95baa656f725ad1e4468184cdf66b071e3f2456ad4d23c872a7edb3f9a4046f43c6ca0492191754b3a0ec680605ee12cf4841e302066b2694f528e5e8b15df19269642a5d3008446777ea1cb4f4d4087e21e1654f7e423b6f8a9d52570fbc7a72cbeaa0bf0c566d07f440f265fb2f6cab1daf6eb51086607031b1f5d10dbca6c572df5f4eddd5e7c008fdd805d7f57966b001360f19ebab4d8d5f6765e44d9b32b9e545357fefcc36ec5e412db7cf208b7b63a62dfa91f22916bbe168525454f835906f420f9aa3710c89124cfa4f2cf932ead93bc45b8158f0bb4bdc9d683b2a3d3e3b2ef759918d395143cbae32394f674c1d54eb1864bffde2e40fa6b5b0af04e9fba7c779777afa666063cf2d90963c86f7353682787565d7ba2228c24d0a48ce59716a4ce638d6dd30f159099b3169d195fe0abb8f0aecaa7b14b2c90dc4d2213a05df32fc01266a629f3a1f3cdef95ff10263b8cfb87fdbd29833705d9ef96ebf5e0b84e5227afc83c079c257c00cacb94ccebe252f955740c28a800cdf44d136b562b8bee81d744ca20bfbb2ebabc108e5b0b396ef0bd6027961a236cc37fbcde28e62be0804f4ed3cf5eaaf541603633df053d318681c0e3342efe57c67b1cf3e432f32d5fd1ee98960a1df11cec0246b323ba5dd06cce2167bcfbca50063fd0824ee8c8ebd583a402665e2c12d789ec99d6aebd9698da19dff6608558b4d8bb3d47eb68752a9903efd81495100043cb0c7baa2d4de4236e91b967bb4ecccb151f48c8807959b1f7314ffd0c0ca63f419f3f62d1c4ba4d5f103d4640720567008a4c48ff198e4d9ee25636d2e31d758549eb8f9a420fcc47d0005ad894f22893716faba17d08708491241798cabd327c4ee1ca6c3e5e3d64a9eee42085096f4bc5b7ae0884720dcd193a816504087f96f79caec444bc23d40fb4d4b8907d6d5e2eae31b48004299b2b90acd9803f64e643fab9534f92ce7912911a0a099f19b22bc376eee6453f662b29ac68e503dac0adf9ee12c91e0d8c46d4482477fa75c2149276220cfbd442bfca2953e466b5f91aa555b4400fc1356691f1de6f7a81d1ced13084f070635b0cbd634901be5a2a8b4dc03fec727840f3ff2a77466811673e5d7fe580f1425da2dc7fd21306b12caa71b8f10eb5c0aaced0f34af5b63739569f346bf1994cd3971c406aec31734a0488dcc45d5fc27abb4960abeae6f18ccbd8bd2e3947401df6bac47bc347c6ca1f3d9c2b84fc4f004f0fca2bca2aa128ab072a97e897ab33c0ff0614d40690afa4fa04370be8c2b29be919ee55182df4f6988fcc9ff600ece77979d40757d28f66090c654c941e3f0969df8b953586e88f6e0cb56414b1accc66bb44799a3e1dcf53c661a04bc8bc5e2ff1abba016cdb0503295b90ded8a0537de5b8c4be86b5cc568227084ca9bdae5e5499d176e74963e7fa12209b80375e1b99f10561fa0ce104ed308736ee3e8cd2ab0b30a09bd2680dba10910c2eac6cb931aee00f6d2020232f029ee55989f1f6e2ffb46060feeaf6759c6eea10b7873c267cc458a75791ac844fcc72daeab423b3289231e8193ba742e8c14c1fc36df410fe9742d8314970473ef7386c78484ea07d975bbfe1ff05520087ec346aa4957f02927b825a89c955a1a644603facc3944be702e5f7f261f51ab242282883882fcb20e5994ff1dcb4e736754aab2539b2ed191c22202baa73e138488d206a809ba0e3a57b9e2b4a87a36a10560d17f06918ab6ec1569a4ce9604cc73d746c82468d224fa56813e0d0bfc2a56e6ccd6f972ce78dc89a3f8c67919f83df8b4eb2124a7faaf0c98f8ff280224ce14d367d879025d90f1aefc849b142d1d29ef3fad3d87a1f7b1835e7cde48ed809ad86b49ba2951eb62f0dcc503762a625ff67569fcd6dc691066876b7bae856905b3257304069d55f2d3cf6b2124610200615852fdd0274439f2170ac528baf5a21362b1c0a8d0a90d9010403578f46a679835f6b81464474cbb56595f34536146ad74506743f646efb33611c165e3d91ef69b9cbb3aec4c0c661853766acb81cd31e971a70eeeecb487893d58e85f84d59bcc8e236ca7f8d0ed4a5a134ec17beda11784e8cee7e0c3150b8b8f5c70ecd2ad421f2933b1e5719fee33173ab42252d2225f09e06e4b69435edd4ba6f875843097aeba8dd5fa80387ae5dd3ea50</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>研究生之路</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>【踩坑】npm下载需要管理员权限问题</title>
    <url>/2021/10/07/%E3%80%90%E8%B8%A9%E5%9D%91%E3%80%91npm%E4%B8%8B%E8%BD%BD%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>安装配置Node后，利用npm下载包</p>
<p>报错：<code>npm ERR! Please try running this command again as root/Administrator</code></p>
<a id="more"></a>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>这是由于我们在配置Node环境时修改了路径，在nodejs中创建了<code>node_global</code>和<code>node_cache</code>两个文件夹，而这两个文件夹的创建需要管理员权限，那么，以后执行npm命令自然也需要以管理员身份运行命令行。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>网上现有解决方法有很多是让删除<code>C:\Users\{账户}\下的.npmrc</code>文件，但是！！这个文件存放了修改路径的代码，删除后，虽然解决了npm报错问题，但是下载的路径依然是默认的<code>C:\Users\{账户}\AppData\Roaming\npm</code>，不方便管理且占用C盘空间。</p>
<p>我们可以修改nodejs文件夹的授权，将其所有组和用户名的权限改为“完全控制”，问题得以解决。</p>
<img src="/2021/10/07/%E3%80%90%E8%B8%A9%E5%9D%91%E3%80%91npm%E4%B8%8B%E8%BD%BD%E9%9C%80%E8%A6%81%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE.png" class title="权限设置">
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
</search>
